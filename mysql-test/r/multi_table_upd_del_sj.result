CREATE TABLE class(class_num INT NOT NULL PRIMARY KEY, class_name VARCHAR(20)) ENGINE=INNODB;
CREATE TABLE student(stu_name VARCHAR(20) NOT NULL PRIMARY KEY, stu_city VARCHAR(20), stu_id INT) ENGINE=INNODB;
CREATE TABLE roster(ros_num INT NOT NULL PRIMARY KEY, class_num INT, stu_name VARCHAR(20), FOREIGN KEY fk1(class_num) REFERENCES class(class_num), FOREIGN KEY fk2(stu_name) REFERENCES student(stu_name)) ENGINE=INNODB;
INSERT INTO class VALUES(1,'math'),(2,'science'),(3,'history'),(4,'geog');
INSERT INTO student VALUES('amit','bangalore',1),('ashu','hyderabad',2),('sumit','kota',2),('rajdeep','bbsr',4);
INSERT INTO roster VALUES(1,3,'amit'),(2,4,'amit'),(3, 1, 'ashu'),(4,3,'ashu'),(5,1,'sumit'),(6,4,'sumit');
CREATE TABLE ot1(a INT) ENGINE=INNODB;
CREATE TABLE ot2(a INT) ENGINE=INNODB;
CREATE TABLE ot3(a INT) ENGINE=INNODB;
CREATE TABLE it1(a INT) ENGINE=INNODB;
CREATE TABLE it2(a INT) ENGINE=INNODB;
CREATE TABLE it3(a INT) ENGINE=INNODB;
INSERT INTO ot1 VALUES(0),(1),(2),(3),(4),(5),(6),(7);
INSERT INTO ot2 VALUES(0),(2),(4),(6);
INSERT INTO ot3 VALUES(0),(3),(6);
INSERT INTO it1 VALUES(0),(1),(2),(3),(4),(5),(6),(7);
INSERT INTO it2 VALUES(0),(2),(4),(6);
INSERT INTO it3 VALUES(0),(3),(6);
COMMIT;
# The optimizer_switch is set to default. We are verifying the various supported JOIN types for SEMI-JOIN
SET optimizer_switch=default;
COMMIT;
SET autocommit=off;
EXPLAIN EXTENDED UPDATE class JOIN roster ON class.class_num=roster.class_num
SET class.class_name='geography'
	      WHERE class.class_num IN (SELECT class_num FROM roster);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	roster	index	fk1	fk1	5	NULL	6	100.00	Using index; LooseScan
1	SIMPLE	class	ALL	PRIMARY	NULL	NULL	NULL	4	75.00	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	roster	ref	fk1	fk1	5	test.roster.class_num	1	100.00	Using index
EXPLAIN EXTENDED UPDATE class JOIN roster ON class.class_num=roster.class_num 
SET class.class_name='geography' 
WHERE roster.class_num IN (SELECT class_num FROM roster);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	roster	index	fk1	fk1	5	NULL	6	100.00	Using where; Using index; LooseScan
1	SIMPLE	roster	ref	fk1	fk1	5	test.roster.class_num	1	100.00	Using index
1	SIMPLE	class	ALL	PRIMARY	NULL	NULL	NULL	4	75.00	Using where; Using join buffer (Block Nested Loop)
EXPLAIN EXTENDED UPDATE student JOIN roster ON student.stu_name=roster.stu_name 
SET student.stu_city='kolkata' 
WHERE student.stu_name IN (SELECT stu_name FROM roster);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	roster	index	fk2	fk2	23	NULL	6	100.00	Using index; LooseScan
1	SIMPLE	student	ALL	PRIMARY	NULL	NULL	NULL	4	75.00	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	roster	ref	fk2	fk2	23	test.roster.stu_name	1	100.00	Using index
EXPLAIN EXTENDED UPDATE student JOIN roster ON student.stu_name=roster.stu_name 
SET student.stu_city='kolkata' 
WHERE roster.stu_name IN (SELECT stu_name FROM roster);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	roster	index	fk2	fk2	23	NULL	6	100.00	Using where; Using index; LooseScan
1	SIMPLE	roster	ref	fk2	fk2	23	test.roster.stu_name	1	100.00	Using index
1	SIMPLE	student	ALL	PRIMARY	NULL	NULL	NULL	4	75.00	Using where; Using join buffer (Block Nested Loop)
EXPLAIN EXTENDED UPDATE LOW_PRIORITY class JOIN roster ON class.class_num=roster.class_num 
SET class.class_name='geography' 
WHERE class.class_num IN (SELECT class_num FROM roster);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	roster	index	fk1	fk1	5	NULL	6	100.00	Using index; LooseScan
1	SIMPLE	class	ALL	PRIMARY	NULL	NULL	NULL	4	75.00	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	roster	ref	fk1	fk1	5	test.roster.class_num	1	100.00	Using index
EXPLAIN EXTENDED UPDATE IGNORE class JOIN roster ON class.class_num=roster.class_num 
SET class.class_name='geography' 
WHERE roster.class_num IN (SELECT class_num FROM roster);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	roster	index	fk1	fk1	5	NULL	6	100.00	Using where; Using index; LooseScan
1	SIMPLE	roster	ref	fk1	fk1	5	test.roster.class_num	1	100.00	Using index
1	SIMPLE	class	ALL	PRIMARY	NULL	NULL	NULL	4	75.00	Using where; Using join buffer (Block Nested Loop)
EXPLAIN EXTENDED UPDATE class RIGHT JOIN roster ON class.class_num=roster.class_num 
SET class.class_name='geography' 
WHERE roster.class_num IN (SELECT class_num FROM roster);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	roster	index	fk1	fk1	5	NULL	6	100.00	Using where; Using index; LooseScan
1	SIMPLE	roster	ref	fk1	fk1	5	test.roster.class_num	1	100.00	Using index
1	SIMPLE	class	ALL	PRIMARY	NULL	NULL	NULL	4	75.00	Using where; Using join buffer (Block Nested Loop)
EXPLAIN EXTENDED UPDATE student LEFT JOIN roster ON student.stu_name=roster.stu_name 
SET student.stu_city='kolkata' 
WHERE student.stu_name IN (SELECT stu_name FROM roster);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	roster	index	fk2	fk2	23	NULL	6	100.00	Using index; LooseScan
1	SIMPLE	student	ALL	PRIMARY	NULL	NULL	NULL	4	75.00	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	roster	ref	fk2	fk2	23	test.roster.stu_name	1	100.00	Using index
EXPLAIN EXTENDED UPDATE class INNER JOIN roster ON class.class_num=roster.class_num 
SET class.class_name='geography' 
WHERE class.class_num IN (SELECT class_num FROM roster);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	roster	index	fk1	fk1	5	NULL	6	100.00	Using index; LooseScan
1	SIMPLE	class	ALL	PRIMARY	NULL	NULL	NULL	4	75.00	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	roster	ref	fk1	fk1	5	test.roster.class_num	1	100.00	Using index
EXPLAIN EXTENDED UPDATE ot1 LEFT JOIN ot2 ON ot1.a=ot2.a 
SET ot1.a = 111, ot2.a = 222 
WHERE ot1.a IN (SELECT a FROM it3 ORDER BY a);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	<subquery2>	ALL	NULL	NULL	NULL	NULL	NULL	0.00	NULL
1	SIMPLE	ot1	ALL	NULL	NULL	NULL	NULL	8	100.00	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	ot2	ALL	NULL	NULL	NULL	NULL	4	100.00	Using where; Using join buffer (Block Nested Loop)
2	MATERIALIZED	it3	ALL	NULL	NULL	NULL	NULL	3	100.00	NULL
EXPLAIN EXTENDED UPDATE ot1 LEFT JOIN ot2 ON ot1.a=ot2.a 
SET ot1.a = 111 
WHERE COALESCE(ot2.a,0) IN (SELECT a FROM it3);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	<subquery2>	ALL	NULL	NULL	NULL	NULL	NULL	0.00	NULL
1	SIMPLE	ot1	ALL	NULL	NULL	NULL	NULL	8	100.00	Using join buffer (Block Nested Loop)
1	SIMPLE	ot2	ALL	NULL	NULL	NULL	NULL	4	100.00	Using where; Using join buffer (Block Nested Loop)
2	MATERIALIZED	it3	ALL	NULL	NULL	NULL	NULL	3	100.00	NULL
EXPLAIN EXTENDED UPDATE ot1 LEFT JOIN ot2 ON ot1.a=ot2.a 
SET ot1.a = 111, ot2.a = 222 
WHERE (ot1.a,ot2.a) IN (SELECT a,a FROM it3 ORDER BY 2);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	<subquery2>	ALL	NULL	NULL	NULL	NULL	NULL	0.00	Using where
1	SIMPLE	ot2	ALL	NULL	NULL	NULL	NULL	4	100.00	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	ot1	ALL	NULL	NULL	NULL	NULL	8	100.00	Using where; Using join buffer (Block Nested Loop)
2	MATERIALIZED	it3	ALL	NULL	NULL	NULL	NULL	3	100.00	NULL
EXPLAIN EXTENDED UPDATE ot1 JOIN ot2 ON ot1.a=ot2.a AND ot1.a IN (SELECT a FROM it3) 
SET ot1.a = 111, ot2.a = 222 
WHERE ot1.a IN (SELECT a FROM it3);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	<subquery3>	ALL	NULL	NULL	NULL	NULL	NULL	0.00	Using where
1	SIMPLE	ot1	ALL	NULL	NULL	NULL	NULL	8	100.00	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	<subquery2>	eq_ref	<auto_key>	<auto_key>	5	<subquery3>.a	1	100.00	NULL
1	SIMPLE	ot2	ALL	NULL	NULL	NULL	NULL	4	100.00	Using where; Using join buffer (Block Nested Loop)
3	MATERIALIZED	it3	ALL	NULL	NULL	NULL	NULL	3	100.00	NULL
2	MATERIALIZED	it3	ALL	NULL	NULL	NULL	NULL	3	100.00	NULL
EXPLAIN EXTENDED UPDATE ot1 JOIN ot2 ON ot1.a IN (SELECT a FROM it3) 
SET ot1.a = 111, ot2.a = 222 
WHERE ot1.a IN (SELECT a FROM it3);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	<subquery3>	ALL	NULL	NULL	NULL	NULL	NULL	0.00	Using where
1	SIMPLE	ot1	ALL	NULL	NULL	NULL	NULL	8	100.00	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	<subquery2>	eq_ref	<auto_key>	<auto_key>	5	<subquery3>.a	1	100.00	NULL
1	SIMPLE	ot2	ALL	NULL	NULL	NULL	NULL	4	100.00	Using join buffer (Block Nested Loop)
3	MATERIALIZED	it3	ALL	NULL	NULL	NULL	NULL	3	100.00	NULL
2	MATERIALIZED	it3	ALL	NULL	NULL	NULL	NULL	3	100.00	NULL
EXPLAIN EXTENDED UPDATE ot1 LEFT JOIN (ot2 JOIN ot3 ON ot2.a=ot3.a) ON ot1.a=ot2.a AND ot1.a IN (SELECT a FROM it1 ORDER BY a) 
SET ot1.a = 111 
WHERE ot1.a IN (SELECT a FROM it3 ORDER BY a);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	<subquery3>	ALL	NULL	NULL	NULL	NULL	NULL	0.00	NULL
1	SIMPLE	ot1	ALL	NULL	NULL	NULL	NULL	8	100.00	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	it1	ALL	NULL	NULL	NULL	NULL	8	100.00	Using where; FirstMatch(ot1)
1	SIMPLE	ot3	ALL	NULL	NULL	NULL	NULL	3	100.00	Using where
1	SIMPLE	ot2	ALL	NULL	NULL	NULL	NULL	4	100.00	Using where
3	MATERIALIZED	it3	ALL	NULL	NULL	NULL	NULL	3	100.00	NULL
UPDATE class JOIN roster ON class.class_num=roster.class_num
SET class.class_name='geography'
	      WHERE class.class_num IN (SELECT class_num FROM roster);
SELECT * FROM class;
class_num	class_name
1	geography
2	science
3	geography
4	geography
ROLLBACK;
UPDATE class JOIN roster ON class.class_num=roster.class_num 
SET class.class_name='geography' 
WHERE roster.class_num IN (SELECT class_num FROM roster);
SELECT * FROM class;
class_num	class_name
1	geography
2	science
3	geography
4	geography
ROLLBACK;
UPDATE student JOIN roster ON student.stu_name=roster.stu_name 
SET student.stu_city='kolkata' 
WHERE student.stu_name IN (SELECT stu_name FROM roster);
SELECT * FROM student;
stu_name	stu_city	stu_id
amit	kolkata	1
ashu	kolkata	2
rajdeep	bbsr	4
sumit	kolkata	2
ROLLBACK;
UPDATE student JOIN roster ON student.stu_name=roster.stu_name 
SET student.stu_city='kolkata' 
WHERE roster.stu_name IN (SELECT stu_name FROM roster);
SELECT * FROM student;
stu_name	stu_city	stu_id
amit	kolkata	1
ashu	kolkata	2
rajdeep	bbsr	4
sumit	kolkata	2
ROLLBACK;
UPDATE LOW_PRIORITY class JOIN roster ON class.class_num=roster.class_num 
SET class.class_name='geography' 
WHERE class.class_num IN (SELECT class_num FROM roster);
SELECT * FROM class;
class_num	class_name
1	geography
2	science
3	geography
4	geography
ROLLBACK;
UPDATE IGNORE class JOIN roster ON class.class_num=roster.class_num 
SET class.class_name='geography' 
WHERE roster.class_num IN (SELECT class_num FROM roster);
SELECT * FROM class;
class_num	class_name
1	geography
2	science
3	geography
4	geography
ROLLBACK;
UPDATE class RIGHT JOIN roster ON class.class_num=roster.class_num 
SET class.class_name='geography' 
WHERE roster.class_num IN (SELECT class_num FROM roster);
SELECT * FROM class;
class_num	class_name
1	geography
2	science
3	geography
4	geography
ROLLBACK;
UPDATE student LEFT JOIN roster ON student.stu_name=roster.stu_name 
SET student.stu_city='kolkata' 
WHERE student.stu_name IN (SELECT stu_name FROM roster);
SELECT * FROM student;
stu_name	stu_city	stu_id
amit	kolkata	1
ashu	kolkata	2
rajdeep	bbsr	4
sumit	kolkata	2
ROLLBACK;
UPDATE class INNER JOIN roster ON class.class_num=roster.class_num 
SET class.class_name='geography' 
WHERE class.class_num IN (SELECT class_num FROM roster);
SELECT * FROM class;
class_num	class_name
1	geography
2	science
3	geography
4	geography
ROLLBACK;
UPDATE ot1 LEFT JOIN ot2 ON ot1.a=ot2.a 
SET ot1.a = 111, ot2.a = 222 
WHERE ot1.a IN (SELECT a FROM it3 ORDER BY a);
SELECT * FROM ot1;
a
111
1
2
111
4
5
111
7
SELECT * FROM ot2;
a
222
2
4
222
ROLLBACK;
UPDATE ot1 LEFT JOIN ot2 ON ot1.a=ot2.a 
SET ot1.a = 111 
WHERE COALESCE(ot2.a,0) IN (SELECT a FROM it3);
SELECT * FROM ot1;
a
111
111
2
111
4
111
111
111
ROLLBACK;
UPDATE ot1 LEFT JOIN ot2 ON ot1.a=ot2.a 
SET ot1.a = 111, ot2.a = 222 
WHERE (ot1.a,ot2.a) IN (SELECT a,a FROM it3 ORDER BY 2);
SELECT * FROM ot1;
a
111
1
2
3
4
5
111
7
SELECT * FROM ot2;
a
222
2
4
222
ROLLBACK;
UPDATE ot1 JOIN ot2 ON ot1.a=ot2.a AND ot1.a IN (SELECT a FROM it3) 
SET ot1.a = 111, ot2.a = 222 
WHERE ot1.a IN (SELECT a FROM it3);
SELECT * FROM ot1;
a
111
1
2
3
4
5
111
7
SELECT * FROM ot2;
a
222
2
4
222
ROLLBACK;
UPDATE ot1 JOIN ot2 ON ot1.a IN (SELECT a FROM it3) 
SET ot1.a = 111, ot2.a = 222 
WHERE ot1.a IN (SELECT a FROM it3);
SELECT * FROM ot1;
a
111
1
2
111
4
5
111
7
SELECT * FROM ot2;
a
222
222
222
222
ROLLBACK;
UPDATE ot1 LEFT JOIN (ot2 JOIN ot3 ON ot2.a=ot3.a) ON ot1.a=ot2.a AND ot1.a IN (SELECT a FROM it1 ORDER BY a) 
SET ot1.a = 111 
WHERE ot1.a IN (SELECT a FROM it3 ORDER BY a);
SELECT * FROM ot1;
a
111
1
2
111
4
5
111
7
ROLLBACK;
# The following queries would select Firstmatch based on the optimizer switch settings
# Please note that some of the queries would still show Duplicate Weedout
SET optimizer_switch='semijoin=on,firstmatch=on,materialization=off,loosescan=off,index_condition_pushdown=off,mrr=off';
COMMIT;
EXPLAIN EXTENDED UPDATE class JOIN roster ON class.class_num=roster.class_num
SET class.class_name='geography'
	      WHERE class.class_num IN (SELECT class_num FROM roster);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	class	ALL	PRIMARY	NULL	NULL	NULL	4	100.00	NULL
1	SIMPLE	roster	ref	fk1	fk1	5	test.class.class_num	1	100.00	Using index
1	SIMPLE	roster	ref	fk1	fk1	5	test.class.class_num	1	100.00	Using index; FirstMatch(roster)
EXPLAIN EXTENDED UPDATE class RIGHT JOIN roster ON class.class_num=roster.class_num 
SET class.class_name='geography' 
WHERE roster.class_num IN (SELECT class_num FROM roster);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	roster	index	fk1	fk1	5	NULL	6	100.00	Using where; Using index
1	SIMPLE	roster	ref	fk1	fk1	5	test.roster.class_num	1	100.00	Using index; FirstMatch(roster)
1	SIMPLE	class	ALL	PRIMARY	NULL	NULL	NULL	4	75.00	Using where; Using join buffer (Block Nested Loop)
EXPLAIN EXTENDED UPDATE student LEFT JOIN roster ON student.stu_name=roster.stu_name 
SET student.stu_city='kolkata' 
WHERE student.stu_name IN (SELECT stu_name FROM roster);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	student	ALL	PRIMARY	NULL	NULL	NULL	4	100.00	NULL
1	SIMPLE	roster	ref	fk2	fk2	23	test.student.stu_name	1	100.00	Using index; FirstMatch(student)
1	SIMPLE	roster	ref	fk2	fk2	23	test.student.stu_name	1	100.00	Using index
EXPLAIN EXTENDED UPDATE class INNER JOIN roster ON class.class_num=roster.class_num 
SET class.class_name='geography' 
WHERE class.class_num IN (SELECT class_num FROM roster);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	class	ALL	PRIMARY	NULL	NULL	NULL	4	100.00	NULL
1	SIMPLE	roster	ref	fk1	fk1	5	test.class.class_num	1	100.00	Using index
1	SIMPLE	roster	ref	fk1	fk1	5	test.class.class_num	1	100.00	Using index; FirstMatch(roster)
EXPLAIN EXTENDED UPDATE ot1 LEFT JOIN ot2 ON ot1.a=ot2.a 
SET ot1.a = 111, ot2.a = 222 
WHERE ot1.a IN (SELECT a FROM it3 ORDER BY a);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	it3	ALL	NULL	NULL	NULL	NULL	3	100.00	Start temporary
1	SIMPLE	ot1	ALL	NULL	NULL	NULL	NULL	8	100.00	Using where; End temporary; Using join buffer (Block Nested Loop)
1	SIMPLE	ot2	ALL	NULL	NULL	NULL	NULL	4	100.00	Using where; Using join buffer (Block Nested Loop)
EXPLAIN EXTENDED UPDATE ot1 LEFT JOIN ot2 ON ot1.a=ot2.a 
SET ot1.a = 111 
WHERE COALESCE(ot2.a,0) IN (SELECT a FROM it3);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	it3	ALL	NULL	NULL	NULL	NULL	3	100.00	Start temporary
1	SIMPLE	ot1	ALL	NULL	NULL	NULL	NULL	8	100.00	Using join buffer (Block Nested Loop)
1	SIMPLE	ot2	ALL	NULL	NULL	NULL	NULL	4	100.00	Using where; End temporary; Using join buffer (Block Nested Loop)
EXPLAIN EXTENDED UPDATE ot1 LEFT JOIN ot2 ON ot1.a=ot2.a 
SET ot1.a = 111, ot2.a = 222 
WHERE (ot1.a,ot2.a) IN (SELECT a,a FROM it3 ORDER BY 2);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	it3	ALL	NULL	NULL	NULL	NULL	3	100.00	Start temporary
1	SIMPLE	ot2	ALL	NULL	NULL	NULL	NULL	4	100.00	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	ot1	ALL	NULL	NULL	NULL	NULL	8	100.00	Using where; End temporary; Using join buffer (Block Nested Loop)
EXPLAIN EXTENDED UPDATE ot1 JOIN ot2 ON ot1.a=ot2.a AND ot1.a IN (SELECT a FROM it3) 
SET ot1.a = 111, ot2.a = 222 
WHERE ot1.a IN (SELECT a FROM it3);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	it3	ALL	NULL	NULL	NULL	NULL	3	100.00	Start temporary
1	SIMPLE	ot1	ALL	NULL	NULL	NULL	NULL	8	100.00	Using where; End temporary; Using join buffer (Block Nested Loop)
1	SIMPLE	it3	ALL	NULL	NULL	NULL	NULL	3	100.00	Using where; FirstMatch(ot1); Using join buffer (Block Nested Loop)
1	SIMPLE	ot2	ALL	NULL	NULL	NULL	NULL	4	100.00	Using where; Using join buffer (Block Nested Loop)
EXPLAIN EXTENDED UPDATE ot1 JOIN ot2 ON ot1.a IN (SELECT a FROM it3) 
SET ot1.a = 111, ot2.a = 222 
WHERE ot1.a IN (SELECT a FROM it3);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	it3	ALL	NULL	NULL	NULL	NULL	3	100.00	Start temporary
1	SIMPLE	ot1	ALL	NULL	NULL	NULL	NULL	8	100.00	Using where; End temporary; Using join buffer (Block Nested Loop)
1	SIMPLE	it3	ALL	NULL	NULL	NULL	NULL	3	100.00	Using where; FirstMatch(ot1); Using join buffer (Block Nested Loop)
1	SIMPLE	ot2	ALL	NULL	NULL	NULL	NULL	4	100.00	Using join buffer (Block Nested Loop)
EXPLAIN EXTENDED UPDATE ot1 LEFT JOIN (ot2 JOIN ot3 ON ot2.a=ot3.a) ON ot1.a=ot2.a AND ot1.a IN (SELECT a FROM it1 ORDER BY a) 
SET ot1.a = 111 
WHERE ot1.a IN (SELECT a FROM it3 ORDER BY a);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	ot1	ALL	NULL	NULL	NULL	NULL	8	100.00	NULL
1	SIMPLE	it3	ALL	NULL	NULL	NULL	NULL	3	100.00	Using where; FirstMatch(ot1); Using join buffer (Block Nested Loop)
1	SIMPLE	it1	ALL	NULL	NULL	NULL	NULL	8	100.00	Using where; FirstMatch(it3)
1	SIMPLE	ot3	ALL	NULL	NULL	NULL	NULL	3	100.00	Using where
1	SIMPLE	ot2	ALL	NULL	NULL	NULL	NULL	4	100.00	Using where
UPDATE class JOIN roster ON class.class_num=roster.class_num
SET class.class_name='geography'
	      WHERE class.class_num IN (SELECT class_num FROM roster);
SELECT * FROM class;
class_num	class_name
1	geography
2	science
3	geography
4	geography
ROLLBACK;
UPDATE class RIGHT JOIN roster ON class.class_num=roster.class_num 
SET class.class_name='geography' 
WHERE roster.class_num IN (SELECT class_num FROM roster);
SELECT * FROM class;
class_num	class_name
1	geography
2	science
3	geography
4	geography
ROLLBACK;
UPDATE student LEFT JOIN roster ON student.stu_name=roster.stu_name 
SET student.stu_city='kolkata' 
WHERE student.stu_name IN (SELECT stu_name FROM roster);
SELECT * FROM student;
stu_name	stu_city	stu_id
amit	kolkata	1
ashu	kolkata	2
rajdeep	bbsr	4
sumit	kolkata	2
ROLLBACK;
UPDATE class INNER JOIN roster ON class.class_num=roster.class_num 
SET class.class_name='geography' 
WHERE class.class_num IN (SELECT class_num FROM roster);
SELECT * FROM class;
class_num	class_name
1	geography
2	science
3	geography
4	geography
ROLLBACK;
UPDATE ot1 LEFT JOIN ot2 ON ot1.a=ot2.a 
SET ot1.a = 111, ot2.a = 222 
WHERE ot1.a IN (SELECT a FROM it3 ORDER BY a);
SELECT * FROM ot1;
a
111
1
2
111
4
5
111
7
SELECT * FROM ot2;
a
222
2
4
222
ROLLBACK;
UPDATE ot1 LEFT JOIN ot2 ON ot1.a=ot2.a 
SET ot1.a = 111 
WHERE COALESCE(ot2.a,0) IN (SELECT a FROM it3);
SELECT * FROM ot1;
a
111
111
2
111
4
111
111
111
ROLLBACK;
UPDATE ot1 LEFT JOIN ot2 ON ot1.a=ot2.a 
SET ot1.a = 111, ot2.a = 222 
WHERE (ot1.a,ot2.a) IN (SELECT a,a FROM it3 ORDER BY 2);
SELECT * FROM ot1;
a
111
1
2
3
4
5
111
7
SELECT * FROM ot2;
a
222
2
4
222
ROLLBACK;
UPDATE ot1 JOIN ot2 ON ot1.a=ot2.a AND ot1.a IN (SELECT a FROM it3) 
SET ot1.a = 111, ot2.a = 222 
WHERE ot1.a IN (SELECT a FROM it3);
SELECT * FROM ot1;
a
111
1
2
3
4
5
111
7
SELECT * FROM ot2;
a
222
2
4
222
ROLLBACK;
UPDATE ot1 JOIN ot2 ON ot1.a IN (SELECT a FROM it3) 
SET ot1.a = 111, ot2.a = 222 
WHERE ot1.a IN (SELECT a FROM it3);
SELECT * FROM ot1;
a
111
1
2
111
4
5
111
7
SELECT * FROM ot2;
a
222
222
222
222
ROLLBACK;
UPDATE ot1 LEFT JOIN (ot2 JOIN ot3 ON ot2.a=ot3.a) ON ot1.a=ot2.a AND ot1.a IN (SELECT a FROM it1 ORDER BY a) 
SET ot1.a = 111 
WHERE ot1.a IN (SELECT a FROM it3 ORDER BY a);
SELECT * FROM ot1;
a
111
1
2
111
4
5
111
7
ROLLBACK;
# The following queries would select Materialize based on the optimizer switch settings
# Please note that some of the queries would still show Duplicate Weedout
SET optimizer_switch='semijoin=on,loosescan=off,firstmatch=off,index_condition_pushdown=off,mrr=off,materialization=on';
COMMIT;
EXPLAIN EXTENDED UPDATE class JOIN roster ON class.class_num=roster.class_num
SET class.class_name='geography'
	      WHERE class.class_num IN (SELECT class_num FROM roster);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	class	ALL	PRIMARY	NULL	NULL	NULL	4	100.00	Using where
1	SIMPLE	roster	ref	fk1	fk1	5	test.class.class_num	1	100.00	Using index
1	SIMPLE	<subquery2>	eq_ref	<auto_key>	<auto_key>	5	test.class.class_num	1	100.00	NULL
2	MATERIALIZED	roster	index	fk1	fk1	5	NULL	6	100.00	Using index
EXPLAIN EXTENDED UPDATE class RIGHT JOIN roster ON class.class_num=roster.class_num 
SET class.class_name='geography' 
WHERE roster.class_num IN (SELECT class_num FROM roster);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	roster	index	fk1	fk1	5	NULL	6	100.00	Using where; Using index
1	SIMPLE	<subquery2>	eq_ref	<auto_key>	<auto_key>	5	test.roster.class_num	1	100.00	NULL
1	SIMPLE	class	ALL	PRIMARY	NULL	NULL	NULL	4	75.00	Using where; Using join buffer (Block Nested Loop)
2	MATERIALIZED	roster	index	fk1	fk1	5	NULL	6	100.00	Using index
EXPLAIN EXTENDED UPDATE student LEFT JOIN roster ON student.stu_name=roster.stu_name 
SET student.stu_city='kolkata' 
WHERE student.stu_name IN (SELECT stu_name FROM roster);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	student	ALL	PRIMARY	NULL	NULL	NULL	4	100.00	Using where
1	SIMPLE	<subquery2>	eq_ref	<auto_key>	<auto_key>	23	test.student.stu_name	1	100.00	NULL
1	SIMPLE	roster	ref	fk2	fk2	23	test.student.stu_name	1	100.00	Using index
2	MATERIALIZED	roster	index	fk2	fk2	23	NULL	6	100.00	Using index
EXPLAIN EXTENDED UPDATE class INNER JOIN roster ON class.class_num=roster.class_num 
SET class.class_name='geography' 
WHERE class.class_num IN (SELECT class_num FROM roster);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	class	ALL	PRIMARY	NULL	NULL	NULL	4	100.00	Using where
1	SIMPLE	roster	ref	fk1	fk1	5	test.class.class_num	1	100.00	Using index
1	SIMPLE	<subquery2>	eq_ref	<auto_key>	<auto_key>	5	test.class.class_num	1	100.00	NULL
2	MATERIALIZED	roster	index	fk1	fk1	5	NULL	6	100.00	Using index
EXPLAIN EXTENDED UPDATE ot1 LEFT JOIN ot2 ON ot1.a=ot2.a 
SET ot1.a = 111, ot2.a = 222 
WHERE ot1.a IN (SELECT a FROM it3 ORDER BY a);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	<subquery2>	ALL	NULL	NULL	NULL	NULL	NULL	0.00	NULL
1	SIMPLE	ot1	ALL	NULL	NULL	NULL	NULL	8	100.00	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	ot2	ALL	NULL	NULL	NULL	NULL	4	100.00	Using where; Using join buffer (Block Nested Loop)
2	MATERIALIZED	it3	ALL	NULL	NULL	NULL	NULL	3	100.00	NULL
EXPLAIN EXTENDED UPDATE ot1 LEFT JOIN ot2 ON ot1.a=ot2.a 
SET ot1.a = 111 
WHERE COALESCE(ot2.a,0) IN (SELECT a FROM it3);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	<subquery2>	ALL	NULL	NULL	NULL	NULL	NULL	0.00	NULL
1	SIMPLE	ot1	ALL	NULL	NULL	NULL	NULL	8	100.00	Using join buffer (Block Nested Loop)
1	SIMPLE	ot2	ALL	NULL	NULL	NULL	NULL	4	100.00	Using where; Using join buffer (Block Nested Loop)
2	MATERIALIZED	it3	ALL	NULL	NULL	NULL	NULL	3	100.00	NULL
EXPLAIN EXTENDED UPDATE ot1 LEFT JOIN ot2 ON ot1.a=ot2.a 
SET ot1.a = 111, ot2.a = 222 
WHERE (ot1.a,ot2.a) IN (SELECT a,a FROM it3 ORDER BY 2);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	<subquery2>	ALL	NULL	NULL	NULL	NULL	NULL	0.00	Using where
1	SIMPLE	ot2	ALL	NULL	NULL	NULL	NULL	4	100.00	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	ot1	ALL	NULL	NULL	NULL	NULL	8	100.00	Using where; Using join buffer (Block Nested Loop)
2	MATERIALIZED	it3	ALL	NULL	NULL	NULL	NULL	3	100.00	NULL
EXPLAIN EXTENDED UPDATE ot1 JOIN ot2 ON ot1.a=ot2.a AND ot1.a IN (SELECT a FROM it3) 
SET ot1.a = 111, ot2.a = 222 
WHERE ot1.a IN (SELECT a FROM it3);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	<subquery3>	ALL	NULL	NULL	NULL	NULL	NULL	0.00	Using where
1	SIMPLE	ot1	ALL	NULL	NULL	NULL	NULL	8	100.00	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	<subquery2>	eq_ref	<auto_key>	<auto_key>	5	<subquery3>.a	1	100.00	NULL
1	SIMPLE	ot2	ALL	NULL	NULL	NULL	NULL	4	100.00	Using where; Using join buffer (Block Nested Loop)
3	MATERIALIZED	it3	ALL	NULL	NULL	NULL	NULL	3	100.00	NULL
2	MATERIALIZED	it3	ALL	NULL	NULL	NULL	NULL	3	100.00	NULL
EXPLAIN EXTENDED UPDATE ot1 JOIN ot2 ON ot1.a IN (SELECT a FROM it3) 
SET ot1.a = 111, ot2.a = 222 
WHERE ot1.a IN (SELECT a FROM it3);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	<subquery3>	ALL	NULL	NULL	NULL	NULL	NULL	0.00	Using where
1	SIMPLE	ot1	ALL	NULL	NULL	NULL	NULL	8	100.00	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	<subquery2>	eq_ref	<auto_key>	<auto_key>	5	<subquery3>.a	1	100.00	NULL
1	SIMPLE	ot2	ALL	NULL	NULL	NULL	NULL	4	100.00	Using join buffer (Block Nested Loop)
3	MATERIALIZED	it3	ALL	NULL	NULL	NULL	NULL	3	100.00	NULL
2	MATERIALIZED	it3	ALL	NULL	NULL	NULL	NULL	3	100.00	NULL
EXPLAIN EXTENDED UPDATE ot1 LEFT JOIN (ot2 JOIN ot3 ON ot2.a=ot3.a) ON ot1.a=ot2.a AND ot1.a IN (SELECT a FROM it1 ORDER BY a) 
SET ot1.a = 111 
WHERE ot1.a IN (SELECT a FROM it3 ORDER BY a);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	it3	ALL	NULL	NULL	NULL	NULL	3	100.00	Start temporary
1	SIMPLE	ot1	ALL	NULL	NULL	NULL	NULL	8	100.00	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	it1	ALL	NULL	NULL	NULL	NULL	8	100.00	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	ot3	ALL	NULL	NULL	NULL	NULL	3	100.00	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	ot2	ALL	NULL	NULL	NULL	NULL	4	100.00	Using where; End temporary; Using join buffer (Block Nested Loop)
UPDATE class JOIN roster ON class.class_num=roster.class_num
SET class.class_name='geography'
	      WHERE class.class_num IN (SELECT class_num FROM roster);
SELECT * FROM class;
class_num	class_name
1	geography
2	science
3	geography
4	geography
ROLLBACK;
UPDATE class RIGHT JOIN roster ON class.class_num=roster.class_num 
SET class.class_name='geography' 
WHERE roster.class_num IN (SELECT class_num FROM roster);
SELECT * FROM class;
class_num	class_name
1	geography
2	science
3	geography
4	geography
ROLLBACK;
UPDATE student LEFT JOIN roster ON student.stu_name=roster.stu_name 
SET student.stu_city='kolkata' 
WHERE student.stu_name IN (SELECT stu_name FROM roster);
SELECT * FROM student;
stu_name	stu_city	stu_id
amit	kolkata	1
ashu	kolkata	2
rajdeep	bbsr	4
sumit	kolkata	2
ROLLBACK;
UPDATE class INNER JOIN roster ON class.class_num=roster.class_num 
SET class.class_name='geography' 
WHERE class.class_num IN (SELECT class_num FROM roster);
SELECT * FROM class;
class_num	class_name
1	geography
2	science
3	geography
4	geography
ROLLBACK;
UPDATE ot1 LEFT JOIN ot2 ON ot1.a=ot2.a 
SET ot1.a = 111, ot2.a = 222 
WHERE ot1.a IN (SELECT a FROM it3 ORDER BY a);
SELECT * FROM ot1;
a
111
1
2
111
4
5
111
7
SELECT * FROM ot2;
a
222
2
4
222
ROLLBACK;
UPDATE ot1 LEFT JOIN ot2 ON ot1.a=ot2.a 
SET ot1.a = 111 
WHERE COALESCE(ot2.a,0) IN (SELECT a FROM it3);
SELECT * FROM ot1;
a
111
111
2
111
4
111
111
111
ROLLBACK;
UPDATE ot1 LEFT JOIN ot2 ON ot1.a=ot2.a 
SET ot1.a = 111, ot2.a = 222 
WHERE (ot1.a,ot2.a) IN (SELECT a,a FROM it3 ORDER BY 2);
SELECT * FROM ot1;
a
111
1
2
3
4
5
111
7
SELECT * FROM ot2;
a
222
2
4
222
ROLLBACK;
UPDATE ot1 JOIN ot2 ON ot1.a=ot2.a AND ot1.a IN (SELECT a FROM it3) 
SET ot1.a = 111, ot2.a = 222 
WHERE ot1.a IN (SELECT a FROM it3);
SELECT * FROM ot1;
a
111
1
2
3
4
5
111
7
SELECT * FROM ot2;
a
222
2
4
222
ROLLBACK;
UPDATE ot1 JOIN ot2 ON ot1.a IN (SELECT a FROM it3) 
SET ot1.a = 111, ot2.a = 222 
WHERE ot1.a IN (SELECT a FROM it3);
SELECT * FROM ot1;
a
111
1
2
111
4
5
111
7
SELECT * FROM ot2;
a
222
222
222
222
ROLLBACK;
UPDATE ot1 LEFT JOIN (ot2 JOIN ot3 ON ot2.a=ot3.a) ON ot1.a=ot2.a AND ot1.a IN (SELECT a FROM it1 ORDER BY a) 
SET ot1.a = 111 
WHERE ot1.a IN (SELECT a FROM it3 ORDER BY a);
SELECT * FROM ot1;
a
111
1
2
111
4
5
111
7
ROLLBACK;
# The following queries would select Duplicate Weedout strategy based on the optimizer switch settings
SET optimizer_switch='loosescan=off,firstmatch=off,index_condition_pushdown=off,mrr=off,semijoin=on,materialization=off';
COMMIT;
EXPLAIN EXTENDED UPDATE class JOIN roster ON class.class_num=roster.class_num
SET class.class_name='geography'
	      WHERE class.class_num IN (SELECT class_num FROM roster);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	class	ALL	PRIMARY	NULL	NULL	NULL	4	100.00	NULL
1	SIMPLE	roster	ref	fk1	fk1	5	test.class.class_num	1	100.00	Using index
1	SIMPLE	roster	ref	fk1	fk1	5	test.class.class_num	1	100.00	Using index; Start temporary; End temporary
EXPLAIN EXTENDED UPDATE class RIGHT JOIN roster ON class.class_num=roster.class_num 
SET class.class_name='geography' 
WHERE roster.class_num IN (SELECT class_num FROM roster);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	roster	index	fk1	fk1	5	NULL	6	100.00	Using where; Using index; Start temporary
1	SIMPLE	roster	ref	fk1	fk1	5	test.roster.class_num	1	100.00	Using index; End temporary
1	SIMPLE	class	ALL	PRIMARY	NULL	NULL	NULL	4	75.00	Using where; Using join buffer (Block Nested Loop)
EXPLAIN EXTENDED UPDATE student LEFT JOIN roster ON student.stu_name=roster.stu_name 
SET student.stu_city='kolkata' 
WHERE student.stu_name IN (SELECT stu_name FROM roster);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	student	ALL	PRIMARY	NULL	NULL	NULL	4	100.00	NULL
1	SIMPLE	roster	ref	fk2	fk2	23	test.student.stu_name	1	100.00	Using index; Start temporary
1	SIMPLE	roster	ref	fk2	fk2	23	test.student.stu_name	1	100.00	Using index; End temporary
EXPLAIN EXTENDED UPDATE class INNER JOIN roster ON class.class_num=roster.class_num 
SET class.class_name='geography' 
WHERE class.class_num IN (SELECT class_num FROM roster);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	class	ALL	PRIMARY	NULL	NULL	NULL	4	100.00	NULL
1	SIMPLE	roster	ref	fk1	fk1	5	test.class.class_num	1	100.00	Using index
1	SIMPLE	roster	ref	fk1	fk1	5	test.class.class_num	1	100.00	Using index; Start temporary; End temporary
EXPLAIN EXTENDED UPDATE ot1 LEFT JOIN ot2 ON ot1.a=ot2.a 
SET ot1.a = 111, ot2.a = 222 
WHERE ot1.a IN (SELECT a FROM it3 ORDER BY a);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	it3	ALL	NULL	NULL	NULL	NULL	3	100.00	Start temporary
1	SIMPLE	ot1	ALL	NULL	NULL	NULL	NULL	8	100.00	Using where; End temporary; Using join buffer (Block Nested Loop)
1	SIMPLE	ot2	ALL	NULL	NULL	NULL	NULL	4	100.00	Using where; Using join buffer (Block Nested Loop)
EXPLAIN EXTENDED UPDATE ot1 LEFT JOIN ot2 ON ot1.a=ot2.a 
SET ot1.a = 111 
WHERE COALESCE(ot2.a,0) IN (SELECT a FROM it3);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	it3	ALL	NULL	NULL	NULL	NULL	3	100.00	Start temporary
1	SIMPLE	ot1	ALL	NULL	NULL	NULL	NULL	8	100.00	Using join buffer (Block Nested Loop)
1	SIMPLE	ot2	ALL	NULL	NULL	NULL	NULL	4	100.00	Using where; End temporary; Using join buffer (Block Nested Loop)
EXPLAIN EXTENDED UPDATE ot1 LEFT JOIN ot2 ON ot1.a=ot2.a 
SET ot1.a = 111, ot2.a = 222 
WHERE (ot1.a,ot2.a) IN (SELECT a,a FROM it3 ORDER BY 2);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	it3	ALL	NULL	NULL	NULL	NULL	3	100.00	Start temporary
1	SIMPLE	ot2	ALL	NULL	NULL	NULL	NULL	4	100.00	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	ot1	ALL	NULL	NULL	NULL	NULL	8	100.00	Using where; End temporary; Using join buffer (Block Nested Loop)
EXPLAIN EXTENDED UPDATE ot1 JOIN ot2 ON ot1.a=ot2.a AND ot1.a IN (SELECT a FROM it3) 
SET ot1.a = 111, ot2.a = 222 
WHERE ot1.a IN (SELECT a FROM it3);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	it3	ALL	NULL	NULL	NULL	NULL	3	100.00	Start temporary
1	SIMPLE	it3	ALL	NULL	NULL	NULL	NULL	3	100.00	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	ot1	ALL	NULL	NULL	NULL	NULL	8	100.00	Using where; End temporary; Using join buffer (Block Nested Loop)
1	SIMPLE	ot2	ALL	NULL	NULL	NULL	NULL	4	100.00	Using where; Using join buffer (Block Nested Loop)
EXPLAIN EXTENDED UPDATE ot1 JOIN ot2 ON ot1.a IN (SELECT a FROM it3) 
SET ot1.a = 111, ot2.a = 222 
WHERE ot1.a IN (SELECT a FROM it3);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	it3	ALL	NULL	NULL	NULL	NULL	3	100.00	Start temporary
1	SIMPLE	it3	ALL	NULL	NULL	NULL	NULL	3	100.00	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	ot1	ALL	NULL	NULL	NULL	NULL	8	100.00	Using where; End temporary; Using join buffer (Block Nested Loop)
1	SIMPLE	ot2	ALL	NULL	NULL	NULL	NULL	4	100.00	Using join buffer (Block Nested Loop)
EXPLAIN EXTENDED UPDATE ot1 LEFT JOIN (ot2 JOIN ot3 ON ot2.a=ot3.a) ON ot1.a=ot2.a AND ot1.a IN (SELECT a FROM it1 ORDER BY a) 
SET ot1.a = 111 
WHERE ot1.a IN (SELECT a FROM it3 ORDER BY a);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	it3	ALL	NULL	NULL	NULL	NULL	3	100.00	Start temporary
1	SIMPLE	ot1	ALL	NULL	NULL	NULL	NULL	8	100.00	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	it1	ALL	NULL	NULL	NULL	NULL	8	100.00	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	ot3	ALL	NULL	NULL	NULL	NULL	3	100.00	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	ot2	ALL	NULL	NULL	NULL	NULL	4	100.00	Using where; End temporary; Using join buffer (Block Nested Loop)
UPDATE class JOIN roster ON class.class_num=roster.class_num
SET class.class_name='geography'
	      WHERE class.class_num IN (SELECT class_num FROM roster);
SELECT * FROM class;
class_num	class_name
1	geography
2	science
3	geography
4	geography
ROLLBACK;
UPDATE class RIGHT JOIN roster ON class.class_num=roster.class_num 
SET class.class_name='geography' 
WHERE roster.class_num IN (SELECT class_num FROM roster);
SELECT * FROM class;
class_num	class_name
1	geography
2	science
3	geography
4	geography
ROLLBACK;
UPDATE student LEFT JOIN roster ON student.stu_name=roster.stu_name 
SET student.stu_city='kolkata' 
WHERE student.stu_name IN (SELECT stu_name FROM roster);
SELECT * FROM student;
stu_name	stu_city	stu_id
amit	kolkata	1
ashu	kolkata	2
rajdeep	bbsr	4
sumit	kolkata	2
ROLLBACK;
UPDATE class INNER JOIN roster ON class.class_num=roster.class_num 
SET class.class_name='geography' 
WHERE class.class_num IN (SELECT class_num FROM roster);
SELECT * FROM class;
class_num	class_name
1	geography
2	science
3	geography
4	geography
ROLLBACK;
UPDATE ot1 LEFT JOIN ot2 ON ot1.a=ot2.a 
SET ot1.a = 111, ot2.a = 222 
WHERE ot1.a IN (SELECT a FROM it3 ORDER BY a);
SELECT * FROM ot1;
a
111
1
2
111
4
5
111
7
SELECT * FROM ot2;
a
222
2
4
222
ROLLBACK;
UPDATE ot1 LEFT JOIN ot2 ON ot1.a=ot2.a 
SET ot1.a = 111 
WHERE COALESCE(ot2.a,0) IN (SELECT a FROM it3);
SELECT * FROM ot1;
a
111
111
2
111
4
111
111
111
ROLLBACK;
UPDATE ot1 LEFT JOIN ot2 ON ot1.a=ot2.a 
SET ot1.a = 111, ot2.a = 222 
WHERE (ot1.a,ot2.a) IN (SELECT a,a FROM it3 ORDER BY 2);
SELECT * FROM ot1;
a
111
1
2
3
4
5
111
7
SELECT * FROM ot2;
a
222
2
4
222
ROLLBACK;
UPDATE ot1 JOIN ot2 ON ot1.a=ot2.a AND ot1.a IN (SELECT a FROM it3) 
SET ot1.a = 111, ot2.a = 222 
WHERE ot1.a IN (SELECT a FROM it3);
SELECT * FROM ot1;
a
111
1
2
3
4
5
111
7
SELECT * FROM ot2;
a
222
2
4
222
ROLLBACK;
UPDATE ot1 JOIN ot2 ON ot1.a IN (SELECT a FROM it3) 
SET ot1.a = 111, ot2.a = 222 
WHERE ot1.a IN (SELECT a FROM it3);
SELECT * FROM ot1;
a
111
1
2
111
4
5
111
7
SELECT * FROM ot2;
a
222
222
222
222
ROLLBACK;
UPDATE ot1 LEFT JOIN (ot2 JOIN ot3 ON ot2.a=ot3.a) ON ot1.a=ot2.a AND ot1.a IN (SELECT a FROM it1 ORDER BY a) 
SET ot1.a = 111 
WHERE ot1.a IN (SELECT a FROM it3 ORDER BY a);
SELECT * FROM ot1;
a
111
1
2
111
4
5
111
7
ROLLBACK;
# The following queries would select Loosescan strategy based on the optimizer switch settings
# Please note that some of the queries would still show Duplicate Weedout
SET optimizer_switch='loosescan=on,firstmatch=off,index_condition_pushdown=off,mrr=off,semijoin=on,materialization=off';
COMMIT;
EXPLAIN EXTENDED UPDATE class JOIN roster ON class.class_num=roster.class_num
SET class.class_name='geography'
	      WHERE class.class_num IN (SELECT class_num FROM roster);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	roster	index	fk1	fk1	5	NULL	6	100.00	Using index; LooseScan
1	SIMPLE	class	ALL	PRIMARY	NULL	NULL	NULL	4	75.00	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	roster	ref	fk1	fk1	5	test.roster.class_num	1	100.00	Using index
EXPLAIN EXTENDED UPDATE class RIGHT JOIN roster ON class.class_num=roster.class_num 
SET class.class_name='geography' 
WHERE roster.class_num IN (SELECT class_num FROM roster);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	roster	index	fk1	fk1	5	NULL	6	100.00	Using where; Using index; LooseScan
1	SIMPLE	roster	ref	fk1	fk1	5	test.roster.class_num	1	100.00	Using index
1	SIMPLE	class	ALL	PRIMARY	NULL	NULL	NULL	4	75.00	Using where; Using join buffer (Block Nested Loop)
EXPLAIN EXTENDED UPDATE student LEFT JOIN roster ON student.stu_name=roster.stu_name 
SET student.stu_city='kolkata' 
WHERE student.stu_name IN (SELECT stu_name FROM roster);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	roster	index	fk2	fk2	23	NULL	6	100.00	Using index; LooseScan
1	SIMPLE	student	ALL	PRIMARY	NULL	NULL	NULL	4	75.00	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	roster	ref	fk2	fk2	23	test.roster.stu_name	1	100.00	Using index
EXPLAIN EXTENDED UPDATE class INNER JOIN roster ON class.class_num=roster.class_num 
SET class.class_name='geography' 
WHERE class.class_num IN (SELECT class_num FROM roster);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	roster	index	fk1	fk1	5	NULL	6	100.00	Using index; LooseScan
1	SIMPLE	class	ALL	PRIMARY	NULL	NULL	NULL	4	75.00	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	roster	ref	fk1	fk1	5	test.roster.class_num	1	100.00	Using index
EXPLAIN EXTENDED UPDATE ot1 LEFT JOIN ot2 ON ot1.a=ot2.a 
SET ot1.a = 111, ot2.a = 222 
WHERE ot1.a IN (SELECT a FROM it3 ORDER BY a);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	it3	ALL	NULL	NULL	NULL	NULL	3	100.00	Start temporary
1	SIMPLE	ot1	ALL	NULL	NULL	NULL	NULL	8	100.00	Using where; End temporary; Using join buffer (Block Nested Loop)
1	SIMPLE	ot2	ALL	NULL	NULL	NULL	NULL	4	100.00	Using where; Using join buffer (Block Nested Loop)
EXPLAIN EXTENDED UPDATE ot1 LEFT JOIN ot2 ON ot1.a=ot2.a 
SET ot1.a = 111 
WHERE COALESCE(ot2.a,0) IN (SELECT a FROM it3);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	it3	ALL	NULL	NULL	NULL	NULL	3	100.00	Start temporary
1	SIMPLE	ot1	ALL	NULL	NULL	NULL	NULL	8	100.00	Using join buffer (Block Nested Loop)
1	SIMPLE	ot2	ALL	NULL	NULL	NULL	NULL	4	100.00	Using where; End temporary; Using join buffer (Block Nested Loop)
EXPLAIN EXTENDED UPDATE ot1 LEFT JOIN ot2 ON ot1.a=ot2.a 
SET ot1.a = 111, ot2.a = 222 
WHERE (ot1.a,ot2.a) IN (SELECT a,a FROM it3 ORDER BY 2);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	it3	ALL	NULL	NULL	NULL	NULL	3	100.00	Start temporary
1	SIMPLE	ot2	ALL	NULL	NULL	NULL	NULL	4	100.00	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	ot1	ALL	NULL	NULL	NULL	NULL	8	100.00	Using where; End temporary; Using join buffer (Block Nested Loop)
EXPLAIN EXTENDED UPDATE ot1 JOIN ot2 ON ot1.a=ot2.a AND ot1.a IN (SELECT a FROM it3) 
SET ot1.a = 111, ot2.a = 222 
WHERE ot1.a IN (SELECT a FROM it3);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	it3	ALL	NULL	NULL	NULL	NULL	3	100.00	Start temporary
1	SIMPLE	it3	ALL	NULL	NULL	NULL	NULL	3	100.00	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	ot1	ALL	NULL	NULL	NULL	NULL	8	100.00	Using where; End temporary; Using join buffer (Block Nested Loop)
1	SIMPLE	ot2	ALL	NULL	NULL	NULL	NULL	4	100.00	Using where; Using join buffer (Block Nested Loop)
EXPLAIN EXTENDED UPDATE ot1 JOIN ot2 ON ot1.a IN (SELECT a FROM it3) 
SET ot1.a = 111, ot2.a = 222 
WHERE ot1.a IN (SELECT a FROM it3);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	it3	ALL	NULL	NULL	NULL	NULL	3	100.00	Start temporary
1	SIMPLE	it3	ALL	NULL	NULL	NULL	NULL	3	100.00	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	ot1	ALL	NULL	NULL	NULL	NULL	8	100.00	Using where; End temporary; Using join buffer (Block Nested Loop)
1	SIMPLE	ot2	ALL	NULL	NULL	NULL	NULL	4	100.00	Using join buffer (Block Nested Loop)
EXPLAIN EXTENDED UPDATE ot1 LEFT JOIN (ot2 JOIN ot3 ON ot2.a=ot3.a) ON ot1.a=ot2.a AND ot1.a IN (SELECT a FROM it1 ORDER BY a) 
SET ot1.a = 111 
WHERE ot1.a IN (SELECT a FROM it3 ORDER BY a);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	it3	ALL	NULL	NULL	NULL	NULL	3	100.00	Start temporary
1	SIMPLE	ot1	ALL	NULL	NULL	NULL	NULL	8	100.00	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	it1	ALL	NULL	NULL	NULL	NULL	8	100.00	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	ot3	ALL	NULL	NULL	NULL	NULL	3	100.00	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	ot2	ALL	NULL	NULL	NULL	NULL	4	100.00	Using where; End temporary; Using join buffer (Block Nested Loop)
UPDATE class JOIN roster ON class.class_num=roster.class_num
SET class.class_name='geography'
	      WHERE class.class_num IN (SELECT class_num FROM roster);
SELECT * FROM class;
class_num	class_name
1	geography
2	science
3	geography
4	geography
ROLLBACK;
UPDATE class RIGHT JOIN roster ON class.class_num=roster.class_num 
SET class.class_name='geography' 
WHERE roster.class_num IN (SELECT class_num FROM roster);
SELECT * FROM class;
class_num	class_name
1	geography
2	science
3	geography
4	geography
ROLLBACK;
UPDATE student LEFT JOIN roster ON student.stu_name=roster.stu_name 
SET student.stu_city='kolkata' 
WHERE student.stu_name IN (SELECT stu_name FROM roster);
SELECT * FROM student;
stu_name	stu_city	stu_id
amit	kolkata	1
ashu	kolkata	2
rajdeep	bbsr	4
sumit	kolkata	2
ROLLBACK;
UPDATE class INNER JOIN roster ON class.class_num=roster.class_num 
SET class.class_name='geography' 
WHERE class.class_num IN (SELECT class_num FROM roster);
SELECT * FROM class;
class_num	class_name
1	geography
2	science
3	geography
4	geography
ROLLBACK;
UPDATE ot1 LEFT JOIN ot2 ON ot1.a=ot2.a 
SET ot1.a = 111, ot2.a = 222 
WHERE ot1.a IN (SELECT a FROM it3 ORDER BY a);
SELECT * FROM ot1;
a
111
1
2
111
4
5
111
7
SELECT * FROM ot2;
a
222
2
4
222
ROLLBACK;
UPDATE ot1 LEFT JOIN ot2 ON ot1.a=ot2.a 
SET ot1.a = 111 
WHERE COALESCE(ot2.a,0) IN (SELECT a FROM it3);
SELECT * FROM ot1;
a
111
111
2
111
4
111
111
111
ROLLBACK;
UPDATE ot1 LEFT JOIN ot2 ON ot1.a=ot2.a 
SET ot1.a = 111, ot2.a = 222 
WHERE (ot1.a,ot2.a) IN (SELECT a,a FROM it3 ORDER BY 2);
SELECT * FROM ot1;
a
111
1
2
3
4
5
111
7
SELECT * FROM ot2;
a
222
2
4
222
ROLLBACK;
UPDATE ot1 JOIN ot2 ON ot1.a=ot2.a AND ot1.a IN (SELECT a FROM it3) 
SET ot1.a = 111, ot2.a = 222 
WHERE ot1.a IN (SELECT a FROM it3);
SELECT * FROM ot1;
a
111
1
2
3
4
5
111
7
SELECT * FROM ot2;
a
222
2
4
222
ROLLBACK;
UPDATE ot1 JOIN ot2 ON ot1.a IN (SELECT a FROM it3) 
SET ot1.a = 111, ot2.a = 222 
WHERE ot1.a IN (SELECT a FROM it3);
SELECT * FROM ot1;
a
111
1
2
111
4
5
111
7
SELECT * FROM ot2;
a
222
222
222
222
ROLLBACK;
UPDATE ot1 LEFT JOIN (ot2 JOIN ot3 ON ot2.a=ot3.a) ON ot1.a=ot2.a AND ot1.a IN (SELECT a FROM it1 ORDER BY a) 
SET ot1.a = 111 
WHERE ot1.a IN (SELECT a FROM it3 ORDER BY a);
SELECT * FROM ot1;
a
111
1
2
111
4
5
111
7
ROLLBACK;
# The following queries would give various strategies based on the default optimizer switch settings
SET optimizer_switch=default;
COMMIT;
EXPLAIN EXTENDED UPDATE class, roster
SET class.class_name='geography'
	       WHERE class.class_num IN (SELECT class_num FROM roster ORDER BY ros_num);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	class	ALL	PRIMARY	NULL	NULL	NULL	4	100.00	NULL
1	SIMPLE	roster	ref	fk1	fk1	5	test.class.class_num	1	100.00	Using index; FirstMatch(class)
1	SIMPLE	roster	index	NULL	fk1	5	NULL	6	100.00	Using index; Using join buffer (Block Nested Loop)
EXPLAIN EXTENDED UPDATE class INNER JOIN roster ON class.class_num = roster.class_num 
AND class.class_name = 'history' OR class.class_name = 'math'
	       SET class.class_name='geography'
	       WHERE class.class_num IN (SELECT class_num FROM roster ORDER BY ros_num);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	roster	index	fk1	fk1	5	NULL	6	100.00	Using index; LooseScan
1	SIMPLE	class	ALL	PRIMARY	NULL	NULL	NULL	4	75.00	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	roster	index	fk1	fk1	5	NULL	6	100.00	Using where; Using index; Using join buffer (Block Nested Loop)
UPDATE class, roster
SET class.class_name='geography'
	       WHERE class.class_num IN (SELECT class_num FROM roster ORDER BY ros_num);
SELECT * FROM class;
class_num	class_name
1	geography
2	science
3	geography
4	geography
ROLLBACK;
UPDATE class INNER JOIN roster ON class.class_num = roster.class_num 
AND class.class_name = 'history' OR class.class_name = 'math'
	       SET class.class_name='geography'
	       WHERE class.class_num IN (SELECT class_num FROM roster ORDER BY ros_num);
SELECT * FROM class;
class_num	class_name
1	geography
2	science
3	geography
4	geog
ROLLBACK;
# Using IN subquery predicate in the ON clause of the JOIN
EXPLAIN EXTENDED UPDATE class JOIN roster ON class.class_num IN (SELECT class_num from roster ORDER BY ros_num) 
SET class.class_name='geography';
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	class	ALL	PRIMARY	NULL	NULL	NULL	4	100.00	NULL
1	SIMPLE	roster	ref	fk1	fk1	5	test.class.class_num	1	100.00	Using index; FirstMatch(class)
1	SIMPLE	roster	index	NULL	fk1	5	NULL	6	100.00	Using index; Using join buffer (Block Nested Loop)
UPDATE class JOIN roster ON class.class_num IN (SELECT class_num from roster ORDER BY ros_num) 
SET class.class_name='geography';
SELECT * FROM class;
class_num	class_name
1	geography
2	science
3	geography
4	geography
ROLLBACK;
# The following set of tables are created to verify JOINS between 3 tables
CREATE TABLE tx(c1 INT NOT NULL PRIMARY KEY, c2 INT) ENGINE=INNODB;
CREATE TABLE ty(c1 INT, c2 INT, c3 VARCHAR(20) NOT NULL PRIMARY KEY, FOREIGN KEY fk1(c1) REFERENCES tx(c1)) ENGINE=INNODB;
CREATE TABLE tz(c1 INT, c2 INT, c3 VARCHAR(20), FOREIGN KEY fk2(c3) REFERENCES ty(c3)) ENGINE=INNODB;
INSERT INTO tx VALUES(1,1),(2,2),(3,3),(4,4),(5,5);
INSERT INTO ty VALUES(1,1,'1 match tx'),(2,2,'2 match tx'),(4,4,'4 match tx');
INSERT INTO tz VALUES(2,2,'2 match tx'),(4,4,'4 match tx');
INSERT INTO tz VALUES(20,20,'2 match tx'),(40,40,'4 match tx');
INSERT INTO tz VALUES(200,200,'2 match tx'),(400,400,'4 match tx');
COMMIT;
# Verifying various variations of the JOIN syntax using 3 tables
EXPLAIN EXTENDED UPDATE tx JOIN ty ON tx.c1=ty.c1 JOIN tz ON ty.c3=tz.c3 
SET tx.c2=100 
WHERE tx.c1 IN(SELECT c2 from ty WHERE ty.c3 IN(SELECT c3 from tz WHERE c2>2) ORDER BY c1);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	<subquery2>	ALL	NULL	NULL	NULL	NULL	NULL	0.00	Using where
1	SIMPLE	tx	eq_ref	PRIMARY	PRIMARY	4	<subquery2>.c2	1	100.00	NULL
1	SIMPLE	ty	ref	PRIMARY,fk1	fk1	5	<subquery2>.c2	1	100.00	Using index
1	SIMPLE	tz	ref	fk2	fk2	23	test.ty.c3	3	100.00	Using index
2	MATERIALIZED	ty	ALL	PRIMARY	NULL	NULL	NULL	3	100.00	NULL
2	MATERIALIZED	tz	ALL	fk2	NULL	NULL	NULL	6	83.33	Using where; Using join buffer (Block Nested Loop)
EXPLAIN EXTENDED UPDATE tx JOIN ty ON tx.c1=ty.c1 LEFT JOIN tz ON ty.c3=tz.c3 
SET tx.c2=100 
WHERE tx.c1 IN(SELECT c2 from ty WHERE ty.c3 IN(SELECT c3 from tz WHERE c2>2));
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	<subquery2>	ALL	NULL	NULL	NULL	NULL	NULL	0.00	Using where
1	SIMPLE	tx	eq_ref	PRIMARY	PRIMARY	4	<subquery2>.c2	1	100.00	NULL
1	SIMPLE	ty	ref	fk1	fk1	5	<subquery2>.c2	1	100.00	Using index
1	SIMPLE	tz	ref	fk2	fk2	23	test.ty.c3	3	100.00	Using index
2	MATERIALIZED	ty	ALL	PRIMARY	NULL	NULL	NULL	3	100.00	NULL
2	MATERIALIZED	tz	ALL	fk2	NULL	NULL	NULL	6	83.33	Using where; Using join buffer (Block Nested Loop)
EXPLAIN EXTENDED UPDATE tx JOIN ty ON tx.c1=ty.c1 LEFT JOIN tz ON ty.c3=tz.c3 
SET tx.c2=100 
WHERE tx.c1 IN(SELECT c1 from ty WHERE ty.c3 IN(SELECT c3 from tz WHERE c2>2) ORDER BY c2);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	ty	index	PRIMARY,fk1	fk1	5	NULL	3	100.00	Using where; Using index; Start temporary
1	SIMPLE	ty	ref	fk1	fk1	5	test.ty.c1	1	100.00	Using index
1	SIMPLE	tx	eq_ref	PRIMARY	PRIMARY	4	test.ty.c1	1	100.00	NULL
1	SIMPLE	tz	ALL	fk2	NULL	NULL	NULL	6	83.33	Using where; End temporary; Using join buffer (Block Nested Loop)
1	SIMPLE	tz	ref	fk2	fk2	23	test.ty.c3	3	100.00	Using index
EXPLAIN EXTENDED UPDATE tx JOIN ty ON tx.c1=ty.c1 LEFT JOIN tz ON ty.c3=tz.c3 
SET tx.c2=100 
WHERE tx.c1 IN(SELECT c2 from ty WHERE ty.c3 IN(SELECT c3 from tz));
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	<subquery2>	ALL	NULL	NULL	NULL	NULL	NULL	0.00	Using where
1	SIMPLE	tx	eq_ref	PRIMARY	PRIMARY	4	<subquery2>.c2	1	100.00	NULL
1	SIMPLE	ty	ref	fk1	fk1	5	<subquery2>.c2	1	100.00	Using index
1	SIMPLE	tz	ref	fk2	fk2	23	test.ty.c3	3	100.00	Using index
2	MATERIALIZED	ty	ALL	PRIMARY	NULL	NULL	NULL	3	100.00	NULL
2	MATERIALIZED	tz	ref	fk2	fk2	23	test.ty.c3	3	100.00	Using index
EXPLAIN EXTENDED UPDATE tx INNER JOIN ty ON tx.c1=ty.c1 LEFT JOIN tz ON ty.c3=tz.c3 
SET tx.c2=100 
WHERE tx.c1 IN(SELECT c2 from ty WHERE ty.c3 IN(SELECT c3 from tz ORDER BY c2));
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	<subquery2>	ALL	NULL	NULL	NULL	NULL	NULL	0.00	Using where
1	SIMPLE	tx	eq_ref	PRIMARY	PRIMARY	4	<subquery2>.c2	1	100.00	NULL
1	SIMPLE	ty	ref	fk1	fk1	5	<subquery2>.c2	1	100.00	Using index
1	SIMPLE	tz	ref	fk2	fk2	23	test.ty.c3	3	100.00	Using index
2	MATERIALIZED	ty	ALL	PRIMARY	NULL	NULL	NULL	3	100.00	NULL
2	MATERIALIZED	tz	ref	fk2	fk2	23	test.ty.c3	3	100.00	Using index
EXPLAIN EXTENDED UPDATE tx,ty,tz 
SET tx.c2=100 
WHERE tx.c1 IN(SELECT c2 from ty WHERE ty.c3 IN(SELECT c3 from tz WHERE c2>2 ORDER BY c2));
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	ty	index	NULL	fk1	5	NULL	3	100.00	Using index; Start temporary
1	SIMPLE	ty	ALL	PRIMARY	NULL	NULL	NULL	3	100.00	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	tx	eq_ref	PRIMARY	PRIMARY	4	test.ty.c2	1	100.00	NULL
1	SIMPLE	tz	ALL	fk2	NULL	NULL	NULL	6	83.33	Using where; End temporary; Using join buffer (Block Nested Loop)
1	SIMPLE	tz	index	NULL	fk2	23	NULL	6	100.00	Using index; Using join buffer (Block Nested Loop)
EXPLAIN EXTENDED UPDATE tx,ty,tz 
SET tx.c2=100 
WHERE tx.c1 IN(SELECT c2 from ty WHERE ty.c3 IN(SELECT c3 from tz));
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	ty	index	NULL	fk1	5	NULL	3	100.00	Using index; Start temporary
1	SIMPLE	ty	ALL	PRIMARY	NULL	NULL	NULL	3	100.00	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	tx	eq_ref	PRIMARY	PRIMARY	4	test.ty.c2	1	100.00	NULL
1	SIMPLE	tz	ref	fk2	fk2	23	test.ty.c3	3	100.00	Using index; End temporary
1	SIMPLE	tz	index	NULL	fk2	23	NULL	6	100.00	Using index; Using join buffer (Block Nested Loop)
UPDATE tx JOIN ty ON tx.c1=ty.c1 JOIN tz ON ty.c3=tz.c3 
SET tx.c2=100 
WHERE tx.c1 IN(SELECT c2 from ty WHERE ty.c3 IN(SELECT c3 from tz WHERE c2>2) ORDER BY c1);
SELECT * FROM tx;
c1	c2
1	1
2	100
3	3
4	100
5	5
ROLLBACK;
UPDATE tx JOIN ty ON tx.c1=ty.c1 LEFT JOIN tz ON ty.c3=tz.c3 
SET tx.c2=100 
WHERE tx.c1 IN(SELECT c2 from ty WHERE ty.c3 IN(SELECT c3 from tz WHERE c2>2));
SELECT * FROM tx;
c1	c2
1	1
2	100
3	3
4	100
5	5
ROLLBACK;
UPDATE tx JOIN ty ON tx.c1=ty.c1 LEFT JOIN tz ON ty.c3=tz.c3 
SET tx.c2=100 
WHERE tx.c1 IN(SELECT c1 from ty WHERE ty.c3 IN(SELECT c3 from tz WHERE c2>2) ORDER BY c2);
SELECT * FROM tx;
c1	c2
1	1
2	100
3	3
4	100
5	5
ROLLBACK;
UPDATE tx JOIN ty ON tx.c1=ty.c1 LEFT JOIN tz ON ty.c3=tz.c3 
SET tx.c2=100 
WHERE tx.c1 IN(SELECT c2 from ty WHERE ty.c3 IN(SELECT c3 from tz));
SELECT * FROM tx;
c1	c2
1	1
2	100
3	3
4	100
5	5
ROLLBACK;
UPDATE tx INNER JOIN ty ON tx.c1=ty.c1 LEFT JOIN tz ON ty.c3=tz.c3 
SET tx.c2=100 
WHERE tx.c1 IN(SELECT c2 from ty WHERE ty.c3 IN(SELECT c3 from tz ORDER BY c2));
SELECT * FROM tx;
c1	c2
1	1
2	100
3	3
4	100
5	5
ROLLBACK;
UPDATE tx,ty,tz 
SET tx.c2=100 
WHERE tx.c1 IN(SELECT c2 from ty WHERE ty.c3 IN(SELECT c3 from tz WHERE c2>2 ORDER BY c2));
SELECT * FROM tx;
c1	c2
1	1
2	100
3	3
4	100
5	5
ROLLBACK;
UPDATE tx,ty,tz 
SET tx.c2=100 
WHERE tx.c1 IN(SELECT c2 from ty WHERE ty.c3 IN(SELECT c3 from tz));
SELECT * FROM tx;
c1	c2
1	1
2	100
3	3
4	100
5	5
ROLLBACK;
# The following queries have JOIN syntax within the IN sub-query
EXPLAIN EXTENDED UPDATE tx JOIN ty ON tx.c1=ty.c1 JOIN tz ON ty.c3=tz.c3 
SET tx.c2=100 
WHERE tx.c1 IN(SELECT ty.c2 from ty,tz WHERE ty.c3 = tz.c3 and tz.c2 > 2);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	<subquery2>	ALL	NULL	NULL	NULL	NULL	NULL	0.00	Using where
1	SIMPLE	tx	eq_ref	PRIMARY	PRIMARY	4	<subquery2>.c2	1	100.00	NULL
1	SIMPLE	ty	ref	PRIMARY,fk1	fk1	5	<subquery2>.c2	1	100.00	Using index
1	SIMPLE	tz	ref	fk2	fk2	23	test.ty.c3	3	100.00	Using index
2	MATERIALIZED	ty	ALL	PRIMARY	NULL	NULL	NULL	3	100.00	NULL
2	MATERIALIZED	tz	ALL	fk2	NULL	NULL	NULL	6	83.33	Using where; Using join buffer (Block Nested Loop)
EXPLAIN EXTENDED UPDATE tx JOIN ty ON tx.c1=ty.c1 JOIN tz ON ty.c3=tz.c3 
SET tx.c2=100 
WHERE tx.c1 IN(SELECT ty.c2 from ty JOIN tz ON ty.c3 = tz.c3 and tz.c2 > 2);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	<subquery2>	ALL	NULL	NULL	NULL	NULL	NULL	0.00	Using where
1	SIMPLE	tx	eq_ref	PRIMARY	PRIMARY	4	<subquery2>.c2	1	100.00	NULL
1	SIMPLE	ty	ref	PRIMARY,fk1	fk1	5	<subquery2>.c2	1	100.00	Using index
1	SIMPLE	tz	ref	fk2	fk2	23	test.ty.c3	3	100.00	Using index
2	MATERIALIZED	ty	ALL	PRIMARY	NULL	NULL	NULL	3	100.00	NULL
2	MATERIALIZED	tz	ALL	fk2	NULL	NULL	NULL	6	83.33	Using where; Using join buffer (Block Nested Loop)
EXPLAIN EXTENDED UPDATE tx JOIN ty ON tx.c1=ty.c1 JOIN tz ON ty.c3=tz.c3 
SET tx.c2=100 
WHERE tx.c1 IN(SELECT ty.c2 from ty INNER JOIN tz ON ty.c3 = tz.c3 and tz.c2 > 2);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	<subquery2>	ALL	NULL	NULL	NULL	NULL	NULL	0.00	Using where
1	SIMPLE	tx	eq_ref	PRIMARY	PRIMARY	4	<subquery2>.c2	1	100.00	NULL
1	SIMPLE	ty	ref	PRIMARY,fk1	fk1	5	<subquery2>.c2	1	100.00	Using index
1	SIMPLE	tz	ref	fk2	fk2	23	test.ty.c3	3	100.00	Using index
2	MATERIALIZED	ty	ALL	PRIMARY	NULL	NULL	NULL	3	100.00	NULL
2	MATERIALIZED	tz	ALL	fk2	NULL	NULL	NULL	6	83.33	Using where; Using join buffer (Block Nested Loop)
EXPLAIN EXTENDED UPDATE tx JOIN ty ON tx.c1=ty.c1 JOIN tz ON ty.c3=tz.c3 
SET tx.c2=100 
WHERE tx.c1 IN(SELECT ty.c2 from ty LEFT JOIN tz ON ty.c3 = tz.c3 and tz.c2 > 2);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	ty	ALL	NULL	NULL	NULL	NULL	3	100.00	Using where; Start temporary
1	SIMPLE	ty	ref	PRIMARY,fk1	fk1	5	test.ty.c2	1	100.00	Using index
1	SIMPLE	tx	eq_ref	PRIMARY	PRIMARY	4	test.ty.c2	1	100.00	NULL
1	SIMPLE	tz	ALL	fk2	NULL	NULL	NULL	6	83.33	Using where; End temporary; Using join buffer (Block Nested Loop)
1	SIMPLE	tz	ref	fk2	fk2	23	test.ty.c3	3	100.00	Using index
EXPLAIN EXTENDED UPDATE tx INNER JOIN ty ON tx.c1=ty.c1 LEFT JOIN tz ON ty.c3=tz.c3 
SET tx.c2=100 
WHERE tx.c1 IN(SELECT c2 from ty) AND tx.c1 IN(SELECT c2 from tz);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	ty	ALL	NULL	NULL	NULL	NULL	3	100.00	Using where; Start temporary
1	SIMPLE	ty	ref	fk1	fk1	5	test.ty.c2	1	100.00	Using index
1	SIMPLE	tx	eq_ref	PRIMARY	PRIMARY	4	test.ty.c2	1	100.00	End temporary
1	SIMPLE	tz	ALL	NULL	NULL	NULL	NULL	6	100.00	Using where; FirstMatch(tx); Using join buffer (Block Nested Loop)
1	SIMPLE	tz	ref	fk2	fk2	23	test.ty.c3	3	100.00	Using index
UPDATE tx JOIN ty ON tx.c1=ty.c1 JOIN tz ON ty.c3=tz.c3 
SET tx.c2=100 
WHERE tx.c1 IN(SELECT ty.c2 from ty,tz WHERE ty.c3 = tz.c3 and tz.c2 > 2);
SELECT * FROM tx;
c1	c2
1	1
2	100
3	3
4	100
5	5
ROLLBACK;
UPDATE tx JOIN ty ON tx.c1=ty.c1 JOIN tz ON ty.c3=tz.c3 
SET tx.c2=100 
WHERE tx.c1 IN(SELECT ty.c2 from ty JOIN tz ON ty.c3 = tz.c3 and tz.c2 > 2);
SELECT * FROM tx;
c1	c2
1	1
2	100
3	3
4	100
5	5
ROLLBACK;
UPDATE tx JOIN ty ON tx.c1=ty.c1 JOIN tz ON ty.c3=tz.c3 
SET tx.c2=100 
WHERE tx.c1 IN(SELECT ty.c2 from ty INNER JOIN tz ON ty.c3 = tz.c3 and tz.c2 > 2);
SELECT * FROM tx;
c1	c2
1	1
2	100
3	3
4	100
5	5
ROLLBACK;
UPDATE tx JOIN ty ON tx.c1=ty.c1 JOIN tz ON ty.c3=tz.c3 
SET tx.c2=100 
WHERE tx.c1 IN(SELECT ty.c2 from ty LEFT JOIN tz ON ty.c3 = tz.c3 and tz.c2 > 2);
SELECT * FROM tx;
c1	c2
1	1
2	100
3	3
4	100
5	5
ROLLBACK;
UPDATE tx INNER JOIN ty ON tx.c1=ty.c1 LEFT JOIN tz ON ty.c3=tz.c3 
SET tx.c2=100 
WHERE tx.c1 IN(SELECT c2 from ty) AND tx.c1 IN(SELECT c2 from tz);
SELECT * FROM tx;
c1	c2
1	1
2	100
3	3
4	100
5	5
ROLLBACK;
# Updating  columns from more than 1 table 
EXPLAIN EXTENDED UPDATE tx,ty,tz 
SET tx.c2=100,tz.c2=101 
WHERE tx.c1 IN(SELECT c2 from ty);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	ty	index	NULL	fk1	5	NULL	3	100.00	Using index
1	SIMPLE	<subquery2>	ALL	NULL	NULL	NULL	NULL	NULL	0.00	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	tx	eq_ref	PRIMARY	PRIMARY	4	<subquery2>.c2	1	100.00	NULL
1	SIMPLE	tz	ALL	NULL	NULL	NULL	NULL	6	100.00	Using join buffer (Block Nested Loop)
2	MATERIALIZED	ty	ALL	NULL	NULL	NULL	NULL	3	100.00	NULL
EXPLAIN EXTENDED UPDATE tx INNER JOIN ty ON tx.c1=ty.c1 LEFT JOIN tz ON ty.c3=tz.c3 
SET tx.c2=100,tz.c2=101 
WHERE tx.c1 IN(SELECT c2 from ty);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	ty	ALL	NULL	NULL	NULL	NULL	3	100.00	Using where; Start temporary
1	SIMPLE	ty	ref	fk1	fk1	5	test.ty.c2	1	100.00	Using index
1	SIMPLE	tx	eq_ref	PRIMARY	PRIMARY	4	test.ty.c2	1	100.00	End temporary
1	SIMPLE	tz	ALL	fk2	NULL	NULL	NULL	6	83.33	Using where; Using join buffer (Block Nested Loop)
UPDATE tx,ty,tz 
SET tx.c2=100,tz.c2=101 
WHERE tx.c1 IN(SELECT c2 from ty);
SELECT * FROM tx;
c1	c2
1	100
2	100
3	3
4	100
5	5
SELECT * FROM tz;
c1	c2	c3
2	101	2 match tx
4	101	4 match tx
20	101	2 match tx
40	101	4 match tx
200	101	2 match tx
400	101	4 match tx
ROLLBACK;
UPDATE tx INNER JOIN ty ON tx.c1=ty.c1 LEFT JOIN tz ON ty.c3=tz.c3 
SET tx.c2=100,tz.c2=101 
WHERE tx.c1 IN(SELECT c2 from ty);
SELECT * FROM tx;
c1	c2
1	100
2	100
3	3
4	100
5	5
SELECT * FROM tz;
c1	c2	c3
2	101	2 match tx
4	101	4 match tx
20	101	2 match tx
40	101	4 match tx
200	101	2 match tx
400	101	4 match tx
ROLLBACK;
# Testing multi-table DELETE
ALTER TABLE roster DROP FOREIGN KEY roster_ibfk_1;
ALTER TABLE roster DROP FOREIGN KEY roster_ibfk_2;
ALTER TABLE roster DROP PRIMARY KEY;
ALTER TABLE class DROP PRIMARY KEY;
ALTER TABLE student DROP PRIMARY KEY;
ALTER TABLE roster ADD KEY(class_num);
# The optimizer_switch is set to default. We are verifying the various supported JOIN types for SEMI-JOIN
SET optimizer_switch=default;
COMMIT;
EXPLAIN EXTENDED DELETE class FROM class RIGHT JOIN roster 
ON class.class_num=roster.class_num 
WHERE roster.class_num IN (SELECT class_num FROM roster);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	roster	index	class_num	class_num	5	NULL	1	100.00	Using where; Using index
1	SIMPLE	class	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	roster	ref	class_num	class_num	5	test.roster.class_num	1	100.00	Using index; FirstMatch(class)
EXPLAIN EXTENDED DELETE LOW_PRIORITY FROM class USING class INNER JOIN roster 
ON class.class_num=roster.class_num 
WHERE class.class_num IN (SELECT class_num FROM roster);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	class	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	SIMPLE	roster	ref	class_num	class_num	5	test.class.class_num	1	100.00	Using index
1	SIMPLE	roster	ref	class_num	class_num	5	test.class.class_num	1	100.00	Using index; FirstMatch(roster)
EXPLAIN EXTENDED DELETE QUICK FROM class USING class LEFT JOIN roster 
ON class.class_num=roster.class_num 
WHERE class.class_num IN (SELECT class_num FROM roster);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	class	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	SIMPLE	roster	ref	class_num	class_num	5	test.class.class_num	1	100.00	Using index; FirstMatch(class)
1	SIMPLE	roster	ref	class_num	class_num	5	test.class.class_num	1	100.00	Using index
EXPLAIN EXTENDED DELETE IGNORE FROM class USING class RIGHT JOIN roster 
ON class.class_num=roster.class_num 
WHERE class.class_num IN (SELECT class_num FROM roster);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	class	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where
1	SIMPLE	roster	ref	class_num	class_num	5	test.class.class_num	1	100.00	Using index
1	SIMPLE	roster	ref	class_num	class_num	5	test.class.class_num	1	100.00	Using index; FirstMatch(roster)
EXPLAIN EXTENDED DELETE class FROM class, roster 
WHERE class.class_num IN (SELECT class_num FROM roster);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	class	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	SIMPLE	roster	index	NULL	class_num	5	NULL	1	100.00	Using index; Using join buffer (Block Nested Loop)
1	SIMPLE	roster	ref	class_num	class_num	5	test.class.class_num	1	100.00	Using index; FirstMatch(roster)
EXPLAIN EXTENDED DELETE FROM class USING class, roster 
WHERE class.class_num IN (SELECT class_num FROM roster);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	class	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	SIMPLE	roster	index	NULL	class_num	5	NULL	1	100.00	Using index; Using join buffer (Block Nested Loop)
1	SIMPLE	roster	ref	class_num	class_num	5	test.class.class_num	1	100.00	Using index; FirstMatch(roster)
EXPLAIN EXTENDED DELETE student FROM student LEFT JOIN roster 
ON student.stu_name=roster.stu_name 
WHERE student.stu_name IN (SELECT stu_name FROM roster);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	student	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	SIMPLE	roster	ref	fk2	fk2	23	test.student.stu_name	1	100.00	Using index; FirstMatch(student)
1	SIMPLE	roster	ref	fk2	fk2	23	test.student.stu_name	1	100.00	Using index
EXPLAIN EXTENDED DELETE student FROM student INNER JOIN roster INNER JOIN class 
ON student.stu_name=roster.stu_name AND roster.class_num = class.class_num AND stu_city = 'bbsr' 
WHERE student.stu_name IN (SELECT stu_name FROM roster);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	student	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where
1	SIMPLE	class	ALL	NULL	NULL	NULL	NULL	1	100.00	Using join buffer (Block Nested Loop)
1	SIMPLE	roster	ref	fk2,class_num	fk2	23	test.student.stu_name	1	100.00	Using where
1	SIMPLE	roster	ref	fk2	fk2	23	test.student.stu_name	1	100.00	Using index; FirstMatch(roster)
EXPLAIN EXTENDED DELETE tz FROM tz JOIN ty 
ON tz.c3=ty.c3 JOIN tx ON ty.c1=tx.c1 
WHERE ty.c1 IN(SELECT c2 from ty WHERE ty.c1 IN(SELECT c1 from tx WHERE c2>2));
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	ty	ALL	fk1	NULL	NULL	NULL	3	100.00	Using where; Start temporary
1	SIMPLE	ty	ref	PRIMARY,fk1	fk1	5	test.ty.c2	1	100.00	Using index
1	SIMPLE	tx	eq_ref	PRIMARY	PRIMARY	4	test.ty.c2	1	100.00	Using index
1	SIMPLE	tx	eq_ref	PRIMARY	PRIMARY	4	test.ty.c1	1	100.00	Using where; End temporary
1	SIMPLE	tz	ref	fk2	fk2	23	test.ty.c3	3	100.00	NULL
EXPLAIN EXTENDED DELETE FROM tz USING tz JOIN ty 
ON tz.c3=ty.c3 LEFT JOIN tx ON ty.c1=tx.c1 
WHERE ty.c1 IN(SELECT c2 from ty WHERE ty.c1 IN(SELECT c1 from tx WHERE c2>2));
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	ty	ALL	fk1	NULL	NULL	NULL	3	100.00	Using where; Start temporary
1	SIMPLE	ty	ref	PRIMARY,fk1	fk1	5	test.ty.c2	1	100.00	Using index
1	SIMPLE	tx	eq_ref	PRIMARY	PRIMARY	4	test.ty.c2	1	100.00	Using index
1	SIMPLE	tx	eq_ref	PRIMARY	PRIMARY	4	test.ty.c1	1	100.00	Using where; End temporary
1	SIMPLE	tz	ref	fk2	fk2	23	test.ty.c3	3	100.00	NULL
EXPLAIN EXTENDED DELETE FROM tz USING tz JOIN ty 
ON tz.c3=ty.c3 LEFT JOIN tx ON ty.c1=tx.c1 
WHERE ty.c1 IN(SELECT c2 from ty WHERE ty.c1 IN(SELECT c1 from tx));
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	ty	ALL	fk1	NULL	NULL	NULL	3	100.00	Using where; Start temporary
1	SIMPLE	ty	ref	PRIMARY,fk1	fk1	5	test.ty.c2	1	100.00	Using index
1	SIMPLE	tx	eq_ref	PRIMARY	PRIMARY	4	test.ty.c2	1	100.00	Using index
1	SIMPLE	tx	eq_ref	PRIMARY	PRIMARY	4	test.ty.c1	1	100.00	Using index; End temporary
1	SIMPLE	tz	ref	fk2	fk2	23	test.ty.c3	3	100.00	NULL
EXPLAIN EXTENDED DELETE FROM tz USING tz INNER JOIN ty 
ON tz.c3=ty.c3 LEFT JOIN tx ON ty.c1=tx.c1 
WHERE ty.c1 IN(SELECT c2 from ty WHERE ty.c1 IN(SELECT c1 from tx));
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	ty	ALL	fk1	NULL	NULL	NULL	3	100.00	Using where; Start temporary
1	SIMPLE	ty	ref	PRIMARY,fk1	fk1	5	test.ty.c2	1	100.00	Using index
1	SIMPLE	tx	eq_ref	PRIMARY	PRIMARY	4	test.ty.c2	1	100.00	Using index
1	SIMPLE	tx	eq_ref	PRIMARY	PRIMARY	4	test.ty.c1	1	100.00	Using index; End temporary
1	SIMPLE	tz	ref	fk2	fk2	23	test.ty.c3	3	100.00	NULL
EXPLAIN EXTENDED DELETE tz FROM tx,ty,tz 
WHERE tx.c1 IN(SELECT c2 from ty WHERE ty.c3 IN(SELECT c3 from tx WHERE c2>2));
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	ty	index	NULL	fk1	5	NULL	3	100.00	Using index; Start temporary
1	SIMPLE	ty	ALL	NULL	NULL	NULL	NULL	3	100.00	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	tx	eq_ref	PRIMARY	PRIMARY	4	test.ty.c2	1	100.00	Using index
1	SIMPLE	tx	ALL	NULL	NULL	NULL	NULL	5	100.00	Using where; End temporary; Using join buffer (Block Nested Loop)
1	SIMPLE	tz	ALL	NULL	NULL	NULL	NULL	6	100.00	Using join buffer (Block Nested Loop)
Warnings:
Note	1276	Field or reference 'test.ty.c3' of SELECT #3 was resolved in SELECT #2
EXPLAIN EXTENDED DELETE tz FROM tx,ty,tz 
WHERE ty.c1 IN(SELECT c2 from tx WHERE ty.c1 IN(SELECT c1 from tx));
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	tx	ALL	NULL	NULL	NULL	NULL	5	100.00	Using where; Start temporary
1	SIMPLE	ty	ref	fk1	fk1	5	test.tx.c2	1	100.00	Using index
1	SIMPLE	tx	eq_ref	PRIMARY	PRIMARY	4	test.tx.c2	1	100.00	Using index; End temporary
1	SIMPLE	tx	index	NULL	PRIMARY	4	NULL	5	100.00	Using index; Using join buffer (Block Nested Loop)
1	SIMPLE	tz	ALL	NULL	NULL	NULL	NULL	6	100.00	Using join buffer (Block Nested Loop)
Warnings:
Note	1276	Field or reference 'test.ty.c1' of SELECT #2 was resolved in SELECT #1
DELETE class FROM class RIGHT JOIN roster 
ON class.class_num=roster.class_num 
WHERE roster.class_num IN (SELECT class_num FROM roster);
SELECT * FROM class;
class_num	class_name
2	science
ROLLBACK;
DELETE LOW_PRIORITY FROM class USING class INNER JOIN roster 
ON class.class_num=roster.class_num 
WHERE class.class_num IN (SELECT class_num FROM roster);
SELECT * FROM class;
class_num	class_name
2	science
ROLLBACK;
DELETE QUICK FROM class USING class LEFT JOIN roster 
ON class.class_num=roster.class_num 
WHERE class.class_num IN (SELECT class_num FROM roster);
SELECT * FROM class;
class_num	class_name
2	science
ROLLBACK;
DELETE IGNORE FROM class USING class RIGHT JOIN roster 
ON class.class_num=roster.class_num 
WHERE class.class_num IN (SELECT class_num FROM roster);
SELECT * FROM class;
class_num	class_name
2	science
ROLLBACK;
DELETE class FROM class, roster 
WHERE class.class_num IN (SELECT class_num FROM roster);
SELECT * FROM class;
class_num	class_name
2	science
ROLLBACK;
DELETE FROM class USING class, roster 
WHERE class.class_num IN (SELECT class_num FROM roster);
SELECT * FROM class;
class_num	class_name
2	science
ROLLBACK;
DELETE student FROM student LEFT JOIN roster 
ON student.stu_name=roster.stu_name 
WHERE student.stu_name IN (SELECT stu_name FROM roster);
SELECT * FROM student;
stu_name	stu_city	stu_id
rajdeep	bbsr	4
ROLLBACK;
DELETE student FROM student INNER JOIN roster INNER JOIN class 
ON student.stu_name=roster.stu_name AND roster.class_num = class.class_num AND stu_city = 'bbsr' 
WHERE student.stu_name IN (SELECT stu_name FROM roster);
SELECT * FROM student;
stu_name	stu_city	stu_id
amit	bangalore	1
ashu	hyderabad	2
rajdeep	bbsr	4
sumit	kota	2
ROLLBACK;
DELETE tz FROM tz JOIN ty 
ON tz.c3=ty.c3 JOIN tx ON ty.c1=tx.c1 
WHERE ty.c1 IN(SELECT c2 from ty WHERE ty.c1 IN(SELECT c1 from tx WHERE c2>2));
SELECT * FROM tz;
c1	c2	c3
2	2	2 match tx
20	20	2 match tx
200	200	2 match tx
ROLLBACK;
DELETE FROM tz USING tz JOIN ty 
ON tz.c3=ty.c3 LEFT JOIN tx ON ty.c1=tx.c1 
WHERE ty.c1 IN(SELECT c2 from ty WHERE ty.c1 IN(SELECT c1 from tx WHERE c2>2));
SELECT * FROM tz;
c1	c2	c3
2	2	2 match tx
20	20	2 match tx
200	200	2 match tx
ROLLBACK;
DELETE FROM tz USING tz JOIN ty 
ON tz.c3=ty.c3 LEFT JOIN tx ON ty.c1=tx.c1 
WHERE ty.c1 IN(SELECT c2 from ty WHERE ty.c1 IN(SELECT c1 from tx));
SELECT * FROM tz;
c1	c2	c3
ROLLBACK;
DELETE FROM tz USING tz INNER JOIN ty 
ON tz.c3=ty.c3 LEFT JOIN tx ON ty.c1=tx.c1 
WHERE ty.c1 IN(SELECT c2 from ty WHERE ty.c1 IN(SELECT c1 from tx));
SELECT * FROM tz;
c1	c2	c3
ROLLBACK;
DELETE tz FROM tx,ty,tz 
WHERE tx.c1 IN(SELECT c2 from ty WHERE ty.c3 IN(SELECT c3 from tx WHERE c2>2));
SELECT * FROM tz;
c1	c2	c3
ROLLBACK;
DELETE tz FROM tx,ty,tz 
WHERE ty.c1 IN(SELECT c2 from tx WHERE ty.c1 IN(SELECT c1 from tx));
SELECT * FROM tz;
c1	c2	c3
ROLLBACK;
# The following queries would select Firstmatch based on the optimizer switch settings
# Please note that some of the queries would still show Duplicate Weedout
SET optimizer_switch='semijoin=on,firstmatch=on,materialization=off,loosescan=off,index_condition_pushdown=off,mrr=off';
COMMIT;
EXPLAIN EXTENDED DELETE class FROM class RIGHT JOIN roster 
ON class.class_num=roster.class_num 
WHERE roster.class_num IN (SELECT class_num FROM roster);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	roster	index	class_num	class_num	5	NULL	1	100.00	Using where; Using index
1	SIMPLE	class	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	roster	ref	class_num	class_num	5	test.roster.class_num	1	100.00	Using index; FirstMatch(class)
EXPLAIN EXTENDED DELETE LOW_PRIORITY FROM class USING class INNER JOIN roster 
ON class.class_num=roster.class_num 
WHERE class.class_num IN (SELECT class_num FROM roster);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	class	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	SIMPLE	roster	ref	class_num	class_num	5	test.class.class_num	1	100.00	Using index
1	SIMPLE	roster	ref	class_num	class_num	5	test.class.class_num	1	100.00	Using index; FirstMatch(roster)
EXPLAIN EXTENDED DELETE QUICK FROM class USING class LEFT JOIN roster 
ON class.class_num=roster.class_num 
WHERE class.class_num IN (SELECT class_num FROM roster);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	class	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	SIMPLE	roster	ref	class_num	class_num	5	test.class.class_num	1	100.00	Using index; FirstMatch(class)
1	SIMPLE	roster	ref	class_num	class_num	5	test.class.class_num	1	100.00	Using index
EXPLAIN EXTENDED DELETE IGNORE FROM class USING class RIGHT JOIN roster 
ON class.class_num=roster.class_num 
WHERE class.class_num IN (SELECT class_num FROM roster);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	class	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where
1	SIMPLE	roster	ref	class_num	class_num	5	test.class.class_num	1	100.00	Using index
1	SIMPLE	roster	ref	class_num	class_num	5	test.class.class_num	1	100.00	Using index; FirstMatch(roster)
EXPLAIN EXTENDED DELETE class FROM class, roster 
WHERE class.class_num IN (SELECT class_num FROM roster);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	class	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	SIMPLE	roster	index	NULL	class_num	5	NULL	1	100.00	Using index; Using join buffer (Block Nested Loop)
1	SIMPLE	roster	ref	class_num	class_num	5	test.class.class_num	1	100.00	Using index; FirstMatch(roster)
EXPLAIN EXTENDED DELETE FROM class USING class, roster 
WHERE class.class_num IN (SELECT class_num FROM roster);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	class	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	SIMPLE	roster	index	NULL	class_num	5	NULL	1	100.00	Using index; Using join buffer (Block Nested Loop)
1	SIMPLE	roster	ref	class_num	class_num	5	test.class.class_num	1	100.00	Using index; FirstMatch(roster)
EXPLAIN EXTENDED DELETE student FROM student LEFT JOIN roster 
ON student.stu_name=roster.stu_name 
WHERE student.stu_name IN (SELECT stu_name FROM roster);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	student	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	SIMPLE	roster	ref	fk2	fk2	23	test.student.stu_name	1	100.00	Using index; FirstMatch(student)
1	SIMPLE	roster	ref	fk2	fk2	23	test.student.stu_name	1	100.00	Using index
EXPLAIN EXTENDED DELETE student FROM student INNER JOIN roster INNER JOIN class 
ON student.stu_name=roster.stu_name AND roster.class_num = class.class_num AND stu_city = 'bbsr' 
WHERE student.stu_name IN (SELECT stu_name FROM roster);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	student	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where
1	SIMPLE	class	ALL	NULL	NULL	NULL	NULL	1	100.00	Using join buffer (Block Nested Loop)
1	SIMPLE	roster	ref	fk2,class_num	fk2	23	test.student.stu_name	1	100.00	Using where
1	SIMPLE	roster	ref	fk2	fk2	23	test.student.stu_name	1	100.00	Using index; FirstMatch(roster)
EXPLAIN EXTENDED DELETE tz FROM tz JOIN ty 
ON tz.c3=ty.c3 JOIN tx ON ty.c1=tx.c1 
WHERE ty.c1 IN(SELECT c2 from ty WHERE ty.c1 IN(SELECT c1 from tx WHERE c2>2));
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	tz	ALL	fk2	NULL	NULL	NULL	1	100.00	Using where
1	SIMPLE	ty	eq_ref	PRIMARY,fk1	PRIMARY	22	test.tz.c3	1	100.00	Using where
1	SIMPLE	tx	eq_ref	PRIMARY	PRIMARY	4	test.ty.c1	1	100.00	Using index
1	SIMPLE	ty	ALL	fk1	NULL	NULL	NULL	3	100.00	Using where
1	SIMPLE	tx	eq_ref	PRIMARY	PRIMARY	4	test.ty.c1	1	100.00	Using where; FirstMatch(tx)
EXPLAIN EXTENDED DELETE FROM tz USING tz JOIN ty 
ON tz.c3=ty.c3 LEFT JOIN tx ON ty.c1=tx.c1 
WHERE ty.c1 IN(SELECT c2 from ty WHERE ty.c1 IN(SELECT c1 from tx WHERE c2>2));
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	tz	ALL	fk2	NULL	NULL	NULL	1	100.00	Using where
1	SIMPLE	ty	eq_ref	PRIMARY,fk1	PRIMARY	22	test.tz.c3	1	100.00	NULL
1	SIMPLE	tx	eq_ref	PRIMARY	PRIMARY	4	test.ty.c1	1	100.00	Using index
1	SIMPLE	ty	ALL	fk1	NULL	NULL	NULL	3	100.00	Using where
1	SIMPLE	tx	eq_ref	PRIMARY	PRIMARY	4	test.ty.c1	1	100.00	Using where; FirstMatch(tx)
EXPLAIN EXTENDED DELETE FROM tz USING tz JOIN ty 
ON tz.c3=ty.c3 LEFT JOIN tx ON ty.c1=tx.c1 
WHERE ty.c1 IN(SELECT c2 from ty WHERE ty.c1 IN(SELECT c1 from tx));
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	tz	ALL	fk2	NULL	NULL	NULL	1	100.00	Using where
1	SIMPLE	ty	eq_ref	PRIMARY,fk1	PRIMARY	22	test.tz.c3	1	100.00	NULL
1	SIMPLE	tx	eq_ref	PRIMARY	PRIMARY	4	test.ty.c1	1	100.00	Using index
1	SIMPLE	ty	ALL	fk1	NULL	NULL	NULL	3	100.00	Using where
1	SIMPLE	tx	eq_ref	PRIMARY	PRIMARY	4	test.ty.c1	1	100.00	Using index; FirstMatch(tx)
EXPLAIN EXTENDED DELETE FROM tz USING tz INNER JOIN ty 
ON tz.c3=ty.c3 LEFT JOIN tx ON ty.c1=tx.c1 
WHERE ty.c1 IN(SELECT c2 from ty WHERE ty.c1 IN(SELECT c1 from tx));
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	tz	ALL	fk2	NULL	NULL	NULL	1	100.00	Using where
1	SIMPLE	ty	eq_ref	PRIMARY,fk1	PRIMARY	22	test.tz.c3	1	100.00	NULL
1	SIMPLE	tx	eq_ref	PRIMARY	PRIMARY	4	test.ty.c1	1	100.00	Using index
1	SIMPLE	ty	ALL	fk1	NULL	NULL	NULL	3	100.00	Using where
1	SIMPLE	tx	eq_ref	PRIMARY	PRIMARY	4	test.ty.c1	1	100.00	Using index; FirstMatch(tx)
EXPLAIN EXTENDED DELETE tz FROM tx,ty,tz 
WHERE tx.c1 IN(SELECT c2 from ty WHERE ty.c3 IN(SELECT c3 from tx WHERE c2>2));
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	tz	ALL	NULL	NULL	NULL	NULL	1	100.00	Start temporary
1	SIMPLE	ty	index	NULL	fk1	5	NULL	3	100.00	Using index; Using join buffer (Block Nested Loop)
1	SIMPLE	ty	ALL	NULL	NULL	NULL	NULL	3	100.00	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	tx	eq_ref	PRIMARY	PRIMARY	4	test.ty.c2	1	100.00	Using index
1	SIMPLE	tx	ALL	NULL	NULL	NULL	NULL	5	100.00	Using where; End temporary; Using join buffer (Block Nested Loop)
Warnings:
Note	1276	Field or reference 'test.ty.c3' of SELECT #3 was resolved in SELECT #2
EXPLAIN EXTENDED DELETE tz FROM tx,ty,tz 
WHERE ty.c1 IN(SELECT c2 from tx WHERE ty.c1 IN(SELECT c1 from tx));
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	tz	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	SIMPLE	ty	index	fk1	fk1	5	NULL	3	100.00	Using where; Using index; Using join buffer (Block Nested Loop)
1	SIMPLE	tx	eq_ref	PRIMARY	PRIMARY	4	test.ty.c1	1	100.00	Using index
1	SIMPLE	tx	ALL	NULL	NULL	NULL	NULL	5	100.00	Using where; FirstMatch(tx); Using join buffer (Block Nested Loop)
1	SIMPLE	tx	index	NULL	PRIMARY	4	NULL	5	100.00	Using index; Using join buffer (Block Nested Loop)
Warnings:
Note	1276	Field or reference 'test.ty.c1' of SELECT #2 was resolved in SELECT #1
DELETE class FROM class RIGHT JOIN roster 
ON class.class_num=roster.class_num 
WHERE roster.class_num IN (SELECT class_num FROM roster);
SELECT * FROM class;
class_num	class_name
2	science
ROLLBACK;
DELETE LOW_PRIORITY FROM class USING class INNER JOIN roster 
ON class.class_num=roster.class_num 
WHERE class.class_num IN (SELECT class_num FROM roster);
SELECT * FROM class;
class_num	class_name
2	science
ROLLBACK;
DELETE QUICK FROM class USING class LEFT JOIN roster 
ON class.class_num=roster.class_num 
WHERE class.class_num IN (SELECT class_num FROM roster);
SELECT * FROM class;
class_num	class_name
2	science
ROLLBACK;
DELETE IGNORE FROM class USING class RIGHT JOIN roster 
ON class.class_num=roster.class_num 
WHERE class.class_num IN (SELECT class_num FROM roster);
SELECT * FROM class;
class_num	class_name
2	science
ROLLBACK;
DELETE class FROM class, roster 
WHERE class.class_num IN (SELECT class_num FROM roster);
SELECT * FROM class;
class_num	class_name
2	science
ROLLBACK;
DELETE FROM class USING class, roster 
WHERE class.class_num IN (SELECT class_num FROM roster);
SELECT * FROM class;
class_num	class_name
2	science
ROLLBACK;
DELETE student FROM student LEFT JOIN roster 
ON student.stu_name=roster.stu_name 
WHERE student.stu_name IN (SELECT stu_name FROM roster);
SELECT * FROM student;
stu_name	stu_city	stu_id
rajdeep	bbsr	4
ROLLBACK;
DELETE student FROM student INNER JOIN roster INNER JOIN class 
ON student.stu_name=roster.stu_name AND roster.class_num = class.class_num AND stu_city = 'bbsr' 
WHERE student.stu_name IN (SELECT stu_name FROM roster);
SELECT * FROM student;
stu_name	stu_city	stu_id
amit	bangalore	1
ashu	hyderabad	2
rajdeep	bbsr	4
sumit	kota	2
ROLLBACK;
DELETE tz FROM tz JOIN ty 
ON tz.c3=ty.c3 JOIN tx ON ty.c1=tx.c1 
WHERE ty.c1 IN(SELECT c2 from ty WHERE ty.c1 IN(SELECT c1 from tx WHERE c2>2));
SELECT * FROM tz;
c1	c2	c3
2	2	2 match tx
20	20	2 match tx
200	200	2 match tx
ROLLBACK;
DELETE FROM tz USING tz JOIN ty 
ON tz.c3=ty.c3 LEFT JOIN tx ON ty.c1=tx.c1 
WHERE ty.c1 IN(SELECT c2 from ty WHERE ty.c1 IN(SELECT c1 from tx WHERE c2>2));
SELECT * FROM tz;
c1	c2	c3
2	2	2 match tx
20	20	2 match tx
200	200	2 match tx
ROLLBACK;
DELETE FROM tz USING tz JOIN ty 
ON tz.c3=ty.c3 LEFT JOIN tx ON ty.c1=tx.c1 
WHERE ty.c1 IN(SELECT c2 from ty WHERE ty.c1 IN(SELECT c1 from tx));
SELECT * FROM tz;
c1	c2	c3
ROLLBACK;
DELETE FROM tz USING tz INNER JOIN ty 
ON tz.c3=ty.c3 LEFT JOIN tx ON ty.c1=tx.c1 
WHERE ty.c1 IN(SELECT c2 from ty WHERE ty.c1 IN(SELECT c1 from tx));
SELECT * FROM tz;
c1	c2	c3
ROLLBACK;
DELETE tz FROM tx,ty,tz 
WHERE tx.c1 IN(SELECT c2 from ty WHERE ty.c3 IN(SELECT c3 from tx WHERE c2>2));
SELECT * FROM tz;
c1	c2	c3
ROLLBACK;
DELETE tz FROM tx,ty,tz 
WHERE ty.c1 IN(SELECT c2 from tx WHERE ty.c1 IN(SELECT c1 from tx));
SELECT * FROM tz;
c1	c2	c3
ROLLBACK;
# The following queries would select Materialize based on the optimizer switch settings
# Please note that some of the queries would still show Duplicate Weedout
SET optimizer_switch='semijoin=on,loosescan=off,firstmatch=off,index_condition_pushdown=off,mrr=off,materialization=on';
COMMIT;
EXPLAIN EXTENDED DELETE class FROM class RIGHT JOIN roster 
ON class.class_num=roster.class_num 
WHERE roster.class_num IN (SELECT class_num FROM roster);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	roster	index	class_num	class_num	5	NULL	1	100.00	Using where; Using index
1	SIMPLE	class	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	<subquery2>	eq_ref	<auto_key>	<auto_key>	5	test.roster.class_num	1	100.00	NULL
2	MATERIALIZED	roster	index	class_num	class_num	5	NULL	1	100.00	Using index
EXPLAIN EXTENDED DELETE LOW_PRIORITY FROM class USING class INNER JOIN roster 
ON class.class_num=roster.class_num 
WHERE class.class_num IN (SELECT class_num FROM roster);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	class	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where
1	SIMPLE	roster	ref	class_num	class_num	5	test.class.class_num	1	100.00	Using index
1	SIMPLE	<subquery2>	eq_ref	<auto_key>	<auto_key>	5	test.class.class_num	1	100.00	NULL
2	MATERIALIZED	roster	index	class_num	class_num	5	NULL	1	100.00	Using index
EXPLAIN EXTENDED DELETE QUICK FROM class USING class LEFT JOIN roster 
ON class.class_num=roster.class_num 
WHERE class.class_num IN (SELECT class_num FROM roster);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	class	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	SIMPLE	roster	ref	class_num	class_num	5	test.class.class_num	1	100.00	Using index; Start temporary
1	SIMPLE	roster	ref	class_num	class_num	5	test.class.class_num	1	100.00	Using index; End temporary
EXPLAIN EXTENDED DELETE IGNORE FROM class USING class RIGHT JOIN roster 
ON class.class_num=roster.class_num 
WHERE class.class_num IN (SELECT class_num FROM roster);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	class	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where
1	SIMPLE	roster	ref	class_num	class_num	5	test.class.class_num	1	100.00	Using index
1	SIMPLE	<subquery2>	eq_ref	<auto_key>	<auto_key>	5	test.class.class_num	1	100.00	NULL
2	MATERIALIZED	roster	index	class_num	class_num	5	NULL	1	100.00	Using index
EXPLAIN EXTENDED DELETE class FROM class, roster 
WHERE class.class_num IN (SELECT class_num FROM roster);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	class	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where
1	SIMPLE	roster	index	NULL	class_num	5	NULL	1	100.00	Using index; Using join buffer (Block Nested Loop)
1	SIMPLE	<subquery2>	eq_ref	<auto_key>	<auto_key>	5	test.class.class_num	1	100.00	NULL
2	MATERIALIZED	roster	index	class_num	class_num	5	NULL	1	100.00	Using index
EXPLAIN EXTENDED DELETE FROM class USING class, roster 
WHERE class.class_num IN (SELECT class_num FROM roster);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	class	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where
1	SIMPLE	roster	index	NULL	class_num	5	NULL	1	100.00	Using index; Using join buffer (Block Nested Loop)
1	SIMPLE	<subquery2>	eq_ref	<auto_key>	<auto_key>	5	test.class.class_num	1	100.00	NULL
2	MATERIALIZED	roster	index	class_num	class_num	5	NULL	1	100.00	Using index
EXPLAIN EXTENDED DELETE student FROM student LEFT JOIN roster 
ON student.stu_name=roster.stu_name 
WHERE student.stu_name IN (SELECT stu_name FROM roster);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	student	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	SIMPLE	roster	ref	fk2	fk2	23	test.student.stu_name	1	100.00	Using index; Start temporary
1	SIMPLE	roster	ref	fk2	fk2	23	test.student.stu_name	1	100.00	Using index; End temporary
EXPLAIN EXTENDED DELETE student FROM student INNER JOIN roster INNER JOIN class 
ON student.stu_name=roster.stu_name AND roster.class_num = class.class_num AND stu_city = 'bbsr' 
WHERE student.stu_name IN (SELECT stu_name FROM roster);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	student	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where
1	SIMPLE	class	ALL	NULL	NULL	NULL	NULL	1	100.00	Using join buffer (Block Nested Loop)
1	SIMPLE	roster	ref	fk2,class_num	fk2	23	test.student.stu_name	1	100.00	Using where
1	SIMPLE	<subquery2>	eq_ref	<auto_key>	<auto_key>	23	test.student.stu_name	1	100.00	NULL
2	MATERIALIZED	roster	index	fk2	fk2	23	NULL	1	100.00	Using index
EXPLAIN EXTENDED DELETE tz FROM tz JOIN ty 
ON tz.c3=ty.c3 JOIN tx ON ty.c1=tx.c1 
WHERE ty.c1 IN(SELECT c2 from ty WHERE ty.c1 IN(SELECT c1 from tx WHERE c2>2));
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	tz	ALL	fk2	NULL	NULL	NULL	1	100.00	Using where
1	SIMPLE	ty	eq_ref	PRIMARY,fk1	PRIMARY	22	test.tz.c3	1	100.00	Using where
1	SIMPLE	tx	eq_ref	PRIMARY	PRIMARY	4	test.ty.c1	1	100.00	Using index
1	SIMPLE	<subquery2>	eq_ref	<auto_key>	<auto_key>	5	test.ty.c1	1	100.00	NULL
2	MATERIALIZED	ty	ALL	fk1	NULL	NULL	NULL	3	100.00	Using where
2	MATERIALIZED	tx	eq_ref	PRIMARY	PRIMARY	4	test.ty.c1	1	100.00	Using where
EXPLAIN EXTENDED DELETE FROM tz USING tz JOIN ty 
ON tz.c3=ty.c3 LEFT JOIN tx ON ty.c1=tx.c1 
WHERE ty.c1 IN(SELECT c2 from ty WHERE ty.c1 IN(SELECT c1 from tx WHERE c2>2));
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	tz	ALL	fk2	NULL	NULL	NULL	1	100.00	Using where
1	SIMPLE	ty	eq_ref	PRIMARY,fk1	PRIMARY	22	test.tz.c3	1	100.00	Using where
1	SIMPLE	tx	eq_ref	PRIMARY	PRIMARY	4	test.ty.c1	1	100.00	Using index
1	SIMPLE	<subquery2>	eq_ref	<auto_key>	<auto_key>	5	test.ty.c1	1	100.00	NULL
2	MATERIALIZED	ty	ALL	fk1	NULL	NULL	NULL	3	100.00	Using where
2	MATERIALIZED	tx	eq_ref	PRIMARY	PRIMARY	4	test.ty.c1	1	100.00	Using where
EXPLAIN EXTENDED DELETE FROM tz USING tz JOIN ty 
ON tz.c3=ty.c3 LEFT JOIN tx ON ty.c1=tx.c1 
WHERE ty.c1 IN(SELECT c2 from ty WHERE ty.c1 IN(SELECT c1 from tx));
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	tz	ALL	fk2	NULL	NULL	NULL	1	100.00	Using where
1	SIMPLE	ty	eq_ref	PRIMARY,fk1	PRIMARY	22	test.tz.c3	1	100.00	Using where
1	SIMPLE	tx	eq_ref	PRIMARY	PRIMARY	4	test.ty.c1	1	100.00	Using index
1	SIMPLE	<subquery2>	eq_ref	<auto_key>	<auto_key>	5	test.ty.c1	1	100.00	NULL
2	MATERIALIZED	ty	ALL	fk1	NULL	NULL	NULL	3	100.00	Using where
2	MATERIALIZED	tx	eq_ref	PRIMARY	PRIMARY	4	test.ty.c1	1	100.00	Using index
EXPLAIN EXTENDED DELETE FROM tz USING tz INNER JOIN ty 
ON tz.c3=ty.c3 LEFT JOIN tx ON ty.c1=tx.c1 
WHERE ty.c1 IN(SELECT c2 from ty WHERE ty.c1 IN(SELECT c1 from tx));
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	tz	ALL	fk2	NULL	NULL	NULL	1	100.00	Using where
1	SIMPLE	ty	eq_ref	PRIMARY,fk1	PRIMARY	22	test.tz.c3	1	100.00	Using where
1	SIMPLE	tx	eq_ref	PRIMARY	PRIMARY	4	test.ty.c1	1	100.00	Using index
1	SIMPLE	<subquery2>	eq_ref	<auto_key>	<auto_key>	5	test.ty.c1	1	100.00	NULL
2	MATERIALIZED	ty	ALL	fk1	NULL	NULL	NULL	3	100.00	Using where
2	MATERIALIZED	tx	eq_ref	PRIMARY	PRIMARY	4	test.ty.c1	1	100.00	Using index
EXPLAIN EXTENDED DELETE tz FROM tx,ty,tz 
WHERE tx.c1 IN(SELECT c2 from ty WHERE ty.c3 IN(SELECT c3 from tx WHERE c2>2));
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	tz	ALL	NULL	NULL	NULL	NULL	1	100.00	Start temporary
1	SIMPLE	ty	index	NULL	fk1	5	NULL	3	100.00	Using index; Using join buffer (Block Nested Loop)
1	SIMPLE	ty	ALL	NULL	NULL	NULL	NULL	3	100.00	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	tx	eq_ref	PRIMARY	PRIMARY	4	test.ty.c2	1	100.00	Using index
1	SIMPLE	tx	ALL	NULL	NULL	NULL	NULL	5	100.00	Using where; End temporary; Using join buffer (Block Nested Loop)
Warnings:
Note	1276	Field or reference 'test.ty.c3' of SELECT #3 was resolved in SELECT #2
EXPLAIN EXTENDED DELETE tz FROM tx,ty,tz 
WHERE ty.c1 IN(SELECT c2 from tx WHERE ty.c1 IN(SELECT c1 from tx));
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	tz	ALL	NULL	NULL	NULL	NULL	1	100.00	Start temporary
1	SIMPLE	ty	index	fk1	fk1	5	NULL	3	100.00	Using where; Using index; Using join buffer (Block Nested Loop)
1	SIMPLE	tx	eq_ref	PRIMARY	PRIMARY	4	test.ty.c1	1	100.00	Using index
1	SIMPLE	tx	ALL	NULL	NULL	NULL	NULL	5	100.00	Using where; End temporary; Using join buffer (Block Nested Loop)
1	SIMPLE	tx	index	NULL	PRIMARY	4	NULL	5	100.00	Using index; Using join buffer (Block Nested Loop)
Warnings:
Note	1276	Field or reference 'test.ty.c1' of SELECT #2 was resolved in SELECT #1
DELETE class FROM class RIGHT JOIN roster 
ON class.class_num=roster.class_num 
WHERE roster.class_num IN (SELECT class_num FROM roster);
SELECT * FROM class;
class_num	class_name
2	science
ROLLBACK;
DELETE LOW_PRIORITY FROM class USING class INNER JOIN roster 
ON class.class_num=roster.class_num 
WHERE class.class_num IN (SELECT class_num FROM roster);
SELECT * FROM class;
class_num	class_name
2	science
ROLLBACK;
DELETE QUICK FROM class USING class LEFT JOIN roster 
ON class.class_num=roster.class_num 
WHERE class.class_num IN (SELECT class_num FROM roster);
SELECT * FROM class;
class_num	class_name
2	science
ROLLBACK;
DELETE IGNORE FROM class USING class RIGHT JOIN roster 
ON class.class_num=roster.class_num 
WHERE class.class_num IN (SELECT class_num FROM roster);
SELECT * FROM class;
class_num	class_name
2	science
ROLLBACK;
DELETE class FROM class, roster 
WHERE class.class_num IN (SELECT class_num FROM roster);
SELECT * FROM class;
class_num	class_name
2	science
ROLLBACK;
DELETE FROM class USING class, roster 
WHERE class.class_num IN (SELECT class_num FROM roster);
SELECT * FROM class;
class_num	class_name
2	science
ROLLBACK;
DELETE student FROM student LEFT JOIN roster 
ON student.stu_name=roster.stu_name 
WHERE student.stu_name IN (SELECT stu_name FROM roster);
SELECT * FROM student;
stu_name	stu_city	stu_id
rajdeep	bbsr	4
ROLLBACK;
DELETE student FROM student INNER JOIN roster INNER JOIN class 
ON student.stu_name=roster.stu_name AND roster.class_num = class.class_num AND stu_city = 'bbsr' 
WHERE student.stu_name IN (SELECT stu_name FROM roster);
SELECT * FROM student;
stu_name	stu_city	stu_id
amit	bangalore	1
ashu	hyderabad	2
rajdeep	bbsr	4
sumit	kota	2
ROLLBACK;
DELETE tz FROM tz JOIN ty 
ON tz.c3=ty.c3 JOIN tx ON ty.c1=tx.c1 
WHERE ty.c1 IN(SELECT c2 from ty WHERE ty.c1 IN(SELECT c1 from tx WHERE c2>2));
SELECT * FROM tz;
c1	c2	c3
2	2	2 match tx
20	20	2 match tx
200	200	2 match tx
ROLLBACK;
DELETE FROM tz USING tz JOIN ty 
ON tz.c3=ty.c3 LEFT JOIN tx ON ty.c1=tx.c1 
WHERE ty.c1 IN(SELECT c2 from ty WHERE ty.c1 IN(SELECT c1 from tx WHERE c2>2));
SELECT * FROM tz;
c1	c2	c3
2	2	2 match tx
20	20	2 match tx
200	200	2 match tx
ROLLBACK;
DELETE FROM tz USING tz JOIN ty 
ON tz.c3=ty.c3 LEFT JOIN tx ON ty.c1=tx.c1 
WHERE ty.c1 IN(SELECT c2 from ty WHERE ty.c1 IN(SELECT c1 from tx));
SELECT * FROM tz;
c1	c2	c3
ROLLBACK;
DELETE FROM tz USING tz INNER JOIN ty 
ON tz.c3=ty.c3 LEFT JOIN tx ON ty.c1=tx.c1 
WHERE ty.c1 IN(SELECT c2 from ty WHERE ty.c1 IN(SELECT c1 from tx));
SELECT * FROM tz;
c1	c2	c3
ROLLBACK;
DELETE tz FROM tx,ty,tz 
WHERE tx.c1 IN(SELECT c2 from ty WHERE ty.c3 IN(SELECT c3 from tx WHERE c2>2));
SELECT * FROM tz;
c1	c2	c3
ROLLBACK;
DELETE tz FROM tx,ty,tz 
WHERE ty.c1 IN(SELECT c2 from tx WHERE ty.c1 IN(SELECT c1 from tx));
SELECT * FROM tz;
c1	c2	c3
ROLLBACK;
# The following queries would select Duplicate Weedout strategy based on the optimizer switch settings
SET optimizer_switch='loosescan=off,firstmatch=off,index_condition_pushdown=off,mrr=off,semijoin=on,materialization=off';
COMMIT;
EXPLAIN EXTENDED DELETE class FROM class RIGHT JOIN roster 
ON class.class_num=roster.class_num 
WHERE roster.class_num IN (SELECT class_num FROM roster);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	roster	index	class_num	class_num	5	NULL	1	100.00	Using where; Using index
1	SIMPLE	class	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	roster	ref	class_num	class_num	5	test.roster.class_num	1	100.00	Using index; Start temporary; End temporary
EXPLAIN EXTENDED DELETE LOW_PRIORITY FROM class USING class INNER JOIN roster 
ON class.class_num=roster.class_num 
WHERE class.class_num IN (SELECT class_num FROM roster);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	class	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	SIMPLE	roster	ref	class_num	class_num	5	test.class.class_num	1	100.00	Using index
1	SIMPLE	roster	ref	class_num	class_num	5	test.class.class_num	1	100.00	Using index; Start temporary; End temporary
EXPLAIN EXTENDED DELETE QUICK FROM class USING class LEFT JOIN roster 
ON class.class_num=roster.class_num 
WHERE class.class_num IN (SELECT class_num FROM roster);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	class	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	SIMPLE	roster	ref	class_num	class_num	5	test.class.class_num	1	100.00	Using index; Start temporary
1	SIMPLE	roster	ref	class_num	class_num	5	test.class.class_num	1	100.00	Using index; End temporary
EXPLAIN EXTENDED DELETE IGNORE FROM class USING class RIGHT JOIN roster 
ON class.class_num=roster.class_num 
WHERE class.class_num IN (SELECT class_num FROM roster);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	class	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where
1	SIMPLE	roster	ref	class_num	class_num	5	test.class.class_num	1	100.00	Using index
1	SIMPLE	roster	ref	class_num	class_num	5	test.class.class_num	1	100.00	Using index; Start temporary; End temporary
EXPLAIN EXTENDED DELETE class FROM class, roster 
WHERE class.class_num IN (SELECT class_num FROM roster);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	class	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	SIMPLE	roster	index	NULL	class_num	5	NULL	1	100.00	Using index; Using join buffer (Block Nested Loop)
1	SIMPLE	roster	ref	class_num	class_num	5	test.class.class_num	1	100.00	Using index; Start temporary; End temporary
EXPLAIN EXTENDED DELETE FROM class USING class, roster 
WHERE class.class_num IN (SELECT class_num FROM roster);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	class	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	SIMPLE	roster	index	NULL	class_num	5	NULL	1	100.00	Using index; Using join buffer (Block Nested Loop)
1	SIMPLE	roster	ref	class_num	class_num	5	test.class.class_num	1	100.00	Using index; Start temporary; End temporary
EXPLAIN EXTENDED DELETE student FROM student LEFT JOIN roster 
ON student.stu_name=roster.stu_name 
WHERE student.stu_name IN (SELECT stu_name FROM roster);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	student	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	SIMPLE	roster	ref	fk2	fk2	23	test.student.stu_name	1	100.00	Using index; Start temporary
1	SIMPLE	roster	ref	fk2	fk2	23	test.student.stu_name	1	100.00	Using index; End temporary
EXPLAIN EXTENDED DELETE student FROM student INNER JOIN roster INNER JOIN class 
ON student.stu_name=roster.stu_name AND roster.class_num = class.class_num AND stu_city = 'bbsr' 
WHERE student.stu_name IN (SELECT stu_name FROM roster);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	student	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where
1	SIMPLE	class	ALL	NULL	NULL	NULL	NULL	1	100.00	Using join buffer (Block Nested Loop)
1	SIMPLE	roster	ref	fk2,class_num	fk2	23	test.student.stu_name	1	100.00	Using where
1	SIMPLE	roster	ref	fk2	fk2	23	test.student.stu_name	1	100.00	Using index; Start temporary; End temporary
EXPLAIN EXTENDED DELETE tz FROM tz JOIN ty 
ON tz.c3=ty.c3 JOIN tx ON ty.c1=tx.c1 
WHERE ty.c1 IN(SELECT c2 from ty WHERE ty.c1 IN(SELECT c1 from tx WHERE c2>2));
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	tz	ALL	fk2	NULL	NULL	NULL	1	100.00	Using where; Start temporary
1	SIMPLE	ty	eq_ref	PRIMARY,fk1	PRIMARY	22	test.tz.c3	1	100.00	Using where
1	SIMPLE	tx	eq_ref	PRIMARY	PRIMARY	4	test.ty.c1	1	100.00	Using index
1	SIMPLE	ty	ALL	fk1	NULL	NULL	NULL	3	100.00	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	tx	eq_ref	PRIMARY	PRIMARY	4	test.ty.c1	1	100.00	Using where; End temporary
EXPLAIN EXTENDED DELETE FROM tz USING tz JOIN ty 
ON tz.c3=ty.c3 LEFT JOIN tx ON ty.c1=tx.c1 
WHERE ty.c1 IN(SELECT c2 from ty WHERE ty.c1 IN(SELECT c1 from tx WHERE c2>2));
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	tz	ALL	fk2	NULL	NULL	NULL	1	100.00	Using where; Start temporary
1	SIMPLE	ty	eq_ref	PRIMARY,fk1	PRIMARY	22	test.tz.c3	1	100.00	NULL
1	SIMPLE	tx	eq_ref	PRIMARY	PRIMARY	4	test.ty.c1	1	100.00	Using index
1	SIMPLE	ty	ALL	fk1	NULL	NULL	NULL	3	100.00	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	tx	eq_ref	PRIMARY	PRIMARY	4	test.ty.c1	1	100.00	Using where; End temporary
EXPLAIN EXTENDED DELETE FROM tz USING tz JOIN ty 
ON tz.c3=ty.c3 LEFT JOIN tx ON ty.c1=tx.c1 
WHERE ty.c1 IN(SELECT c2 from ty WHERE ty.c1 IN(SELECT c1 from tx));
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	tz	ALL	fk2	NULL	NULL	NULL	1	100.00	Using where; Start temporary
1	SIMPLE	ty	eq_ref	PRIMARY,fk1	PRIMARY	22	test.tz.c3	1	100.00	NULL
1	SIMPLE	tx	eq_ref	PRIMARY	PRIMARY	4	test.ty.c1	1	100.00	Using index
1	SIMPLE	ty	ALL	fk1	NULL	NULL	NULL	3	100.00	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	tx	eq_ref	PRIMARY	PRIMARY	4	test.ty.c1	1	100.00	Using index; End temporary
EXPLAIN EXTENDED DELETE FROM tz USING tz INNER JOIN ty 
ON tz.c3=ty.c3 LEFT JOIN tx ON ty.c1=tx.c1 
WHERE ty.c1 IN(SELECT c2 from ty WHERE ty.c1 IN(SELECT c1 from tx));
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	tz	ALL	fk2	NULL	NULL	NULL	1	100.00	Using where; Start temporary
1	SIMPLE	ty	eq_ref	PRIMARY,fk1	PRIMARY	22	test.tz.c3	1	100.00	NULL
1	SIMPLE	tx	eq_ref	PRIMARY	PRIMARY	4	test.ty.c1	1	100.00	Using index
1	SIMPLE	ty	ALL	fk1	NULL	NULL	NULL	3	100.00	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	tx	eq_ref	PRIMARY	PRIMARY	4	test.ty.c1	1	100.00	Using index; End temporary
EXPLAIN EXTENDED DELETE tz FROM tx,ty,tz 
WHERE tx.c1 IN(SELECT c2 from ty WHERE ty.c3 IN(SELECT c3 from tx WHERE c2>2));
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	tz	ALL	NULL	NULL	NULL	NULL	1	100.00	Start temporary
1	SIMPLE	ty	index	NULL	fk1	5	NULL	3	100.00	Using index; Using join buffer (Block Nested Loop)
1	SIMPLE	ty	ALL	NULL	NULL	NULL	NULL	3	100.00	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	tx	eq_ref	PRIMARY	PRIMARY	4	test.ty.c2	1	100.00	Using index
1	SIMPLE	tx	ALL	NULL	NULL	NULL	NULL	5	100.00	Using where; End temporary; Using join buffer (Block Nested Loop)
Warnings:
Note	1276	Field or reference 'test.ty.c3' of SELECT #3 was resolved in SELECT #2
EXPLAIN EXTENDED DELETE tz FROM tx,ty,tz 
WHERE ty.c1 IN(SELECT c2 from tx WHERE ty.c1 IN(SELECT c1 from tx));
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	tz	ALL	NULL	NULL	NULL	NULL	1	100.00	Start temporary
1	SIMPLE	ty	index	fk1	fk1	5	NULL	3	100.00	Using where; Using index; Using join buffer (Block Nested Loop)
1	SIMPLE	tx	eq_ref	PRIMARY	PRIMARY	4	test.ty.c1	1	100.00	Using index
1	SIMPLE	tx	ALL	NULL	NULL	NULL	NULL	5	100.00	Using where; End temporary; Using join buffer (Block Nested Loop)
1	SIMPLE	tx	index	NULL	PRIMARY	4	NULL	5	100.00	Using index; Using join buffer (Block Nested Loop)
Warnings:
Note	1276	Field or reference 'test.ty.c1' of SELECT #2 was resolved in SELECT #1
DELETE class FROM class RIGHT JOIN roster 
ON class.class_num=roster.class_num 
WHERE roster.class_num IN (SELECT class_num FROM roster);
SELECT * FROM class;
class_num	class_name
2	science
ROLLBACK;
DELETE LOW_PRIORITY FROM class USING class INNER JOIN roster 
ON class.class_num=roster.class_num 
WHERE class.class_num IN (SELECT class_num FROM roster);
SELECT * FROM class;
class_num	class_name
2	science
ROLLBACK;
DELETE QUICK FROM class USING class LEFT JOIN roster 
ON class.class_num=roster.class_num 
WHERE class.class_num IN (SELECT class_num FROM roster);
SELECT * FROM class;
class_num	class_name
2	science
ROLLBACK;
DELETE IGNORE FROM class USING class RIGHT JOIN roster 
ON class.class_num=roster.class_num 
WHERE class.class_num IN (SELECT class_num FROM roster);
SELECT * FROM class;
class_num	class_name
2	science
ROLLBACK;
DELETE class FROM class, roster 
WHERE class.class_num IN (SELECT class_num FROM roster);
SELECT * FROM class;
class_num	class_name
2	science
ROLLBACK;
DELETE FROM class USING class, roster 
WHERE class.class_num IN (SELECT class_num FROM roster);
SELECT * FROM class;
class_num	class_name
2	science
ROLLBACK;
DELETE student FROM student LEFT JOIN roster 
ON student.stu_name=roster.stu_name 
WHERE student.stu_name IN (SELECT stu_name FROM roster);
SELECT * FROM student;
stu_name	stu_city	stu_id
rajdeep	bbsr	4
ROLLBACK;
DELETE student FROM student INNER JOIN roster INNER JOIN class 
ON student.stu_name=roster.stu_name AND roster.class_num = class.class_num AND stu_city = 'bbsr' 
WHERE student.stu_name IN (SELECT stu_name FROM roster);
SELECT * FROM student;
stu_name	stu_city	stu_id
amit	bangalore	1
ashu	hyderabad	2
rajdeep	bbsr	4
sumit	kota	2
ROLLBACK;
DELETE tz FROM tz JOIN ty 
ON tz.c3=ty.c3 JOIN tx ON ty.c1=tx.c1 
WHERE ty.c1 IN(SELECT c2 from ty WHERE ty.c1 IN(SELECT c1 from tx WHERE c2>2));
SELECT * FROM tz;
c1	c2	c3
2	2	2 match tx
20	20	2 match tx
200	200	2 match tx
ROLLBACK;
DELETE FROM tz USING tz JOIN ty 
ON tz.c3=ty.c3 LEFT JOIN tx ON ty.c1=tx.c1 
WHERE ty.c1 IN(SELECT c2 from ty WHERE ty.c1 IN(SELECT c1 from tx WHERE c2>2));
SELECT * FROM tz;
c1	c2	c3
2	2	2 match tx
20	20	2 match tx
200	200	2 match tx
ROLLBACK;
DELETE FROM tz USING tz JOIN ty 
ON tz.c3=ty.c3 LEFT JOIN tx ON ty.c1=tx.c1 
WHERE ty.c1 IN(SELECT c2 from ty WHERE ty.c1 IN(SELECT c1 from tx));
SELECT * FROM tz;
c1	c2	c3
ROLLBACK;
DELETE FROM tz USING tz INNER JOIN ty 
ON tz.c3=ty.c3 LEFT JOIN tx ON ty.c1=tx.c1 
WHERE ty.c1 IN(SELECT c2 from ty WHERE ty.c1 IN(SELECT c1 from tx));
SELECT * FROM tz;
c1	c2	c3
ROLLBACK;
DELETE tz FROM tx,ty,tz 
WHERE tx.c1 IN(SELECT c2 from ty WHERE ty.c3 IN(SELECT c3 from tx WHERE c2>2));
SELECT * FROM tz;
c1	c2	c3
ROLLBACK;
DELETE tz FROM tx,ty,tz 
WHERE ty.c1 IN(SELECT c2 from tx WHERE ty.c1 IN(SELECT c1 from tx));
SELECT * FROM tz;
c1	c2	c3
ROLLBACK;
# The following queries would select Loosescan strategy based on the optimizer switch settings
# Please note that some of the queries would still show Duplicate Weedout
SET optimizer_switch='loosescan=on,firstmatch=off,index_condition_pushdown=off,mrr=off,semijoin=on,materialization=off';
COMMIT;
EXPLAIN EXTENDED DELETE class FROM class RIGHT JOIN roster 
ON class.class_num=roster.class_num 
WHERE roster.class_num IN (SELECT class_num FROM roster);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	roster	index	class_num	class_num	5	NULL	1	100.00	Using where; Using index
1	SIMPLE	class	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	roster	ref	class_num	class_num	5	test.roster.class_num	1	100.00	Using index; Start temporary; End temporary
EXPLAIN EXTENDED DELETE LOW_PRIORITY FROM class USING class INNER JOIN roster 
ON class.class_num=roster.class_num 
WHERE class.class_num IN (SELECT class_num FROM roster);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	class	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	SIMPLE	roster	ref	class_num	class_num	5	test.class.class_num	1	100.00	Using index
1	SIMPLE	roster	ref	class_num	class_num	5	test.class.class_num	1	100.00	Using index; Start temporary; End temporary
EXPLAIN EXTENDED DELETE QUICK FROM class USING class LEFT JOIN roster 
ON class.class_num=roster.class_num 
WHERE class.class_num IN (SELECT class_num FROM roster);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	class	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	SIMPLE	roster	ref	class_num	class_num	5	test.class.class_num	1	100.00	Using index; Start temporary
1	SIMPLE	roster	ref	class_num	class_num	5	test.class.class_num	1	100.00	Using index; End temporary
EXPLAIN EXTENDED DELETE IGNORE FROM class USING class RIGHT JOIN roster 
ON class.class_num=roster.class_num 
WHERE class.class_num IN (SELECT class_num FROM roster);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	class	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where
1	SIMPLE	roster	ref	class_num	class_num	5	test.class.class_num	1	100.00	Using index
1	SIMPLE	roster	ref	class_num	class_num	5	test.class.class_num	1	100.00	Using index; Start temporary; End temporary
EXPLAIN EXTENDED DELETE class FROM class, roster 
WHERE class.class_num IN (SELECT class_num FROM roster);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	class	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	SIMPLE	roster	index	NULL	class_num	5	NULL	1	100.00	Using index; Using join buffer (Block Nested Loop)
1	SIMPLE	roster	ref	class_num	class_num	5	test.class.class_num	1	100.00	Using index; Start temporary; End temporary
EXPLAIN EXTENDED DELETE FROM class USING class, roster 
WHERE class.class_num IN (SELECT class_num FROM roster);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	class	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	SIMPLE	roster	index	NULL	class_num	5	NULL	1	100.00	Using index; Using join buffer (Block Nested Loop)
1	SIMPLE	roster	ref	class_num	class_num	5	test.class.class_num	1	100.00	Using index; Start temporary; End temporary
EXPLAIN EXTENDED DELETE student FROM student LEFT JOIN roster 
ON student.stu_name=roster.stu_name 
WHERE student.stu_name IN (SELECT stu_name FROM roster);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	student	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	SIMPLE	roster	ref	fk2	fk2	23	test.student.stu_name	1	100.00	Using index; Start temporary
1	SIMPLE	roster	ref	fk2	fk2	23	test.student.stu_name	1	100.00	Using index; End temporary
EXPLAIN EXTENDED DELETE student FROM student INNER JOIN roster INNER JOIN class 
ON student.stu_name=roster.stu_name AND roster.class_num = class.class_num AND stu_city = 'bbsr' 
WHERE student.stu_name IN (SELECT stu_name FROM roster);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	student	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where
1	SIMPLE	class	ALL	NULL	NULL	NULL	NULL	1	100.00	Using join buffer (Block Nested Loop)
1	SIMPLE	roster	ref	fk2,class_num	fk2	23	test.student.stu_name	1	100.00	Using where
1	SIMPLE	roster	ref	fk2	fk2	23	test.student.stu_name	1	100.00	Using index; Start temporary; End temporary
EXPLAIN EXTENDED DELETE tz FROM tz JOIN ty 
ON tz.c3=ty.c3 JOIN tx ON ty.c1=tx.c1 
WHERE ty.c1 IN(SELECT c2 from ty WHERE ty.c1 IN(SELECT c1 from tx WHERE c2>2));
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	tz	ALL	fk2	NULL	NULL	NULL	1	100.00	Using where; Start temporary
1	SIMPLE	ty	eq_ref	PRIMARY,fk1	PRIMARY	22	test.tz.c3	1	100.00	Using where
1	SIMPLE	tx	eq_ref	PRIMARY	PRIMARY	4	test.ty.c1	1	100.00	Using index
1	SIMPLE	ty	ALL	fk1	NULL	NULL	NULL	3	100.00	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	tx	eq_ref	PRIMARY	PRIMARY	4	test.ty.c1	1	100.00	Using where; End temporary
EXPLAIN EXTENDED DELETE FROM tz USING tz JOIN ty 
ON tz.c3=ty.c3 LEFT JOIN tx ON ty.c1=tx.c1 
WHERE ty.c1 IN(SELECT c2 from ty WHERE ty.c1 IN(SELECT c1 from tx WHERE c2>2));
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	tz	ALL	fk2	NULL	NULL	NULL	1	100.00	Using where; Start temporary
1	SIMPLE	ty	eq_ref	PRIMARY,fk1	PRIMARY	22	test.tz.c3	1	100.00	NULL
1	SIMPLE	tx	eq_ref	PRIMARY	PRIMARY	4	test.ty.c1	1	100.00	Using index
1	SIMPLE	ty	ALL	fk1	NULL	NULL	NULL	3	100.00	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	tx	eq_ref	PRIMARY	PRIMARY	4	test.ty.c1	1	100.00	Using where; End temporary
EXPLAIN EXTENDED DELETE FROM tz USING tz JOIN ty 
ON tz.c3=ty.c3 LEFT JOIN tx ON ty.c1=tx.c1 
WHERE ty.c1 IN(SELECT c2 from ty WHERE ty.c1 IN(SELECT c1 from tx));
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	tz	ALL	fk2	NULL	NULL	NULL	1	100.00	Using where; Start temporary
1	SIMPLE	ty	eq_ref	PRIMARY,fk1	PRIMARY	22	test.tz.c3	1	100.00	NULL
1	SIMPLE	tx	eq_ref	PRIMARY	PRIMARY	4	test.ty.c1	1	100.00	Using index
1	SIMPLE	ty	ALL	fk1	NULL	NULL	NULL	3	100.00	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	tx	eq_ref	PRIMARY	PRIMARY	4	test.ty.c1	1	100.00	Using index; End temporary
EXPLAIN EXTENDED DELETE FROM tz USING tz INNER JOIN ty 
ON tz.c3=ty.c3 LEFT JOIN tx ON ty.c1=tx.c1 
WHERE ty.c1 IN(SELECT c2 from ty WHERE ty.c1 IN(SELECT c1 from tx));
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	tz	ALL	fk2	NULL	NULL	NULL	1	100.00	Using where; Start temporary
1	SIMPLE	ty	eq_ref	PRIMARY,fk1	PRIMARY	22	test.tz.c3	1	100.00	NULL
1	SIMPLE	tx	eq_ref	PRIMARY	PRIMARY	4	test.ty.c1	1	100.00	Using index
1	SIMPLE	ty	ALL	fk1	NULL	NULL	NULL	3	100.00	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	tx	eq_ref	PRIMARY	PRIMARY	4	test.ty.c1	1	100.00	Using index; End temporary
EXPLAIN EXTENDED DELETE tz FROM tx,ty,tz 
WHERE tx.c1 IN(SELECT c2 from ty WHERE ty.c3 IN(SELECT c3 from tx WHERE c2>2));
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	tz	ALL	NULL	NULL	NULL	NULL	1	100.00	Start temporary
1	SIMPLE	ty	index	NULL	fk1	5	NULL	3	100.00	Using index; Using join buffer (Block Nested Loop)
1	SIMPLE	ty	ALL	NULL	NULL	NULL	NULL	3	100.00	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	tx	eq_ref	PRIMARY	PRIMARY	4	test.ty.c2	1	100.00	Using index
1	SIMPLE	tx	ALL	NULL	NULL	NULL	NULL	5	100.00	Using where; End temporary; Using join buffer (Block Nested Loop)
Warnings:
Note	1276	Field or reference 'test.ty.c3' of SELECT #3 was resolved in SELECT #2
EXPLAIN EXTENDED DELETE tz FROM tx,ty,tz 
WHERE ty.c1 IN(SELECT c2 from tx WHERE ty.c1 IN(SELECT c1 from tx));
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	tz	ALL	NULL	NULL	NULL	NULL	1	100.00	Start temporary
1	SIMPLE	ty	index	fk1	fk1	5	NULL	3	100.00	Using where; Using index; Using join buffer (Block Nested Loop)
1	SIMPLE	tx	eq_ref	PRIMARY	PRIMARY	4	test.ty.c1	1	100.00	Using index
1	SIMPLE	tx	ALL	NULL	NULL	NULL	NULL	5	100.00	Using where; End temporary; Using join buffer (Block Nested Loop)
1	SIMPLE	tx	index	NULL	PRIMARY	4	NULL	5	100.00	Using index; Using join buffer (Block Nested Loop)
Warnings:
Note	1276	Field or reference 'test.ty.c1' of SELECT #2 was resolved in SELECT #1
DELETE class FROM class RIGHT JOIN roster 
ON class.class_num=roster.class_num 
WHERE roster.class_num IN (SELECT class_num FROM roster);
SELECT * FROM class;
class_num	class_name
2	science
ROLLBACK;
DELETE LOW_PRIORITY FROM class USING class INNER JOIN roster 
ON class.class_num=roster.class_num 
WHERE class.class_num IN (SELECT class_num FROM roster);
SELECT * FROM class;
class_num	class_name
2	science
ROLLBACK;
DELETE QUICK FROM class USING class LEFT JOIN roster 
ON class.class_num=roster.class_num 
WHERE class.class_num IN (SELECT class_num FROM roster);
SELECT * FROM class;
class_num	class_name
2	science
ROLLBACK;
DELETE IGNORE FROM class USING class RIGHT JOIN roster 
ON class.class_num=roster.class_num 
WHERE class.class_num IN (SELECT class_num FROM roster);
SELECT * FROM class;
class_num	class_name
2	science
ROLLBACK;
DELETE class FROM class, roster 
WHERE class.class_num IN (SELECT class_num FROM roster);
SELECT * FROM class;
class_num	class_name
2	science
ROLLBACK;
DELETE FROM class USING class, roster 
WHERE class.class_num IN (SELECT class_num FROM roster);
SELECT * FROM class;
class_num	class_name
2	science
ROLLBACK;
DELETE student FROM student LEFT JOIN roster 
ON student.stu_name=roster.stu_name 
WHERE student.stu_name IN (SELECT stu_name FROM roster);
SELECT * FROM student;
stu_name	stu_city	stu_id
rajdeep	bbsr	4
ROLLBACK;
DELETE student FROM student INNER JOIN roster INNER JOIN class 
ON student.stu_name=roster.stu_name AND roster.class_num = class.class_num AND stu_city = 'bbsr' 
WHERE student.stu_name IN (SELECT stu_name FROM roster);
SELECT * FROM student;
stu_name	stu_city	stu_id
amit	bangalore	1
ashu	hyderabad	2
rajdeep	bbsr	4
sumit	kota	2
ROLLBACK;
DELETE tz FROM tz JOIN ty 
ON tz.c3=ty.c3 JOIN tx ON ty.c1=tx.c1 
WHERE ty.c1 IN(SELECT c2 from ty WHERE ty.c1 IN(SELECT c1 from tx WHERE c2>2));
SELECT * FROM tz;
c1	c2	c3
2	2	2 match tx
20	20	2 match tx
200	200	2 match tx
ROLLBACK;
DELETE FROM tz USING tz JOIN ty 
ON tz.c3=ty.c3 LEFT JOIN tx ON ty.c1=tx.c1 
WHERE ty.c1 IN(SELECT c2 from ty WHERE ty.c1 IN(SELECT c1 from tx WHERE c2>2));
SELECT * FROM tz;
c1	c2	c3
2	2	2 match tx
20	20	2 match tx
200	200	2 match tx
ROLLBACK;
DELETE FROM tz USING tz JOIN ty 
ON tz.c3=ty.c3 LEFT JOIN tx ON ty.c1=tx.c1 
WHERE ty.c1 IN(SELECT c2 from ty WHERE ty.c1 IN(SELECT c1 from tx));
SELECT * FROM tz;
c1	c2	c3
ROLLBACK;
DELETE FROM tz USING tz INNER JOIN ty 
ON tz.c3=ty.c3 LEFT JOIN tx ON ty.c1=tx.c1 
WHERE ty.c1 IN(SELECT c2 from ty WHERE ty.c1 IN(SELECT c1 from tx));
SELECT * FROM tz;
c1	c2	c3
ROLLBACK;
DELETE tz FROM tx,ty,tz 
WHERE tx.c1 IN(SELECT c2 from ty WHERE ty.c3 IN(SELECT c3 from tx WHERE c2>2));
SELECT * FROM tz;
c1	c2	c3
ROLLBACK;
DELETE tz FROM tx,ty,tz 
WHERE ty.c1 IN(SELECT c2 from tx WHERE ty.c1 IN(SELECT c1 from tx));
SELECT * FROM tz;
c1	c2	c3
ROLLBACK;
# Drop the tables that were created
DROP TABLE tz;
DROP TABLE ty;
DROP TABLE tx;
DROP TABLE roster;
DROP TABLE student;
DROP TABLE class;
COMMIT;
# Verifying the feature with partitioned table
CREATE TABLE emp  (
id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
fname VARCHAR(25) NOT NULL,
lname VARCHAR(25) NOT NULL,
store_id INT NOT NULL,
dept_id INT NOT NULL,
KEY(dept_id)
) ENGINE=INNODB   
PARTITION BY RANGE(id)  (
PARTITION p0 VALUES LESS THAN (5),
PARTITION p1 VALUES LESS THAN (10),
PARTITION p2 VALUES LESS THAN (15),
PARTITION p3 VALUES LESS THAN MAXVALUE
);
CREATE TABLE dept (
dept_id INT NOT NULL,
dept_name varchar(25) NOT NULL,
KEY(dept_id)
) ENGINE=INNODB
PARTITION BY RANGE(dept_id) (
PARTITION p0 VALUES LESS THAN (3),
PARTITION p1 VALUES LESS THAN (6),
PARTITION p3 VALUES LESS THAN MAXVALUE
);
INSERT INTO emp(fname, lname, store_id, dept_id) VALUES
('Bob', 'Taylor', 3, 2), ('Frank', 'Williams', 1, 2), 
('Ellen', 'Johnson', 3, 4), ('Jim', 'Smith', 2, 4),  
('Mary', 'Jones', 1, 1), ('Linda', 'Black', 2, 3),
('Ed', 'Jones', 2, 1), ('June', 'Wilson', 3, 1), 
('Andy', 'Smith', 1, 3), ('Lou', 'Waters', 2, 4),  
('Jill', 'Stone', 1, 4), ('Roger', 'White', 3, 2),
('Howard', 'Andrews', 1, 2), ('Fred', 'Goldberg', 3, 3), 
('Barbara', 'Brown', 2, 3), ('Alice', 'Rogers', 2, 2),  
('Mark', 'Morgan', 3, 3), ('Karen', 'Cole', 3, 2);
INSERT INTO dept VALUES
(1,'admin'),(2, 'finance'),
(3,'IT'),(4, 'security'),
(5,'ref'),(6,'services');
COMMIT;
# Verfying with partitioned tables keeping the default optimizer_switch settings
EXPLAIN EXTENDED UPDATE emp PARTITION(p1,p3) JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500 
WHERE emp.dept_id IN (SELECT dept_id from dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	dept	index	dept_id	dept_id	4	NULL	6	100.00	Using index; LooseScan
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	Using index
1	SIMPLE	emp	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	NULL
EXPLAIN EXTENDED UPDATE emp PARTITION(p1,p0) JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500 
WHERE dept.dept_id IN (SELECT dept_id from dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	dept	index	dept_id	dept_id	4	NULL	6	100.00	Using index; LooseScan
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	Using index
1	SIMPLE	emp	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	NULL
EXPLAIN EXTENDED UPDATE emp PARTITION(p0,p3) RIGHT JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500 
WHERE emp.dept_id IN (SELECT dept_id from dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	dept	index	dept_id	dept_id	4	NULL	6	100.00	Using index; LooseScan
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	Using index
1	SIMPLE	emp	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	NULL
EXPLAIN EXTENDED UPDATE LOW_PRIORITY emp PARTITION(p3,p2,p0) JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500 
WHERE emp.dept_id IN (SELECT dept_id from dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	dept	index	dept_id	dept_id	4	NULL	6	100.00	Using index; LooseScan
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	Using index
1	SIMPLE	emp	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	NULL
EXPLAIN EXTENDED UPDATE IGNORE emp PARTITION(p3,p1,p2,p0) JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500 
WHERE emp.dept_id IN (SELECT dept_id from dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	dept	index	dept_id	dept_id	4	NULL	6	100.00	Using index; LooseScan
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	Using index
1	SIMPLE	emp	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	NULL
EXPLAIN EXTENDED UPDATE emp LEFT JOIN dept PARTITION(p0) ON emp.dept_id = dept.dept_id 
SET dept.dept_name = 'Junk' 
WHERE dept.dept_id IN (SELECT dept_id from emp);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	dept	ALL	dept_id	NULL	NULL	NULL	2	100.00	Using where
1	SIMPLE	emp	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	Using index
1	SIMPLE	emp	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	Using index; Start temporary; End temporary
EXPLAIN EXTENDED UPDATE emp INNER JOIN dept PARTITION(p1,p0) ON emp.dept_id = dept.dept_id 
SET dept.dept_name = 'Junk' 
WHERE dept.dept_id IN (SELECT DISTINCT dept_id from emp);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	dept	ALL	dept_id	NULL	NULL	NULL	5	100.00	NULL
1	SIMPLE	emp	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	Using index
1	SIMPLE	emp	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	Using index; Start temporary; End temporary
EXPLAIN EXTENDED UPDATE emp PARTITION(p0,p2), dept 
SET emp.store_id = 500 
WHERE emp.dept_id IN (SELECT dept_id FROM dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	emp	ALL	dept_id	NULL	NULL	NULL	9	100.00	NULL
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index; Start temporary; End temporary
1	SIMPLE	dept	index	NULL	dept_id	4	NULL	6	100.00	Using index; Using join buffer (Block Nested Loop)
EXPLAIN EXTENDED UPDATE emp INNER JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500, emp.lname = 'not SET', emp.fname = 'not SET' 
WHERE emp.dept_id IN (SELECT dept_id FROM dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	dept	index	dept_id	dept_id	4	NULL	6	100.00	Using index; LooseScan
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	Using index
1	SIMPLE	emp	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	NULL
EXPLAIN EXTENDED UPDATE emp INNER JOIN dept ON emp.dept_id = dept.dept_id AND emp.fname = 'Bob' OR emp.lname = 'Cole' 
SET emp.store_id = 500, emp.lname = 'not SET', emp.fname = 'not SET' 
WHERE emp.dept_id IN (SELECT dept_id FROM dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	dept	index	dept_id	dept_id	4	NULL	6	100.00	Using index; LooseScan
1	SIMPLE	emp	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	Using where
1	SIMPLE	dept	index	dept_id	dept_id	4	NULL	6	100.00	Using where; Using index; Using join buffer (Block Nested Loop)
EXPLAIN EXTENDED UPDATE emp PARTITION(p0,p1,p2) INNER JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500 
WHERE emp.dept_id IN (SELECT dept_id FROM dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	dept	index	dept_id	dept_id	4	NULL	6	100.00	Using index; LooseScan
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	Using index
1	SIMPLE	emp	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	NULL
EXPLAIN EXTENDED UPDATE emp PARTITION(p1,p3) JOIN dept ON emp.dept_id IN (SELECT dept_id FROM dept) 
SET emp.store_id = 500;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	emp	ALL	dept_id	NULL	NULL	NULL	9	100.00	NULL
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index; Start temporary; End temporary
1	SIMPLE	dept	index	NULL	dept_id	4	NULL	6	100.00	Using index; Using join buffer (Block Nested Loop)
EXPLAIN EXTENDED DELETE emp FROM emp PARTITION(p1,p3) JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE emp.dept_id IN (SELECT dept_id from dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	dept	index	dept_id	dept_id	4	NULL	6	100.00	Using index; LooseScan
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	Using index
1	SIMPLE	emp	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	NULL
EXPLAIN EXTENDED DELETE FROM emp USING emp PARTITION(p0) JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE dept.dept_id IN (SELECT dept_id from dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	emp	ALL	dept_id	NULL	NULL	NULL	4	100.00	NULL
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index; Start temporary; End temporary
EXPLAIN EXTENDED DELETE QUICK emp FROM emp PARTITION(p1,p2,p3) RIGHT JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE emp.dept_id IN (SELECT dept_id from dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	dept	index	dept_id	dept_id	4	NULL	6	100.00	Using index; LooseScan
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	Using index
1	SIMPLE	emp	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	NULL
EXPLAIN EXTENDED DELETE LOW_PRIORITY emp FROM emp PARTITION(p3,p0) JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE emp.dept_id IN (SELECT dept_id from dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	dept	index	dept_id	dept_id	4	NULL	6	100.00	Using index; LooseScan
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	Using index
1	SIMPLE	emp	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	NULL
EXPLAIN EXTENDED DELETE IGNORE emp FROM emp JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE emp.dept_id IN (SELECT dept_id from dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	dept	index	dept_id	dept_id	4	NULL	6	100.00	Using index; LooseScan
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	Using index
1	SIMPLE	emp	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	NULL
EXPLAIN EXTENDED DELETE emp FROM emp PARTITION(p1,p3,p0) LEFT JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE emp.dept_id IN (SELECT dept_id from dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	dept	index	dept_id	dept_id	4	NULL	6	100.00	Using index; LooseScan
1	SIMPLE	emp	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	NULL
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	Using index
EXPLAIN EXTENDED DELETE emp FROM emp PARTITION(p1,p3,p0,p2) INNER JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE emp.dept_id IN (SELECT dept_id from dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	dept	index	dept_id	dept_id	4	NULL	6	100.00	Using index; LooseScan
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	Using index
1	SIMPLE	emp	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	NULL
UPDATE emp PARTITION(p1,p3) JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500 
WHERE emp.dept_id IN (SELECT dept_id from dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
1	Bob	Taylor	3	2
2	Frank	Williams	1	2
3	Ellen	Johnson	3	4
4	Jim	Smith	2	4
5	Mary	Jones	500	1
6	Linda	Black	500	3
7	Ed	Jones	500	1
8	June	Wilson	500	1
9	Andy	Smith	500	3
10	Lou	Waters	2	4
11	Jill	Stone	1	4
12	Roger	White	3	2
13	Howard	Andrews	1	2
14	Fred	Goldberg	3	3
15	Barbara	Brown	500	3
16	Alice	Rogers	500	2
17	Mark	Morgan	500	3
18	Karen	Cole	500	2
ROLLBACK;
UPDATE emp PARTITION(p1,p0) JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500 
WHERE dept.dept_id IN (SELECT dept_id from dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
1	Bob	Taylor	500	2
2	Frank	Williams	500	2
3	Ellen	Johnson	500	4
4	Jim	Smith	500	4
5	Mary	Jones	500	1
6	Linda	Black	500	3
7	Ed	Jones	500	1
8	June	Wilson	500	1
9	Andy	Smith	500	3
10	Lou	Waters	2	4
11	Jill	Stone	1	4
12	Roger	White	3	2
13	Howard	Andrews	1	2
14	Fred	Goldberg	3	3
15	Barbara	Brown	2	3
16	Alice	Rogers	2	2
17	Mark	Morgan	3	3
18	Karen	Cole	3	2
ROLLBACK;
UPDATE emp PARTITION(p0,p3) RIGHT JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500 
WHERE emp.dept_id IN (SELECT dept_id from dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
1	Bob	Taylor	500	2
2	Frank	Williams	500	2
3	Ellen	Johnson	500	4
4	Jim	Smith	500	4
5	Mary	Jones	1	1
6	Linda	Black	2	3
7	Ed	Jones	2	1
8	June	Wilson	3	1
9	Andy	Smith	1	3
10	Lou	Waters	2	4
11	Jill	Stone	1	4
12	Roger	White	3	2
13	Howard	Andrews	1	2
14	Fred	Goldberg	3	3
15	Barbara	Brown	500	3
16	Alice	Rogers	500	2
17	Mark	Morgan	500	3
18	Karen	Cole	500	2
ROLLBACK;
UPDATE LOW_PRIORITY emp PARTITION(p3,p2,p0) JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500 
WHERE emp.dept_id IN (SELECT dept_id from dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
1	Bob	Taylor	500	2
2	Frank	Williams	500	2
3	Ellen	Johnson	500	4
4	Jim	Smith	500	4
5	Mary	Jones	1	1
6	Linda	Black	2	3
7	Ed	Jones	2	1
8	June	Wilson	3	1
9	Andy	Smith	1	3
10	Lou	Waters	500	4
11	Jill	Stone	500	4
12	Roger	White	500	2
13	Howard	Andrews	500	2
14	Fred	Goldberg	500	3
15	Barbara	Brown	500	3
16	Alice	Rogers	500	2
17	Mark	Morgan	500	3
18	Karen	Cole	500	2
ROLLBACK;
UPDATE IGNORE emp PARTITION(p3,p1,p2,p0) JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500 
WHERE emp.dept_id IN (SELECT dept_id from dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
1	Bob	Taylor	500	2
2	Frank	Williams	500	2
3	Ellen	Johnson	500	4
4	Jim	Smith	500	4
5	Mary	Jones	500	1
6	Linda	Black	500	3
7	Ed	Jones	500	1
8	June	Wilson	500	1
9	Andy	Smith	500	3
10	Lou	Waters	500	4
11	Jill	Stone	500	4
12	Roger	White	500	2
13	Howard	Andrews	500	2
14	Fred	Goldberg	500	3
15	Barbara	Brown	500	3
16	Alice	Rogers	500	2
17	Mark	Morgan	500	3
18	Karen	Cole	500	2
ROLLBACK;
UPDATE emp LEFT JOIN dept PARTITION(p0) ON emp.dept_id = dept.dept_id 
SET dept.dept_name = 'Junk' 
WHERE dept.dept_id IN (SELECT dept_id from emp);
SELECT * FROM dept;
dept_id	dept_name
1	Junk
2	Junk
3	IT
4	security
5	ref
6	services
ROLLBACK;
UPDATE emp INNER JOIN dept PARTITION(p1,p0) ON emp.dept_id = dept.dept_id 
SET dept.dept_name = 'Junk' 
WHERE dept.dept_id IN (SELECT DISTINCT dept_id from emp);
SELECT * FROM dept;
dept_id	dept_name
1	Junk
2	Junk
3	Junk
4	Junk
5	ref
6	services
ROLLBACK;
UPDATE emp PARTITION(p0,p2), dept 
SET emp.store_id = 500 
WHERE emp.dept_id IN (SELECT dept_id FROM dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
1	Bob	Taylor	500	2
2	Frank	Williams	500	2
3	Ellen	Johnson	500	4
4	Jim	Smith	500	4
5	Mary	Jones	1	1
6	Linda	Black	2	3
7	Ed	Jones	2	1
8	June	Wilson	3	1
9	Andy	Smith	1	3
10	Lou	Waters	500	4
11	Jill	Stone	500	4
12	Roger	White	500	2
13	Howard	Andrews	500	2
14	Fred	Goldberg	500	3
15	Barbara	Brown	2	3
16	Alice	Rogers	2	2
17	Mark	Morgan	3	3
18	Karen	Cole	3	2
ROLLBACK;
UPDATE emp INNER JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500, emp.lname = 'not SET', emp.fname = 'not SET' 
WHERE emp.dept_id IN (SELECT dept_id FROM dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
1	not SET	not SET	500	2
2	not SET	not SET	500	2
3	not SET	not SET	500	4
4	not SET	not SET	500	4
5	not SET	not SET	500	1
6	not SET	not SET	500	3
7	not SET	not SET	500	1
8	not SET	not SET	500	1
9	not SET	not SET	500	3
10	not SET	not SET	500	4
11	not SET	not SET	500	4
12	not SET	not SET	500	2
13	not SET	not SET	500	2
14	not SET	not SET	500	3
15	not SET	not SET	500	3
16	not SET	not SET	500	2
17	not SET	not SET	500	3
18	not SET	not SET	500	2
ROLLBACK;
UPDATE emp INNER JOIN dept ON emp.dept_id = dept.dept_id AND emp.fname = 'Bob' OR emp.lname = 'Cole' 
SET emp.store_id = 500, emp.lname = 'not SET', emp.fname = 'not SET' 
WHERE emp.dept_id IN (SELECT dept_id FROM dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
1	not SET	not SET	500	2
2	Frank	Williams	1	2
3	Ellen	Johnson	3	4
4	Jim	Smith	2	4
5	Mary	Jones	1	1
6	Linda	Black	2	3
7	Ed	Jones	2	1
8	June	Wilson	3	1
9	Andy	Smith	1	3
10	Lou	Waters	2	4
11	Jill	Stone	1	4
12	Roger	White	3	2
13	Howard	Andrews	1	2
14	Fred	Goldberg	3	3
15	Barbara	Brown	2	3
16	Alice	Rogers	2	2
17	Mark	Morgan	3	3
18	not SET	not SET	500	2
ROLLBACK;
UPDATE emp PARTITION(p0,p1,p2) INNER JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500 
WHERE emp.dept_id IN (SELECT dept_id FROM dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
1	Bob	Taylor	500	2
2	Frank	Williams	500	2
3	Ellen	Johnson	500	4
4	Jim	Smith	500	4
5	Mary	Jones	500	1
6	Linda	Black	500	3
7	Ed	Jones	500	1
8	June	Wilson	500	1
9	Andy	Smith	500	3
10	Lou	Waters	500	4
11	Jill	Stone	500	4
12	Roger	White	500	2
13	Howard	Andrews	500	2
14	Fred	Goldberg	500	3
15	Barbara	Brown	2	3
16	Alice	Rogers	2	2
17	Mark	Morgan	3	3
18	Karen	Cole	3	2
ROLLBACK;
UPDATE emp PARTITION(p1,p3) JOIN dept ON emp.dept_id IN (SELECT dept_id FROM dept) 
SET emp.store_id = 500;
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
1	Bob	Taylor	3	2
2	Frank	Williams	1	2
3	Ellen	Johnson	3	4
4	Jim	Smith	2	4
5	Mary	Jones	500	1
6	Linda	Black	500	3
7	Ed	Jones	500	1
8	June	Wilson	500	1
9	Andy	Smith	500	3
10	Lou	Waters	2	4
11	Jill	Stone	1	4
12	Roger	White	3	2
13	Howard	Andrews	1	2
14	Fred	Goldberg	3	3
15	Barbara	Brown	500	3
16	Alice	Rogers	500	2
17	Mark	Morgan	500	3
18	Karen	Cole	500	2
ROLLBACK;
DELETE emp FROM emp PARTITION(p1,p3) JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE emp.dept_id IN (SELECT dept_id from dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
1	Bob	Taylor	3	2
2	Frank	Williams	1	2
3	Ellen	Johnson	3	4
4	Jim	Smith	2	4
10	Lou	Waters	2	4
11	Jill	Stone	1	4
12	Roger	White	3	2
13	Howard	Andrews	1	2
14	Fred	Goldberg	3	3
ROLLBACK;
DELETE FROM emp USING emp PARTITION(p0) JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE dept.dept_id IN (SELECT dept_id from dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
5	Mary	Jones	1	1
6	Linda	Black	2	3
7	Ed	Jones	2	1
8	June	Wilson	3	1
9	Andy	Smith	1	3
10	Lou	Waters	2	4
11	Jill	Stone	1	4
12	Roger	White	3	2
13	Howard	Andrews	1	2
14	Fred	Goldberg	3	3
15	Barbara	Brown	2	3
16	Alice	Rogers	2	2
17	Mark	Morgan	3	3
18	Karen	Cole	3	2
ROLLBACK;
DELETE QUICK emp FROM emp PARTITION(p1,p2,p3) RIGHT JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE emp.dept_id IN (SELECT dept_id from dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
1	Bob	Taylor	3	2
2	Frank	Williams	1	2
3	Ellen	Johnson	3	4
4	Jim	Smith	2	4
ROLLBACK;
DELETE LOW_PRIORITY emp FROM emp PARTITION(p3,p0) JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE emp.dept_id IN (SELECT dept_id from dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
5	Mary	Jones	1	1
6	Linda	Black	2	3
7	Ed	Jones	2	1
8	June	Wilson	3	1
9	Andy	Smith	1	3
10	Lou	Waters	2	4
11	Jill	Stone	1	4
12	Roger	White	3	2
13	Howard	Andrews	1	2
14	Fred	Goldberg	3	3
ROLLBACK;
DELETE IGNORE emp FROM emp JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE emp.dept_id IN (SELECT dept_id from dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
ROLLBACK;
DELETE emp FROM emp PARTITION(p1,p3,p0) LEFT JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE emp.dept_id IN (SELECT dept_id from dept);
SELECT * FROM dept;
dept_id	dept_name
1	admin
2	finance
3	IT
4	security
5	ref
6	services
ROLLBACK;
DELETE emp FROM emp PARTITION(p1,p3,p0,p2) INNER JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE emp.dept_id IN (SELECT dept_id from dept);
SELECT * FROM dept;
dept_id	dept_name
1	admin
2	finance
3	IT
4	security
5	ref
6	services
ROLLBACK;
# Tables are partitioned, queries uses Firstmatch
# Please note that some of the queries would still show Duplicate Weedout
SET optimizer_switch='semijoin=on,firstmatch=on,materialization=off,loosescan=off,index_condition_pushdown=off,mrr=off';
COMMIT;
EXPLAIN EXTENDED UPDATE emp PARTITION(p1,p3) JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500 
WHERE emp.dept_id IN (SELECT dept_id from dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	emp	ALL	dept_id	NULL	NULL	NULL	2	100.00	NULL
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index; FirstMatch(dept)
EXPLAIN EXTENDED UPDATE emp PARTITION(p1,p0) JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500 
WHERE dept.dept_id IN (SELECT dept_id from dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	emp	ALL	dept_id	NULL	NULL	NULL	2	100.00	NULL
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index; FirstMatch(dept)
EXPLAIN EXTENDED UPDATE emp PARTITION(p0,p3) RIGHT JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500 
WHERE emp.dept_id IN (SELECT dept_id from dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	emp	ALL	dept_id	NULL	NULL	NULL	2	100.00	Using where
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index; FirstMatch(dept)
EXPLAIN EXTENDED UPDATE LOW_PRIORITY emp PARTITION(p3,p2,p0) JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500 
WHERE emp.dept_id IN (SELECT dept_id from dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	emp	ALL	dept_id	NULL	NULL	NULL	3	100.00	NULL
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index; FirstMatch(dept)
EXPLAIN EXTENDED UPDATE IGNORE emp PARTITION(p3,p1,p2,p0) JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500 
WHERE emp.dept_id IN (SELECT dept_id from dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	emp	ALL	dept_id	NULL	NULL	NULL	4	100.00	NULL
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index; FirstMatch(dept)
EXPLAIN EXTENDED UPDATE emp LEFT JOIN dept PARTITION(p0) ON emp.dept_id = dept.dept_id 
SET dept.dept_name = 'Junk' 
WHERE dept.dept_id IN (SELECT dept_id from emp);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	dept	ALL	dept_id	NULL	NULL	NULL	2	100.00	Using where
1	SIMPLE	emp	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	Using index
1	SIMPLE	emp	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	Using index; FirstMatch(emp)
EXPLAIN EXTENDED UPDATE emp INNER JOIN dept PARTITION(p1,p0) ON emp.dept_id = dept.dept_id 
SET dept.dept_name = 'Junk' 
WHERE dept.dept_id IN (SELECT DISTINCT dept_id from emp);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	dept	ALL	dept_id	NULL	NULL	NULL	5	100.00	NULL
1	SIMPLE	emp	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	Using index
1	SIMPLE	emp	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	Using index; FirstMatch(emp)
EXPLAIN EXTENDED UPDATE emp PARTITION(p0,p2), dept 
SET emp.store_id = 500 
WHERE emp.dept_id IN (SELECT dept_id FROM dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	emp	ALL	dept_id	NULL	NULL	NULL	2	100.00	NULL
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index; FirstMatch(emp)
1	SIMPLE	dept	index	NULL	dept_id	4	NULL	6	100.00	Using index; Using join buffer (Block Nested Loop)
EXPLAIN EXTENDED UPDATE emp INNER JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500, emp.lname = 'not SET', emp.fname = 'not SET' 
WHERE emp.dept_id IN (SELECT dept_id FROM dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	emp	ALL	dept_id	NULL	NULL	NULL	4	100.00	NULL
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index; FirstMatch(dept)
EXPLAIN EXTENDED UPDATE emp INNER JOIN dept ON emp.dept_id = dept.dept_id AND emp.fname = 'Bob' OR emp.lname = 'Cole' 
SET emp.store_id = 500, emp.lname = 'not SET', emp.fname = 'not SET' 
WHERE emp.dept_id IN (SELECT dept_id FROM dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	emp	ALL	dept_id	NULL	NULL	NULL	4	100.00	Using where
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index; FirstMatch(emp)
1	SIMPLE	dept	index	dept_id	dept_id	4	NULL	6	100.00	Using where; Using index; Using join buffer (Block Nested Loop)
EXPLAIN EXTENDED UPDATE emp PARTITION(p0,p1,p2) INNER JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500 
WHERE emp.dept_id IN (SELECT dept_id FROM dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	emp	ALL	dept_id	NULL	NULL	NULL	3	100.00	NULL
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index; FirstMatch(dept)
EXPLAIN EXTENDED UPDATE emp PARTITION(p1,p3) JOIN dept ON emp.dept_id IN (SELECT dept_id FROM dept) 
SET emp.store_id = 500;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	emp	ALL	dept_id	NULL	NULL	NULL	2	100.00	NULL
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index; FirstMatch(emp)
1	SIMPLE	dept	index	NULL	dept_id	4	NULL	6	100.00	Using index; Using join buffer (Block Nested Loop)
EXPLAIN EXTENDED DELETE emp FROM emp PARTITION(p1,p3) JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE emp.dept_id IN (SELECT dept_id from dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	emp	ALL	dept_id	NULL	NULL	NULL	2	100.00	NULL
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index; FirstMatch(dept)
EXPLAIN EXTENDED DELETE FROM emp USING emp PARTITION(p0) JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE dept.dept_id IN (SELECT dept_id from dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	emp	ALL	dept_id	NULL	NULL	NULL	2	100.00	NULL
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index; FirstMatch(dept)
EXPLAIN EXTENDED DELETE QUICK emp FROM emp PARTITION(p1,p2,p3) RIGHT JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE emp.dept_id IN (SELECT dept_id from dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	emp	ALL	dept_id	NULL	NULL	NULL	3	100.00	Using where
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index; FirstMatch(dept)
EXPLAIN EXTENDED DELETE LOW_PRIORITY emp FROM emp PARTITION(p3,p0) JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE emp.dept_id IN (SELECT dept_id from dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	emp	ALL	dept_id	NULL	NULL	NULL	2	100.00	NULL
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index; FirstMatch(dept)
EXPLAIN EXTENDED DELETE IGNORE emp FROM emp JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE emp.dept_id IN (SELECT dept_id from dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	emp	ALL	dept_id	NULL	NULL	NULL	4	100.00	NULL
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index; FirstMatch(dept)
EXPLAIN EXTENDED DELETE emp FROM emp PARTITION(p1,p3,p0) LEFT JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE emp.dept_id IN (SELECT dept_id from dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	emp	ALL	dept_id	NULL	NULL	NULL	3	100.00	NULL
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index; FirstMatch(emp)
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index
EXPLAIN EXTENDED DELETE emp FROM emp PARTITION(p1,p3,p0,p2) INNER JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE emp.dept_id IN (SELECT dept_id from dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	emp	ALL	dept_id	NULL	NULL	NULL	4	100.00	NULL
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index; FirstMatch(dept)
UPDATE emp PARTITION(p1,p3) JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500 
WHERE emp.dept_id IN (SELECT dept_id from dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
1	Bob	Taylor	3	2
2	Frank	Williams	1	2
3	Ellen	Johnson	3	4
4	Jim	Smith	2	4
5	Mary	Jones	500	1
6	Linda	Black	500	3
7	Ed	Jones	500	1
8	June	Wilson	500	1
9	Andy	Smith	500	3
10	Lou	Waters	2	4
11	Jill	Stone	1	4
12	Roger	White	3	2
13	Howard	Andrews	1	2
14	Fred	Goldberg	3	3
15	Barbara	Brown	500	3
16	Alice	Rogers	500	2
17	Mark	Morgan	500	3
18	Karen	Cole	500	2
ROLLBACK;
UPDATE emp PARTITION(p1,p0) JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500 
WHERE dept.dept_id IN (SELECT dept_id from dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
1	Bob	Taylor	500	2
2	Frank	Williams	500	2
3	Ellen	Johnson	500	4
4	Jim	Smith	500	4
5	Mary	Jones	500	1
6	Linda	Black	500	3
7	Ed	Jones	500	1
8	June	Wilson	500	1
9	Andy	Smith	500	3
10	Lou	Waters	2	4
11	Jill	Stone	1	4
12	Roger	White	3	2
13	Howard	Andrews	1	2
14	Fred	Goldberg	3	3
15	Barbara	Brown	2	3
16	Alice	Rogers	2	2
17	Mark	Morgan	3	3
18	Karen	Cole	3	2
ROLLBACK;
UPDATE emp PARTITION(p0,p3) RIGHT JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500 
WHERE emp.dept_id IN (SELECT dept_id from dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
1	Bob	Taylor	500	2
2	Frank	Williams	500	2
3	Ellen	Johnson	500	4
4	Jim	Smith	500	4
5	Mary	Jones	1	1
6	Linda	Black	2	3
7	Ed	Jones	2	1
8	June	Wilson	3	1
9	Andy	Smith	1	3
10	Lou	Waters	2	4
11	Jill	Stone	1	4
12	Roger	White	3	2
13	Howard	Andrews	1	2
14	Fred	Goldberg	3	3
15	Barbara	Brown	500	3
16	Alice	Rogers	500	2
17	Mark	Morgan	500	3
18	Karen	Cole	500	2
ROLLBACK;
UPDATE LOW_PRIORITY emp PARTITION(p3,p2,p0) JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500 
WHERE emp.dept_id IN (SELECT dept_id from dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
1	Bob	Taylor	500	2
2	Frank	Williams	500	2
3	Ellen	Johnson	500	4
4	Jim	Smith	500	4
5	Mary	Jones	1	1
6	Linda	Black	2	3
7	Ed	Jones	2	1
8	June	Wilson	3	1
9	Andy	Smith	1	3
10	Lou	Waters	500	4
11	Jill	Stone	500	4
12	Roger	White	500	2
13	Howard	Andrews	500	2
14	Fred	Goldberg	500	3
15	Barbara	Brown	500	3
16	Alice	Rogers	500	2
17	Mark	Morgan	500	3
18	Karen	Cole	500	2
ROLLBACK;
UPDATE IGNORE emp PARTITION(p3,p1,p2,p0) JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500 
WHERE emp.dept_id IN (SELECT dept_id from dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
1	Bob	Taylor	500	2
2	Frank	Williams	500	2
3	Ellen	Johnson	500	4
4	Jim	Smith	500	4
5	Mary	Jones	500	1
6	Linda	Black	500	3
7	Ed	Jones	500	1
8	June	Wilson	500	1
9	Andy	Smith	500	3
10	Lou	Waters	500	4
11	Jill	Stone	500	4
12	Roger	White	500	2
13	Howard	Andrews	500	2
14	Fred	Goldberg	500	3
15	Barbara	Brown	500	3
16	Alice	Rogers	500	2
17	Mark	Morgan	500	3
18	Karen	Cole	500	2
ROLLBACK;
UPDATE emp LEFT JOIN dept PARTITION(p0) ON emp.dept_id = dept.dept_id 
SET dept.dept_name = 'Junk' 
WHERE dept.dept_id IN (SELECT dept_id from emp);
SELECT * FROM dept;
dept_id	dept_name
1	Junk
2	Junk
3	IT
4	security
5	ref
6	services
ROLLBACK;
UPDATE emp INNER JOIN dept PARTITION(p1,p0) ON emp.dept_id = dept.dept_id 
SET dept.dept_name = 'Junk' 
WHERE dept.dept_id IN (SELECT DISTINCT dept_id from emp);
SELECT * FROM dept;
dept_id	dept_name
1	Junk
2	Junk
3	Junk
4	Junk
5	ref
6	services
ROLLBACK;
UPDATE emp PARTITION(p0,p2), dept 
SET emp.store_id = 500 
WHERE emp.dept_id IN (SELECT dept_id FROM dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
1	Bob	Taylor	500	2
2	Frank	Williams	500	2
3	Ellen	Johnson	500	4
4	Jim	Smith	500	4
5	Mary	Jones	1	1
6	Linda	Black	2	3
7	Ed	Jones	2	1
8	June	Wilson	3	1
9	Andy	Smith	1	3
10	Lou	Waters	500	4
11	Jill	Stone	500	4
12	Roger	White	500	2
13	Howard	Andrews	500	2
14	Fred	Goldberg	500	3
15	Barbara	Brown	2	3
16	Alice	Rogers	2	2
17	Mark	Morgan	3	3
18	Karen	Cole	3	2
ROLLBACK;
UPDATE emp INNER JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500, emp.lname = 'not SET', emp.fname = 'not SET' 
WHERE emp.dept_id IN (SELECT dept_id FROM dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
1	not SET	not SET	500	2
2	not SET	not SET	500	2
3	not SET	not SET	500	4
4	not SET	not SET	500	4
5	not SET	not SET	500	1
6	not SET	not SET	500	3
7	not SET	not SET	500	1
8	not SET	not SET	500	1
9	not SET	not SET	500	3
10	not SET	not SET	500	4
11	not SET	not SET	500	4
12	not SET	not SET	500	2
13	not SET	not SET	500	2
14	not SET	not SET	500	3
15	not SET	not SET	500	3
16	not SET	not SET	500	2
17	not SET	not SET	500	3
18	not SET	not SET	500	2
ROLLBACK;
UPDATE emp INNER JOIN dept ON emp.dept_id = dept.dept_id AND emp.fname = 'Bob' OR emp.lname = 'Cole' 
SET emp.store_id = 500, emp.lname = 'not SET', emp.fname = 'not SET' 
WHERE emp.dept_id IN (SELECT dept_id FROM dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
1	not SET	not SET	500	2
2	Frank	Williams	1	2
3	Ellen	Johnson	3	4
4	Jim	Smith	2	4
5	Mary	Jones	1	1
6	Linda	Black	2	3
7	Ed	Jones	2	1
8	June	Wilson	3	1
9	Andy	Smith	1	3
10	Lou	Waters	2	4
11	Jill	Stone	1	4
12	Roger	White	3	2
13	Howard	Andrews	1	2
14	Fred	Goldberg	3	3
15	Barbara	Brown	2	3
16	Alice	Rogers	2	2
17	Mark	Morgan	3	3
18	not SET	not SET	500	2
ROLLBACK;
UPDATE emp PARTITION(p0,p1,p2) INNER JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500 
WHERE emp.dept_id IN (SELECT dept_id FROM dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
1	Bob	Taylor	500	2
2	Frank	Williams	500	2
3	Ellen	Johnson	500	4
4	Jim	Smith	500	4
5	Mary	Jones	500	1
6	Linda	Black	500	3
7	Ed	Jones	500	1
8	June	Wilson	500	1
9	Andy	Smith	500	3
10	Lou	Waters	500	4
11	Jill	Stone	500	4
12	Roger	White	500	2
13	Howard	Andrews	500	2
14	Fred	Goldberg	500	3
15	Barbara	Brown	2	3
16	Alice	Rogers	2	2
17	Mark	Morgan	3	3
18	Karen	Cole	3	2
ROLLBACK;
UPDATE emp PARTITION(p1,p3) JOIN dept ON emp.dept_id IN (SELECT dept_id FROM dept) 
SET emp.store_id = 500;
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
1	Bob	Taylor	3	2
2	Frank	Williams	1	2
3	Ellen	Johnson	3	4
4	Jim	Smith	2	4
5	Mary	Jones	500	1
6	Linda	Black	500	3
7	Ed	Jones	500	1
8	June	Wilson	500	1
9	Andy	Smith	500	3
10	Lou	Waters	2	4
11	Jill	Stone	1	4
12	Roger	White	3	2
13	Howard	Andrews	1	2
14	Fred	Goldberg	3	3
15	Barbara	Brown	500	3
16	Alice	Rogers	500	2
17	Mark	Morgan	500	3
18	Karen	Cole	500	2
ROLLBACK;
DELETE emp FROM emp PARTITION(p1,p3) JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE emp.dept_id IN (SELECT dept_id from dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
1	Bob	Taylor	3	2
2	Frank	Williams	1	2
3	Ellen	Johnson	3	4
4	Jim	Smith	2	4
10	Lou	Waters	2	4
11	Jill	Stone	1	4
12	Roger	White	3	2
13	Howard	Andrews	1	2
14	Fred	Goldberg	3	3
ROLLBACK;
DELETE FROM emp USING emp PARTITION(p0) JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE dept.dept_id IN (SELECT dept_id from dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
5	Mary	Jones	1	1
6	Linda	Black	2	3
7	Ed	Jones	2	1
8	June	Wilson	3	1
9	Andy	Smith	1	3
10	Lou	Waters	2	4
11	Jill	Stone	1	4
12	Roger	White	3	2
13	Howard	Andrews	1	2
14	Fred	Goldberg	3	3
15	Barbara	Brown	2	3
16	Alice	Rogers	2	2
17	Mark	Morgan	3	3
18	Karen	Cole	3	2
ROLLBACK;
DELETE QUICK emp FROM emp PARTITION(p1,p2,p3) RIGHT JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE emp.dept_id IN (SELECT dept_id from dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
1	Bob	Taylor	3	2
2	Frank	Williams	1	2
3	Ellen	Johnson	3	4
4	Jim	Smith	2	4
ROLLBACK;
DELETE LOW_PRIORITY emp FROM emp PARTITION(p3,p0) JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE emp.dept_id IN (SELECT dept_id from dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
5	Mary	Jones	1	1
6	Linda	Black	2	3
7	Ed	Jones	2	1
8	June	Wilson	3	1
9	Andy	Smith	1	3
10	Lou	Waters	2	4
11	Jill	Stone	1	4
12	Roger	White	3	2
13	Howard	Andrews	1	2
14	Fred	Goldberg	3	3
ROLLBACK;
DELETE IGNORE emp FROM emp JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE emp.dept_id IN (SELECT dept_id from dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
ROLLBACK;
DELETE emp FROM emp PARTITION(p1,p3,p0) LEFT JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE emp.dept_id IN (SELECT dept_id from dept);
SELECT * FROM dept;
dept_id	dept_name
1	admin
2	finance
3	IT
4	security
5	ref
6	services
ROLLBACK;
DELETE emp FROM emp PARTITION(p1,p3,p0,p2) INNER JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE emp.dept_id IN (SELECT dept_id from dept);
SELECT * FROM dept;
dept_id	dept_name
1	admin
2	finance
3	IT
4	security
5	ref
6	services
ROLLBACK;
# Tables are partitioned, queries uses Materialization
# Please note that some of the queries would still show Duplicate Weedout
SET optimizer_switch='loosescan=off,firstmatch=off,index_condition_pushdown=off,mrr=off,semijoin=on,materialization=on';
COMMIT;
EXPLAIN EXTENDED UPDATE emp PARTITION(p1,p3) JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500 
WHERE emp.dept_id IN (SELECT dept_id from dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	emp	ALL	dept_id	NULL	NULL	NULL	2	100.00	NULL
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index; Start temporary; End temporary
EXPLAIN EXTENDED UPDATE emp PARTITION(p1,p0) JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500 
WHERE dept.dept_id IN (SELECT dept_id from dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	emp	ALL	dept_id	NULL	NULL	NULL	2	100.00	NULL
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index; Start temporary; End temporary
EXPLAIN EXTENDED UPDATE emp PARTITION(p0,p3) RIGHT JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500 
WHERE emp.dept_id IN (SELECT dept_id from dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	emp	ALL	dept_id	NULL	NULL	NULL	2	100.00	Using where
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index; Start temporary; End temporary
EXPLAIN EXTENDED UPDATE LOW_PRIORITY emp PARTITION(p3,p2,p0) JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500 
WHERE emp.dept_id IN (SELECT dept_id from dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	emp	ALL	dept_id	NULL	NULL	NULL	3	100.00	NULL
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index; Start temporary; End temporary
EXPLAIN EXTENDED UPDATE IGNORE emp PARTITION(p3,p1,p2,p0) JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500 
WHERE emp.dept_id IN (SELECT dept_id from dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	dept	index	dept_id	dept_id	4	NULL	6	100.00	Using index; Start temporary
1	SIMPLE	emp	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	End temporary
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	Using index
EXPLAIN EXTENDED UPDATE emp LEFT JOIN dept PARTITION(p0) ON emp.dept_id = dept.dept_id 
SET dept.dept_name = 'Junk' 
WHERE dept.dept_id IN (SELECT dept_id from emp);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	dept	ALL	dept_id	NULL	NULL	NULL	2	100.00	Using where
1	SIMPLE	emp	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	Using index
1	SIMPLE	emp	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	Using index; Start temporary; End temporary
EXPLAIN EXTENDED UPDATE emp INNER JOIN dept PARTITION(p1,p0) ON emp.dept_id = dept.dept_id 
SET dept.dept_name = 'Junk' 
WHERE dept.dept_id IN (SELECT DISTINCT dept_id from emp);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	emp	index	dept_id	dept_id	4	NULL	4	100.00	Using index; Start temporary
1	SIMPLE	emp	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	End temporary
EXPLAIN EXTENDED UPDATE emp PARTITION(p0,p2), dept 
SET emp.store_id = 500 
WHERE emp.dept_id IN (SELECT dept_id FROM dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	emp	ALL	dept_id	NULL	NULL	NULL	2	100.00	NULL
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index; Start temporary; End temporary
1	SIMPLE	dept	index	NULL	dept_id	4	NULL	6	100.00	Using index; Using join buffer (Block Nested Loop)
EXPLAIN EXTENDED UPDATE emp INNER JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500, emp.lname = 'not SET', emp.fname = 'not SET' 
WHERE emp.dept_id IN (SELECT dept_id FROM dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	dept	index	dept_id	dept_id	4	NULL	6	100.00	Using index; Start temporary
1	SIMPLE	emp	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	End temporary
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	Using index
EXPLAIN EXTENDED UPDATE emp INNER JOIN dept ON emp.dept_id = dept.dept_id AND emp.fname = 'Bob' OR emp.lname = 'Cole' 
SET emp.store_id = 500, emp.lname = 'not SET', emp.fname = 'not SET' 
WHERE emp.dept_id IN (SELECT dept_id FROM dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	dept	index	dept_id	dept_id	4	NULL	6	100.00	Using index; Start temporary
1	SIMPLE	emp	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	Using where; End temporary
1	SIMPLE	dept	index	dept_id	dept_id	4	NULL	6	100.00	Using where; Using index; Using join buffer (Block Nested Loop)
EXPLAIN EXTENDED UPDATE emp PARTITION(p0,p1,p2) INNER JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500 
WHERE emp.dept_id IN (SELECT dept_id FROM dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	emp	ALL	dept_id	NULL	NULL	NULL	3	100.00	NULL
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index; Start temporary; End temporary
EXPLAIN EXTENDED UPDATE emp PARTITION(p1,p3) JOIN dept ON emp.dept_id IN (SELECT dept_id FROM dept) 
SET emp.store_id = 500;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	emp	ALL	dept_id	NULL	NULL	NULL	2	100.00	NULL
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index; Start temporary; End temporary
1	SIMPLE	dept	index	NULL	dept_id	4	NULL	6	100.00	Using index; Using join buffer (Block Nested Loop)
EXPLAIN EXTENDED DELETE emp FROM emp PARTITION(p1,p3) JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE emp.dept_id IN (SELECT dept_id from dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	emp	ALL	dept_id	NULL	NULL	NULL	2	100.00	NULL
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index; Start temporary; End temporary
EXPLAIN EXTENDED DELETE FROM emp USING emp PARTITION(p0) JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE dept.dept_id IN (SELECT dept_id from dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	emp	ALL	dept_id	NULL	NULL	NULL	2	100.00	NULL
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index; Start temporary; End temporary
EXPLAIN EXTENDED DELETE QUICK emp FROM emp PARTITION(p1,p2,p3) RIGHT JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE emp.dept_id IN (SELECT dept_id from dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	emp	ALL	dept_id	NULL	NULL	NULL	3	100.00	Using where
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index; Start temporary; End temporary
EXPLAIN EXTENDED DELETE LOW_PRIORITY emp FROM emp PARTITION(p3,p0) JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE emp.dept_id IN (SELECT dept_id from dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	emp	ALL	dept_id	NULL	NULL	NULL	2	100.00	NULL
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index; Start temporary; End temporary
EXPLAIN EXTENDED DELETE IGNORE emp FROM emp JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE emp.dept_id IN (SELECT dept_id from dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	dept	index	dept_id	dept_id	4	NULL	6	100.00	Using index; Start temporary
1	SIMPLE	emp	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	End temporary
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	Using index
EXPLAIN EXTENDED DELETE emp FROM emp PARTITION(p1,p3,p0) LEFT JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE emp.dept_id IN (SELECT dept_id from dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	emp	ALL	dept_id	NULL	NULL	NULL	3	100.00	NULL
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index; Start temporary; End temporary
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index
EXPLAIN EXTENDED DELETE emp FROM emp PARTITION(p1,p3,p0,p2) INNER JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE emp.dept_id IN (SELECT dept_id from dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	dept	index	dept_id	dept_id	4	NULL	6	100.00	Using index; Start temporary
1	SIMPLE	emp	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	End temporary
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	Using index
UPDATE emp PARTITION(p1,p3) JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500 
WHERE emp.dept_id IN (SELECT dept_id from dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
1	Bob	Taylor	3	2
2	Frank	Williams	1	2
3	Ellen	Johnson	3	4
4	Jim	Smith	2	4
5	Mary	Jones	500	1
6	Linda	Black	500	3
7	Ed	Jones	500	1
8	June	Wilson	500	1
9	Andy	Smith	500	3
10	Lou	Waters	2	4
11	Jill	Stone	1	4
12	Roger	White	3	2
13	Howard	Andrews	1	2
14	Fred	Goldberg	3	3
15	Barbara	Brown	500	3
16	Alice	Rogers	500	2
17	Mark	Morgan	500	3
18	Karen	Cole	500	2
ROLLBACK;
UPDATE emp PARTITION(p1,p0) JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500 
WHERE dept.dept_id IN (SELECT dept_id from dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
1	Bob	Taylor	500	2
2	Frank	Williams	500	2
3	Ellen	Johnson	500	4
4	Jim	Smith	500	4
5	Mary	Jones	500	1
6	Linda	Black	500	3
7	Ed	Jones	500	1
8	June	Wilson	500	1
9	Andy	Smith	500	3
10	Lou	Waters	2	4
11	Jill	Stone	1	4
12	Roger	White	3	2
13	Howard	Andrews	1	2
14	Fred	Goldberg	3	3
15	Barbara	Brown	2	3
16	Alice	Rogers	2	2
17	Mark	Morgan	3	3
18	Karen	Cole	3	2
ROLLBACK;
UPDATE emp PARTITION(p0,p3) RIGHT JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500 
WHERE emp.dept_id IN (SELECT dept_id from dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
1	Bob	Taylor	500	2
2	Frank	Williams	500	2
3	Ellen	Johnson	500	4
4	Jim	Smith	500	4
5	Mary	Jones	1	1
6	Linda	Black	2	3
7	Ed	Jones	2	1
8	June	Wilson	3	1
9	Andy	Smith	1	3
10	Lou	Waters	2	4
11	Jill	Stone	1	4
12	Roger	White	3	2
13	Howard	Andrews	1	2
14	Fred	Goldberg	3	3
15	Barbara	Brown	500	3
16	Alice	Rogers	500	2
17	Mark	Morgan	500	3
18	Karen	Cole	500	2
ROLLBACK;
UPDATE LOW_PRIORITY emp PARTITION(p3,p2,p0) JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500 
WHERE emp.dept_id IN (SELECT dept_id from dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
1	Bob	Taylor	500	2
2	Frank	Williams	500	2
3	Ellen	Johnson	500	4
4	Jim	Smith	500	4
5	Mary	Jones	1	1
6	Linda	Black	2	3
7	Ed	Jones	2	1
8	June	Wilson	3	1
9	Andy	Smith	1	3
10	Lou	Waters	500	4
11	Jill	Stone	500	4
12	Roger	White	500	2
13	Howard	Andrews	500	2
14	Fred	Goldberg	500	3
15	Barbara	Brown	500	3
16	Alice	Rogers	500	2
17	Mark	Morgan	500	3
18	Karen	Cole	500	2
ROLLBACK;
UPDATE IGNORE emp PARTITION(p3,p1,p2,p0) JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500 
WHERE emp.dept_id IN (SELECT dept_id from dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
1	Bob	Taylor	500	2
2	Frank	Williams	500	2
3	Ellen	Johnson	500	4
4	Jim	Smith	500	4
5	Mary	Jones	500	1
6	Linda	Black	500	3
7	Ed	Jones	500	1
8	June	Wilson	500	1
9	Andy	Smith	500	3
10	Lou	Waters	500	4
11	Jill	Stone	500	4
12	Roger	White	500	2
13	Howard	Andrews	500	2
14	Fred	Goldberg	500	3
15	Barbara	Brown	500	3
16	Alice	Rogers	500	2
17	Mark	Morgan	500	3
18	Karen	Cole	500	2
ROLLBACK;
UPDATE emp LEFT JOIN dept PARTITION(p0) ON emp.dept_id = dept.dept_id 
SET dept.dept_name = 'Junk' 
WHERE dept.dept_id IN (SELECT dept_id from emp);
SELECT * FROM dept;
dept_id	dept_name
1	Junk
2	Junk
3	IT
4	security
5	ref
6	services
ROLLBACK;
UPDATE emp INNER JOIN dept PARTITION(p1,p0) ON emp.dept_id = dept.dept_id 
SET dept.dept_name = 'Junk' 
WHERE dept.dept_id IN (SELECT DISTINCT dept_id from emp);
SELECT * FROM dept;
dept_id	dept_name
1	Junk
2	Junk
3	Junk
4	Junk
5	ref
6	services
ROLLBACK;
UPDATE emp PARTITION(p0,p2), dept 
SET emp.store_id = 500 
WHERE emp.dept_id IN (SELECT dept_id FROM dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
1	Bob	Taylor	500	2
2	Frank	Williams	500	2
3	Ellen	Johnson	500	4
4	Jim	Smith	500	4
5	Mary	Jones	1	1
6	Linda	Black	2	3
7	Ed	Jones	2	1
8	June	Wilson	3	1
9	Andy	Smith	1	3
10	Lou	Waters	500	4
11	Jill	Stone	500	4
12	Roger	White	500	2
13	Howard	Andrews	500	2
14	Fred	Goldberg	500	3
15	Barbara	Brown	2	3
16	Alice	Rogers	2	2
17	Mark	Morgan	3	3
18	Karen	Cole	3	2
ROLLBACK;
UPDATE emp INNER JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500, emp.lname = 'not SET', emp.fname = 'not SET' 
WHERE emp.dept_id IN (SELECT dept_id FROM dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
1	not SET	not SET	500	2
2	not SET	not SET	500	2
3	not SET	not SET	500	4
4	not SET	not SET	500	4
5	not SET	not SET	500	1
6	not SET	not SET	500	3
7	not SET	not SET	500	1
8	not SET	not SET	500	1
9	not SET	not SET	500	3
10	not SET	not SET	500	4
11	not SET	not SET	500	4
12	not SET	not SET	500	2
13	not SET	not SET	500	2
14	not SET	not SET	500	3
15	not SET	not SET	500	3
16	not SET	not SET	500	2
17	not SET	not SET	500	3
18	not SET	not SET	500	2
ROLLBACK;
UPDATE emp INNER JOIN dept ON emp.dept_id = dept.dept_id AND emp.fname = 'Bob' OR emp.lname = 'Cole' 
SET emp.store_id = 500, emp.lname = 'not SET', emp.fname = 'not SET' 
WHERE emp.dept_id IN (SELECT dept_id FROM dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
1	not SET	not SET	500	2
2	Frank	Williams	1	2
3	Ellen	Johnson	3	4
4	Jim	Smith	2	4
5	Mary	Jones	1	1
6	Linda	Black	2	3
7	Ed	Jones	2	1
8	June	Wilson	3	1
9	Andy	Smith	1	3
10	Lou	Waters	2	4
11	Jill	Stone	1	4
12	Roger	White	3	2
13	Howard	Andrews	1	2
14	Fred	Goldberg	3	3
15	Barbara	Brown	2	3
16	Alice	Rogers	2	2
17	Mark	Morgan	3	3
18	not SET	not SET	500	2
ROLLBACK;
UPDATE emp PARTITION(p0,p1,p2) INNER JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500 
WHERE emp.dept_id IN (SELECT dept_id FROM dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
1	Bob	Taylor	500	2
2	Frank	Williams	500	2
3	Ellen	Johnson	500	4
4	Jim	Smith	500	4
5	Mary	Jones	500	1
6	Linda	Black	500	3
7	Ed	Jones	500	1
8	June	Wilson	500	1
9	Andy	Smith	500	3
10	Lou	Waters	500	4
11	Jill	Stone	500	4
12	Roger	White	500	2
13	Howard	Andrews	500	2
14	Fred	Goldberg	500	3
15	Barbara	Brown	2	3
16	Alice	Rogers	2	2
17	Mark	Morgan	3	3
18	Karen	Cole	3	2
ROLLBACK;
UPDATE emp PARTITION(p1,p3) JOIN dept ON emp.dept_id IN (SELECT dept_id FROM dept) 
SET emp.store_id = 500;
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
1	Bob	Taylor	3	2
2	Frank	Williams	1	2
3	Ellen	Johnson	3	4
4	Jim	Smith	2	4
5	Mary	Jones	500	1
6	Linda	Black	500	3
7	Ed	Jones	500	1
8	June	Wilson	500	1
9	Andy	Smith	500	3
10	Lou	Waters	2	4
11	Jill	Stone	1	4
12	Roger	White	3	2
13	Howard	Andrews	1	2
14	Fred	Goldberg	3	3
15	Barbara	Brown	500	3
16	Alice	Rogers	500	2
17	Mark	Morgan	500	3
18	Karen	Cole	500	2
ROLLBACK;
DELETE emp FROM emp PARTITION(p1,p3) JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE emp.dept_id IN (SELECT dept_id from dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
1	Bob	Taylor	3	2
2	Frank	Williams	1	2
3	Ellen	Johnson	3	4
4	Jim	Smith	2	4
10	Lou	Waters	2	4
11	Jill	Stone	1	4
12	Roger	White	3	2
13	Howard	Andrews	1	2
14	Fred	Goldberg	3	3
ROLLBACK;
DELETE FROM emp USING emp PARTITION(p0) JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE dept.dept_id IN (SELECT dept_id from dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
5	Mary	Jones	1	1
6	Linda	Black	2	3
7	Ed	Jones	2	1
8	June	Wilson	3	1
9	Andy	Smith	1	3
10	Lou	Waters	2	4
11	Jill	Stone	1	4
12	Roger	White	3	2
13	Howard	Andrews	1	2
14	Fred	Goldberg	3	3
15	Barbara	Brown	2	3
16	Alice	Rogers	2	2
17	Mark	Morgan	3	3
18	Karen	Cole	3	2
ROLLBACK;
DELETE QUICK emp FROM emp PARTITION(p1,p2,p3) RIGHT JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE emp.dept_id IN (SELECT dept_id from dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
1	Bob	Taylor	3	2
2	Frank	Williams	1	2
3	Ellen	Johnson	3	4
4	Jim	Smith	2	4
ROLLBACK;
DELETE LOW_PRIORITY emp FROM emp PARTITION(p3,p0) JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE emp.dept_id IN (SELECT dept_id from dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
5	Mary	Jones	1	1
6	Linda	Black	2	3
7	Ed	Jones	2	1
8	June	Wilson	3	1
9	Andy	Smith	1	3
10	Lou	Waters	2	4
11	Jill	Stone	1	4
12	Roger	White	3	2
13	Howard	Andrews	1	2
14	Fred	Goldberg	3	3
ROLLBACK;
DELETE IGNORE emp FROM emp JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE emp.dept_id IN (SELECT dept_id from dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
ROLLBACK;
DELETE emp FROM emp PARTITION(p1,p3,p0) LEFT JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE emp.dept_id IN (SELECT dept_id from dept);
SELECT * FROM dept;
dept_id	dept_name
1	admin
2	finance
3	IT
4	security
5	ref
6	services
ROLLBACK;
DELETE emp FROM emp PARTITION(p1,p3,p0,p2) INNER JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE emp.dept_id IN (SELECT dept_id from dept);
SELECT * FROM dept;
dept_id	dept_name
1	admin
2	finance
3	IT
4	security
5	ref
6	services
ROLLBACK;
# Tables are partitioned, queries uses Duplicate Weedout strategy
SET optimizer_switch='loosescan=off,firstmatch=off,index_condition_pushdown=off,mrr=off,semijoin=on,materialization=off';
COMMIT;
EXPLAIN EXTENDED UPDATE emp PARTITION(p1,p3) JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500 
WHERE emp.dept_id IN (SELECT dept_id from dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	emp	ALL	dept_id	NULL	NULL	NULL	2	100.00	NULL
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index; Start temporary; End temporary
EXPLAIN EXTENDED UPDATE emp PARTITION(p1,p0) JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500 
WHERE dept.dept_id IN (SELECT dept_id from dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	emp	ALL	dept_id	NULL	NULL	NULL	2	100.00	NULL
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index; Start temporary; End temporary
EXPLAIN EXTENDED UPDATE emp PARTITION(p0,p3) RIGHT JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500 
WHERE emp.dept_id IN (SELECT dept_id from dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	emp	ALL	dept_id	NULL	NULL	NULL	2	100.00	Using where
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index; Start temporary; End temporary
EXPLAIN EXTENDED UPDATE LOW_PRIORITY emp PARTITION(p3,p2,p0) JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500 
WHERE emp.dept_id IN (SELECT dept_id from dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	emp	ALL	dept_id	NULL	NULL	NULL	3	100.00	NULL
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index; Start temporary; End temporary
EXPLAIN EXTENDED UPDATE IGNORE emp PARTITION(p3,p1,p2,p0) JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500 
WHERE emp.dept_id IN (SELECT dept_id from dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	dept	index	dept_id	dept_id	4	NULL	6	100.00	Using index; Start temporary
1	SIMPLE	emp	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	End temporary
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	Using index
EXPLAIN EXTENDED UPDATE emp LEFT JOIN dept PARTITION(p0) ON emp.dept_id = dept.dept_id 
SET dept.dept_name = 'Junk' 
WHERE dept.dept_id IN (SELECT dept_id from emp);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	dept	ALL	dept_id	NULL	NULL	NULL	2	100.00	Using where
1	SIMPLE	emp	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	Using index
1	SIMPLE	emp	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	Using index; Start temporary; End temporary
EXPLAIN EXTENDED UPDATE emp INNER JOIN dept PARTITION(p1,p0) ON emp.dept_id = dept.dept_id 
SET dept.dept_name = 'Junk' 
WHERE dept.dept_id IN (SELECT DISTINCT dept_id from emp);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	emp	index	dept_id	dept_id	4	NULL	4	100.00	Using index; Start temporary
1	SIMPLE	emp	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	End temporary
EXPLAIN EXTENDED UPDATE emp PARTITION(p0,p2), dept 
SET emp.store_id = 500 
WHERE emp.dept_id IN (SELECT dept_id FROM dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	emp	ALL	dept_id	NULL	NULL	NULL	2	100.00	NULL
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index; Start temporary; End temporary
1	SIMPLE	dept	index	NULL	dept_id	4	NULL	6	100.00	Using index; Using join buffer (Block Nested Loop)
EXPLAIN EXTENDED UPDATE emp INNER JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500, emp.lname = 'not SET', emp.fname = 'not SET' 
WHERE emp.dept_id IN (SELECT dept_id FROM dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	dept	index	dept_id	dept_id	4	NULL	6	100.00	Using index; Start temporary
1	SIMPLE	emp	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	End temporary
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	Using index
EXPLAIN EXTENDED UPDATE emp INNER JOIN dept ON emp.dept_id = dept.dept_id AND emp.fname = 'Bob' OR emp.lname = 'Cole' 
SET emp.store_id = 500, emp.lname = 'not SET', emp.fname = 'not SET' 
WHERE emp.dept_id IN (SELECT dept_id FROM dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	dept	index	dept_id	dept_id	4	NULL	6	100.00	Using index; Start temporary
1	SIMPLE	emp	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	Using where; End temporary
1	SIMPLE	dept	index	dept_id	dept_id	4	NULL	6	100.00	Using where; Using index; Using join buffer (Block Nested Loop)
EXPLAIN EXTENDED UPDATE emp PARTITION(p0,p1,p2) INNER JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500 
WHERE emp.dept_id IN (SELECT dept_id FROM dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	emp	ALL	dept_id	NULL	NULL	NULL	3	100.00	NULL
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index; Start temporary; End temporary
EXPLAIN EXTENDED UPDATE emp PARTITION(p1,p3) JOIN dept ON emp.dept_id IN (SELECT dept_id FROM dept) 
SET emp.store_id = 500;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	emp	ALL	dept_id	NULL	NULL	NULL	2	100.00	NULL
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index; Start temporary; End temporary
1	SIMPLE	dept	index	NULL	dept_id	4	NULL	6	100.00	Using index; Using join buffer (Block Nested Loop)
EXPLAIN EXTENDED DELETE emp FROM emp PARTITION(p1,p3) JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE emp.dept_id IN (SELECT dept_id from dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	emp	ALL	dept_id	NULL	NULL	NULL	2	100.00	NULL
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index; Start temporary; End temporary
EXPLAIN EXTENDED DELETE FROM emp USING emp PARTITION(p0) JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE dept.dept_id IN (SELECT dept_id from dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	emp	ALL	dept_id	NULL	NULL	NULL	2	100.00	NULL
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index; Start temporary; End temporary
EXPLAIN EXTENDED DELETE QUICK emp FROM emp PARTITION(p1,p2,p3) RIGHT JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE emp.dept_id IN (SELECT dept_id from dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	emp	ALL	dept_id	NULL	NULL	NULL	3	100.00	Using where
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index; Start temporary; End temporary
EXPLAIN EXTENDED DELETE LOW_PRIORITY emp FROM emp PARTITION(p3,p0) JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE emp.dept_id IN (SELECT dept_id from dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	emp	ALL	dept_id	NULL	NULL	NULL	2	100.00	NULL
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index; Start temporary; End temporary
EXPLAIN EXTENDED DELETE IGNORE emp FROM emp JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE emp.dept_id IN (SELECT dept_id from dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	dept	index	dept_id	dept_id	4	NULL	6	100.00	Using index; Start temporary
1	SIMPLE	emp	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	End temporary
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	Using index
EXPLAIN EXTENDED DELETE emp FROM emp PARTITION(p1,p3,p0) LEFT JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE emp.dept_id IN (SELECT dept_id from dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	emp	ALL	dept_id	NULL	NULL	NULL	3	100.00	NULL
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index; Start temporary; End temporary
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index
EXPLAIN EXTENDED DELETE emp FROM emp PARTITION(p1,p3,p0,p2) INNER JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE emp.dept_id IN (SELECT dept_id from dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	dept	index	dept_id	dept_id	4	NULL	6	100.00	Using index; Start temporary
1	SIMPLE	emp	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	End temporary
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	Using index
UPDATE emp PARTITION(p1,p3) JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500 
WHERE emp.dept_id IN (SELECT dept_id from dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
1	Bob	Taylor	3	2
2	Frank	Williams	1	2
3	Ellen	Johnson	3	4
4	Jim	Smith	2	4
5	Mary	Jones	500	1
6	Linda	Black	500	3
7	Ed	Jones	500	1
8	June	Wilson	500	1
9	Andy	Smith	500	3
10	Lou	Waters	2	4
11	Jill	Stone	1	4
12	Roger	White	3	2
13	Howard	Andrews	1	2
14	Fred	Goldberg	3	3
15	Barbara	Brown	500	3
16	Alice	Rogers	500	2
17	Mark	Morgan	500	3
18	Karen	Cole	500	2
ROLLBACK;
UPDATE emp PARTITION(p1,p0) JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500 
WHERE dept.dept_id IN (SELECT dept_id from dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
1	Bob	Taylor	500	2
2	Frank	Williams	500	2
3	Ellen	Johnson	500	4
4	Jim	Smith	500	4
5	Mary	Jones	500	1
6	Linda	Black	500	3
7	Ed	Jones	500	1
8	June	Wilson	500	1
9	Andy	Smith	500	3
10	Lou	Waters	2	4
11	Jill	Stone	1	4
12	Roger	White	3	2
13	Howard	Andrews	1	2
14	Fred	Goldberg	3	3
15	Barbara	Brown	2	3
16	Alice	Rogers	2	2
17	Mark	Morgan	3	3
18	Karen	Cole	3	2
ROLLBACK;
UPDATE emp PARTITION(p0,p3) RIGHT JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500 
WHERE emp.dept_id IN (SELECT dept_id from dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
1	Bob	Taylor	500	2
2	Frank	Williams	500	2
3	Ellen	Johnson	500	4
4	Jim	Smith	500	4
5	Mary	Jones	1	1
6	Linda	Black	2	3
7	Ed	Jones	2	1
8	June	Wilson	3	1
9	Andy	Smith	1	3
10	Lou	Waters	2	4
11	Jill	Stone	1	4
12	Roger	White	3	2
13	Howard	Andrews	1	2
14	Fred	Goldberg	3	3
15	Barbara	Brown	500	3
16	Alice	Rogers	500	2
17	Mark	Morgan	500	3
18	Karen	Cole	500	2
ROLLBACK;
UPDATE LOW_PRIORITY emp PARTITION(p3,p2,p0) JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500 
WHERE emp.dept_id IN (SELECT dept_id from dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
1	Bob	Taylor	500	2
2	Frank	Williams	500	2
3	Ellen	Johnson	500	4
4	Jim	Smith	500	4
5	Mary	Jones	1	1
6	Linda	Black	2	3
7	Ed	Jones	2	1
8	June	Wilson	3	1
9	Andy	Smith	1	3
10	Lou	Waters	500	4
11	Jill	Stone	500	4
12	Roger	White	500	2
13	Howard	Andrews	500	2
14	Fred	Goldberg	500	3
15	Barbara	Brown	500	3
16	Alice	Rogers	500	2
17	Mark	Morgan	500	3
18	Karen	Cole	500	2
ROLLBACK;
UPDATE IGNORE emp PARTITION(p3,p1,p2,p0) JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500 
WHERE emp.dept_id IN (SELECT dept_id from dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
1	Bob	Taylor	500	2
2	Frank	Williams	500	2
3	Ellen	Johnson	500	4
4	Jim	Smith	500	4
5	Mary	Jones	500	1
6	Linda	Black	500	3
7	Ed	Jones	500	1
8	June	Wilson	500	1
9	Andy	Smith	500	3
10	Lou	Waters	500	4
11	Jill	Stone	500	4
12	Roger	White	500	2
13	Howard	Andrews	500	2
14	Fred	Goldberg	500	3
15	Barbara	Brown	500	3
16	Alice	Rogers	500	2
17	Mark	Morgan	500	3
18	Karen	Cole	500	2
ROLLBACK;
UPDATE emp LEFT JOIN dept PARTITION(p0) ON emp.dept_id = dept.dept_id 
SET dept.dept_name = 'Junk' 
WHERE dept.dept_id IN (SELECT dept_id from emp);
SELECT * FROM dept;
dept_id	dept_name
1	Junk
2	Junk
3	IT
4	security
5	ref
6	services
ROLLBACK;
UPDATE emp INNER JOIN dept PARTITION(p1,p0) ON emp.dept_id = dept.dept_id 
SET dept.dept_name = 'Junk' 
WHERE dept.dept_id IN (SELECT DISTINCT dept_id from emp);
SELECT * FROM dept;
dept_id	dept_name
1	Junk
2	Junk
3	Junk
4	Junk
5	ref
6	services
ROLLBACK;
UPDATE emp PARTITION(p0,p2), dept 
SET emp.store_id = 500 
WHERE emp.dept_id IN (SELECT dept_id FROM dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
1	Bob	Taylor	500	2
2	Frank	Williams	500	2
3	Ellen	Johnson	500	4
4	Jim	Smith	500	4
5	Mary	Jones	1	1
6	Linda	Black	2	3
7	Ed	Jones	2	1
8	June	Wilson	3	1
9	Andy	Smith	1	3
10	Lou	Waters	500	4
11	Jill	Stone	500	4
12	Roger	White	500	2
13	Howard	Andrews	500	2
14	Fred	Goldberg	500	3
15	Barbara	Brown	2	3
16	Alice	Rogers	2	2
17	Mark	Morgan	3	3
18	Karen	Cole	3	2
ROLLBACK;
UPDATE emp INNER JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500, emp.lname = 'not SET', emp.fname = 'not SET' 
WHERE emp.dept_id IN (SELECT dept_id FROM dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
1	not SET	not SET	500	2
2	not SET	not SET	500	2
3	not SET	not SET	500	4
4	not SET	not SET	500	4
5	not SET	not SET	500	1
6	not SET	not SET	500	3
7	not SET	not SET	500	1
8	not SET	not SET	500	1
9	not SET	not SET	500	3
10	not SET	not SET	500	4
11	not SET	not SET	500	4
12	not SET	not SET	500	2
13	not SET	not SET	500	2
14	not SET	not SET	500	3
15	not SET	not SET	500	3
16	not SET	not SET	500	2
17	not SET	not SET	500	3
18	not SET	not SET	500	2
ROLLBACK;
UPDATE emp INNER JOIN dept ON emp.dept_id = dept.dept_id AND emp.fname = 'Bob' OR emp.lname = 'Cole' 
SET emp.store_id = 500, emp.lname = 'not SET', emp.fname = 'not SET' 
WHERE emp.dept_id IN (SELECT dept_id FROM dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
1	not SET	not SET	500	2
2	Frank	Williams	1	2
3	Ellen	Johnson	3	4
4	Jim	Smith	2	4
5	Mary	Jones	1	1
6	Linda	Black	2	3
7	Ed	Jones	2	1
8	June	Wilson	3	1
9	Andy	Smith	1	3
10	Lou	Waters	2	4
11	Jill	Stone	1	4
12	Roger	White	3	2
13	Howard	Andrews	1	2
14	Fred	Goldberg	3	3
15	Barbara	Brown	2	3
16	Alice	Rogers	2	2
17	Mark	Morgan	3	3
18	not SET	not SET	500	2
ROLLBACK;
UPDATE emp PARTITION(p0,p1,p2) INNER JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500 
WHERE emp.dept_id IN (SELECT dept_id FROM dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
1	Bob	Taylor	500	2
2	Frank	Williams	500	2
3	Ellen	Johnson	500	4
4	Jim	Smith	500	4
5	Mary	Jones	500	1
6	Linda	Black	500	3
7	Ed	Jones	500	1
8	June	Wilson	500	1
9	Andy	Smith	500	3
10	Lou	Waters	500	4
11	Jill	Stone	500	4
12	Roger	White	500	2
13	Howard	Andrews	500	2
14	Fred	Goldberg	500	3
15	Barbara	Brown	2	3
16	Alice	Rogers	2	2
17	Mark	Morgan	3	3
18	Karen	Cole	3	2
ROLLBACK;
UPDATE emp PARTITION(p1,p3) JOIN dept ON emp.dept_id IN (SELECT dept_id FROM dept) 
SET emp.store_id = 500;
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
1	Bob	Taylor	3	2
2	Frank	Williams	1	2
3	Ellen	Johnson	3	4
4	Jim	Smith	2	4
5	Mary	Jones	500	1
6	Linda	Black	500	3
7	Ed	Jones	500	1
8	June	Wilson	500	1
9	Andy	Smith	500	3
10	Lou	Waters	2	4
11	Jill	Stone	1	4
12	Roger	White	3	2
13	Howard	Andrews	1	2
14	Fred	Goldberg	3	3
15	Barbara	Brown	500	3
16	Alice	Rogers	500	2
17	Mark	Morgan	500	3
18	Karen	Cole	500	2
ROLLBACK;
DELETE emp FROM emp PARTITION(p1,p3) JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE emp.dept_id IN (SELECT dept_id from dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
1	Bob	Taylor	3	2
2	Frank	Williams	1	2
3	Ellen	Johnson	3	4
4	Jim	Smith	2	4
10	Lou	Waters	2	4
11	Jill	Stone	1	4
12	Roger	White	3	2
13	Howard	Andrews	1	2
14	Fred	Goldberg	3	3
ROLLBACK;
DELETE FROM emp USING emp PARTITION(p0) JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE dept.dept_id IN (SELECT dept_id from dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
5	Mary	Jones	1	1
6	Linda	Black	2	3
7	Ed	Jones	2	1
8	June	Wilson	3	1
9	Andy	Smith	1	3
10	Lou	Waters	2	4
11	Jill	Stone	1	4
12	Roger	White	3	2
13	Howard	Andrews	1	2
14	Fred	Goldberg	3	3
15	Barbara	Brown	2	3
16	Alice	Rogers	2	2
17	Mark	Morgan	3	3
18	Karen	Cole	3	2
ROLLBACK;
DELETE QUICK emp FROM emp PARTITION(p1,p2,p3) RIGHT JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE emp.dept_id IN (SELECT dept_id from dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
1	Bob	Taylor	3	2
2	Frank	Williams	1	2
3	Ellen	Johnson	3	4
4	Jim	Smith	2	4
ROLLBACK;
DELETE LOW_PRIORITY emp FROM emp PARTITION(p3,p0) JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE emp.dept_id IN (SELECT dept_id from dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
5	Mary	Jones	1	1
6	Linda	Black	2	3
7	Ed	Jones	2	1
8	June	Wilson	3	1
9	Andy	Smith	1	3
10	Lou	Waters	2	4
11	Jill	Stone	1	4
12	Roger	White	3	2
13	Howard	Andrews	1	2
14	Fred	Goldberg	3	3
ROLLBACK;
DELETE IGNORE emp FROM emp JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE emp.dept_id IN (SELECT dept_id from dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
ROLLBACK;
DELETE emp FROM emp PARTITION(p1,p3,p0) LEFT JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE emp.dept_id IN (SELECT dept_id from dept);
SELECT * FROM dept;
dept_id	dept_name
1	admin
2	finance
3	IT
4	security
5	ref
6	services
ROLLBACK;
DELETE emp FROM emp PARTITION(p1,p3,p0,p2) INNER JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE emp.dept_id IN (SELECT dept_id from dept);
SELECT * FROM dept;
dept_id	dept_name
1	admin
2	finance
3	IT
4	security
5	ref
6	services
ROLLBACK;
# Tables are partitioned, queries uses Loosescan strategy
# Please note that some of the queries would still show Duplicate Weedout
SET optimizer_switch='loosescan=on,firstmatch=off,index_condition_pushdown=off,mrr=off,semijoin=on,materialization=off';
COMMIT;
EXPLAIN EXTENDED UPDATE emp PARTITION(p1,p3) JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500 
WHERE emp.dept_id IN (SELECT dept_id from dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	dept	index	dept_id	dept_id	4	NULL	6	100.00	Using index; LooseScan
1	SIMPLE	emp	ALL	dept_id	NULL	NULL	NULL	2	100.00	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	Using index
EXPLAIN EXTENDED UPDATE emp PARTITION(p1,p0) JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500 
WHERE dept.dept_id IN (SELECT dept_id from dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	emp	ALL	dept_id	NULL	NULL	NULL	2	100.00	NULL
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index; Start temporary; End temporary
EXPLAIN EXTENDED UPDATE emp PARTITION(p0,p3) RIGHT JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500 
WHERE emp.dept_id IN (SELECT dept_id from dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	dept	index	dept_id	dept_id	4	NULL	6	100.00	Using where; Using index; LooseScan
1	SIMPLE	emp	ALL	dept_id	NULL	NULL	NULL	2	100.00	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	Using index
EXPLAIN EXTENDED UPDATE LOW_PRIORITY emp PARTITION(p3,p2,p0) JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500 
WHERE emp.dept_id IN (SELECT dept_id from dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	dept	index	dept_id	dept_id	4	NULL	6	100.00	Using index; LooseScan
1	SIMPLE	emp	ALL	dept_id	NULL	NULL	NULL	3	100.00	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	Using index
EXPLAIN EXTENDED UPDATE IGNORE emp PARTITION(p3,p1,p2,p0) JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500 
WHERE emp.dept_id IN (SELECT dept_id from dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	dept	index	dept_id	dept_id	4	NULL	6	100.00	Using index; LooseScan
1	SIMPLE	emp	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	NULL
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	Using index
EXPLAIN EXTENDED UPDATE emp LEFT JOIN dept PARTITION(p0) ON emp.dept_id = dept.dept_id 
SET dept.dept_name = 'Junk' 
WHERE dept.dept_id IN (SELECT dept_id from emp);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	emp	index	dept_id	dept_id	4	NULL	4	100.00	Using where; Using index; LooseScan
1	SIMPLE	dept	ALL	dept_id	NULL	NULL	NULL	2	100.00	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	emp	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index
EXPLAIN EXTENDED UPDATE emp INNER JOIN dept PARTITION(p1,p0) ON emp.dept_id = dept.dept_id 
SET dept.dept_name = 'Junk' 
WHERE dept.dept_id IN (SELECT DISTINCT dept_id from emp);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	emp	index	dept_id	dept_id	4	NULL	4	100.00	Using index; LooseScan
1	SIMPLE	emp	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	NULL
EXPLAIN EXTENDED UPDATE emp PARTITION(p0,p2), dept 
SET emp.store_id = 500 
WHERE emp.dept_id IN (SELECT dept_id FROM dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	emp	ALL	dept_id	NULL	NULL	NULL	2	100.00	NULL
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index; Start temporary; End temporary
1	SIMPLE	dept	index	NULL	dept_id	4	NULL	6	100.00	Using index; Using join buffer (Block Nested Loop)
EXPLAIN EXTENDED UPDATE emp INNER JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500, emp.lname = 'not SET', emp.fname = 'not SET' 
WHERE emp.dept_id IN (SELECT dept_id FROM dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	dept	index	dept_id	dept_id	4	NULL	6	100.00	Using index; LooseScan
1	SIMPLE	emp	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	NULL
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	Using index
EXPLAIN EXTENDED UPDATE emp INNER JOIN dept ON emp.dept_id = dept.dept_id AND emp.fname = 'Bob' OR emp.lname = 'Cole' 
SET emp.store_id = 500, emp.lname = 'not SET', emp.fname = 'not SET' 
WHERE emp.dept_id IN (SELECT dept_id FROM dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	dept	index	dept_id	dept_id	4	NULL	6	100.00	Using index; LooseScan
1	SIMPLE	emp	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	Using where
1	SIMPLE	dept	index	dept_id	dept_id	4	NULL	6	100.00	Using where; Using index; Using join buffer (Block Nested Loop)
EXPLAIN EXTENDED UPDATE emp PARTITION(p0,p1,p2) INNER JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500 
WHERE emp.dept_id IN (SELECT dept_id FROM dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	dept	index	dept_id	dept_id	4	NULL	6	100.00	Using index; LooseScan
1	SIMPLE	emp	ALL	dept_id	NULL	NULL	NULL	3	100.00	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	Using index
EXPLAIN EXTENDED UPDATE emp PARTITION(p1,p3) JOIN dept ON emp.dept_id IN (SELECT dept_id FROM dept) 
SET emp.store_id = 500;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	emp	ALL	dept_id	NULL	NULL	NULL	2	100.00	NULL
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index; Start temporary; End temporary
1	SIMPLE	dept	index	NULL	dept_id	4	NULL	6	100.00	Using index; Using join buffer (Block Nested Loop)
EXPLAIN EXTENDED DELETE emp FROM emp PARTITION(p1,p3) JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE emp.dept_id IN (SELECT dept_id from dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	emp	ALL	dept_id	NULL	NULL	NULL	2	100.00	NULL
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index; Start temporary; End temporary
EXPLAIN EXTENDED DELETE FROM emp USING emp PARTITION(p0) JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE dept.dept_id IN (SELECT dept_id from dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	emp	ALL	dept_id	NULL	NULL	NULL	2	100.00	NULL
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index; Start temporary; End temporary
EXPLAIN EXTENDED DELETE QUICK emp FROM emp PARTITION(p1,p2,p3) RIGHT JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE emp.dept_id IN (SELECT dept_id from dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	dept	index	dept_id	dept_id	4	NULL	6	100.00	Using where; Using index; LooseScan
1	SIMPLE	emp	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	NULL
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	Using index
EXPLAIN EXTENDED DELETE LOW_PRIORITY emp FROM emp PARTITION(p3,p0) JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE emp.dept_id IN (SELECT dept_id from dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	emp	ALL	dept_id	NULL	NULL	NULL	2	100.00	NULL
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index; Start temporary; End temporary
EXPLAIN EXTENDED DELETE IGNORE emp FROM emp JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE emp.dept_id IN (SELECT dept_id from dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	dept	index	dept_id	dept_id	4	NULL	6	100.00	Using index; LooseScan
1	SIMPLE	emp	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	NULL
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	Using index
EXPLAIN EXTENDED DELETE emp FROM emp PARTITION(p1,p3,p0) LEFT JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE emp.dept_id IN (SELECT dept_id from dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	dept	index	dept_id	dept_id	4	NULL	6	100.00	Using index; LooseScan
1	SIMPLE	emp	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	NULL
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	Using index
EXPLAIN EXTENDED DELETE emp FROM emp PARTITION(p1,p3,p0,p2) INNER JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE emp.dept_id IN (SELECT dept_id from dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	dept	index	dept_id	dept_id	4	NULL	6	100.00	Using index; LooseScan
1	SIMPLE	emp	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	NULL
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	Using index
UPDATE emp PARTITION(p1,p3) JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500 
WHERE emp.dept_id IN (SELECT dept_id from dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
1	Bob	Taylor	3	2
2	Frank	Williams	1	2
3	Ellen	Johnson	3	4
4	Jim	Smith	2	4
5	Mary	Jones	500	1
6	Linda	Black	500	3
7	Ed	Jones	500	1
8	June	Wilson	500	1
9	Andy	Smith	500	3
10	Lou	Waters	2	4
11	Jill	Stone	1	4
12	Roger	White	3	2
13	Howard	Andrews	1	2
14	Fred	Goldberg	3	3
15	Barbara	Brown	500	3
16	Alice	Rogers	500	2
17	Mark	Morgan	500	3
18	Karen	Cole	500	2
ROLLBACK;
UPDATE emp PARTITION(p1,p0) JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500 
WHERE dept.dept_id IN (SELECT dept_id from dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
1	Bob	Taylor	500	2
2	Frank	Williams	500	2
3	Ellen	Johnson	500	4
4	Jim	Smith	500	4
5	Mary	Jones	500	1
6	Linda	Black	500	3
7	Ed	Jones	500	1
8	June	Wilson	500	1
9	Andy	Smith	500	3
10	Lou	Waters	2	4
11	Jill	Stone	1	4
12	Roger	White	3	2
13	Howard	Andrews	1	2
14	Fred	Goldberg	3	3
15	Barbara	Brown	2	3
16	Alice	Rogers	2	2
17	Mark	Morgan	3	3
18	Karen	Cole	3	2
ROLLBACK;
UPDATE emp PARTITION(p0,p3) RIGHT JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500 
WHERE emp.dept_id IN (SELECT dept_id from dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
1	Bob	Taylor	500	2
2	Frank	Williams	500	2
3	Ellen	Johnson	500	4
4	Jim	Smith	500	4
5	Mary	Jones	1	1
6	Linda	Black	2	3
7	Ed	Jones	2	1
8	June	Wilson	3	1
9	Andy	Smith	1	3
10	Lou	Waters	2	4
11	Jill	Stone	1	4
12	Roger	White	3	2
13	Howard	Andrews	1	2
14	Fred	Goldberg	3	3
15	Barbara	Brown	500	3
16	Alice	Rogers	500	2
17	Mark	Morgan	500	3
18	Karen	Cole	500	2
ROLLBACK;
UPDATE LOW_PRIORITY emp PARTITION(p3,p2,p0) JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500 
WHERE emp.dept_id IN (SELECT dept_id from dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
1	Bob	Taylor	500	2
2	Frank	Williams	500	2
3	Ellen	Johnson	500	4
4	Jim	Smith	500	4
5	Mary	Jones	1	1
6	Linda	Black	2	3
7	Ed	Jones	2	1
8	June	Wilson	3	1
9	Andy	Smith	1	3
10	Lou	Waters	500	4
11	Jill	Stone	500	4
12	Roger	White	500	2
13	Howard	Andrews	500	2
14	Fred	Goldberg	500	3
15	Barbara	Brown	500	3
16	Alice	Rogers	500	2
17	Mark	Morgan	500	3
18	Karen	Cole	500	2
ROLLBACK;
UPDATE IGNORE emp PARTITION(p3,p1,p2,p0) JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500 
WHERE emp.dept_id IN (SELECT dept_id from dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
1	Bob	Taylor	500	2
2	Frank	Williams	500	2
3	Ellen	Johnson	500	4
4	Jim	Smith	500	4
5	Mary	Jones	500	1
6	Linda	Black	500	3
7	Ed	Jones	500	1
8	June	Wilson	500	1
9	Andy	Smith	500	3
10	Lou	Waters	500	4
11	Jill	Stone	500	4
12	Roger	White	500	2
13	Howard	Andrews	500	2
14	Fred	Goldberg	500	3
15	Barbara	Brown	500	3
16	Alice	Rogers	500	2
17	Mark	Morgan	500	3
18	Karen	Cole	500	2
ROLLBACK;
UPDATE emp LEFT JOIN dept PARTITION(p0) ON emp.dept_id = dept.dept_id 
SET dept.dept_name = 'Junk' 
WHERE dept.dept_id IN (SELECT dept_id from emp);
SELECT * FROM dept;
dept_id	dept_name
1	Junk
2	Junk
3	IT
4	security
5	ref
6	services
ROLLBACK;
UPDATE emp INNER JOIN dept PARTITION(p1,p0) ON emp.dept_id = dept.dept_id 
SET dept.dept_name = 'Junk' 
WHERE dept.dept_id IN (SELECT DISTINCT dept_id from emp);
SELECT * FROM dept;
dept_id	dept_name
1	Junk
2	Junk
3	Junk
4	Junk
5	ref
6	services
ROLLBACK;
UPDATE emp PARTITION(p0,p2), dept 
SET emp.store_id = 500 
WHERE emp.dept_id IN (SELECT dept_id FROM dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
1	Bob	Taylor	500	2
2	Frank	Williams	500	2
3	Ellen	Johnson	500	4
4	Jim	Smith	500	4
5	Mary	Jones	1	1
6	Linda	Black	2	3
7	Ed	Jones	2	1
8	June	Wilson	3	1
9	Andy	Smith	1	3
10	Lou	Waters	500	4
11	Jill	Stone	500	4
12	Roger	White	500	2
13	Howard	Andrews	500	2
14	Fred	Goldberg	500	3
15	Barbara	Brown	2	3
16	Alice	Rogers	2	2
17	Mark	Morgan	3	3
18	Karen	Cole	3	2
ROLLBACK;
UPDATE emp INNER JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500, emp.lname = 'not SET', emp.fname = 'not SET' 
WHERE emp.dept_id IN (SELECT dept_id FROM dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
1	not SET	not SET	500	2
2	not SET	not SET	500	2
3	not SET	not SET	500	4
4	not SET	not SET	500	4
5	not SET	not SET	500	1
6	not SET	not SET	500	3
7	not SET	not SET	500	1
8	not SET	not SET	500	1
9	not SET	not SET	500	3
10	not SET	not SET	500	4
11	not SET	not SET	500	4
12	not SET	not SET	500	2
13	not SET	not SET	500	2
14	not SET	not SET	500	3
15	not SET	not SET	500	3
16	not SET	not SET	500	2
17	not SET	not SET	500	3
18	not SET	not SET	500	2
ROLLBACK;
UPDATE emp INNER JOIN dept ON emp.dept_id = dept.dept_id AND emp.fname = 'Bob' OR emp.lname = 'Cole' 
SET emp.store_id = 500, emp.lname = 'not SET', emp.fname = 'not SET' 
WHERE emp.dept_id IN (SELECT dept_id FROM dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
1	not SET	not SET	500	2
2	Frank	Williams	1	2
3	Ellen	Johnson	3	4
4	Jim	Smith	2	4
5	Mary	Jones	1	1
6	Linda	Black	2	3
7	Ed	Jones	2	1
8	June	Wilson	3	1
9	Andy	Smith	1	3
10	Lou	Waters	2	4
11	Jill	Stone	1	4
12	Roger	White	3	2
13	Howard	Andrews	1	2
14	Fred	Goldberg	3	3
15	Barbara	Brown	2	3
16	Alice	Rogers	2	2
17	Mark	Morgan	3	3
18	not SET	not SET	500	2
ROLLBACK;
UPDATE emp PARTITION(p0,p1,p2) INNER JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500 
WHERE emp.dept_id IN (SELECT dept_id FROM dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
1	Bob	Taylor	500	2
2	Frank	Williams	500	2
3	Ellen	Johnson	500	4
4	Jim	Smith	500	4
5	Mary	Jones	500	1
6	Linda	Black	500	3
7	Ed	Jones	500	1
8	June	Wilson	500	1
9	Andy	Smith	500	3
10	Lou	Waters	500	4
11	Jill	Stone	500	4
12	Roger	White	500	2
13	Howard	Andrews	500	2
14	Fred	Goldberg	500	3
15	Barbara	Brown	2	3
16	Alice	Rogers	2	2
17	Mark	Morgan	3	3
18	Karen	Cole	3	2
ROLLBACK;
UPDATE emp PARTITION(p1,p3) JOIN dept ON emp.dept_id IN (SELECT dept_id FROM dept) 
SET emp.store_id = 500;
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
1	Bob	Taylor	3	2
2	Frank	Williams	1	2
3	Ellen	Johnson	3	4
4	Jim	Smith	2	4
5	Mary	Jones	500	1
6	Linda	Black	500	3
7	Ed	Jones	500	1
8	June	Wilson	500	1
9	Andy	Smith	500	3
10	Lou	Waters	2	4
11	Jill	Stone	1	4
12	Roger	White	3	2
13	Howard	Andrews	1	2
14	Fred	Goldberg	3	3
15	Barbara	Brown	500	3
16	Alice	Rogers	500	2
17	Mark	Morgan	500	3
18	Karen	Cole	500	2
ROLLBACK;
DELETE emp FROM emp PARTITION(p1,p3) JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE emp.dept_id IN (SELECT dept_id from dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
1	Bob	Taylor	3	2
2	Frank	Williams	1	2
3	Ellen	Johnson	3	4
4	Jim	Smith	2	4
10	Lou	Waters	2	4
11	Jill	Stone	1	4
12	Roger	White	3	2
13	Howard	Andrews	1	2
14	Fred	Goldberg	3	3
ROLLBACK;
DELETE FROM emp USING emp PARTITION(p0) JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE dept.dept_id IN (SELECT dept_id from dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
5	Mary	Jones	1	1
6	Linda	Black	2	3
7	Ed	Jones	2	1
8	June	Wilson	3	1
9	Andy	Smith	1	3
10	Lou	Waters	2	4
11	Jill	Stone	1	4
12	Roger	White	3	2
13	Howard	Andrews	1	2
14	Fred	Goldberg	3	3
15	Barbara	Brown	2	3
16	Alice	Rogers	2	2
17	Mark	Morgan	3	3
18	Karen	Cole	3	2
ROLLBACK;
DELETE QUICK emp FROM emp PARTITION(p1,p2,p3) RIGHT JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE emp.dept_id IN (SELECT dept_id from dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
1	Bob	Taylor	3	2
2	Frank	Williams	1	2
3	Ellen	Johnson	3	4
4	Jim	Smith	2	4
ROLLBACK;
DELETE LOW_PRIORITY emp FROM emp PARTITION(p3,p0) JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE emp.dept_id IN (SELECT dept_id from dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
5	Mary	Jones	1	1
6	Linda	Black	2	3
7	Ed	Jones	2	1
8	June	Wilson	3	1
9	Andy	Smith	1	3
10	Lou	Waters	2	4
11	Jill	Stone	1	4
12	Roger	White	3	2
13	Howard	Andrews	1	2
14	Fred	Goldberg	3	3
ROLLBACK;
DELETE IGNORE emp FROM emp JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE emp.dept_id IN (SELECT dept_id from dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
ROLLBACK;
DELETE emp FROM emp PARTITION(p1,p3,p0) LEFT JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE emp.dept_id IN (SELECT dept_id from dept);
SELECT * FROM dept;
dept_id	dept_name
1	admin
2	finance
3	IT
4	security
5	ref
6	services
ROLLBACK;
DELETE emp FROM emp PARTITION(p1,p3,p0,p2) INNER JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE emp.dept_id IN (SELECT dept_id from dept);
SELECT * FROM dept;
dept_id	dept_name
1	admin
2	finance
3	IT
4	security
5	ref
6	services
ROLLBACK;
# Tables are partitioned, queries with default optimizer_switch settings
SET optimizer_switch=default;
COMMIT;
EXPLAIN EXTENDED UPDATE emp PARTITION(p1,p3) JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500 
WHERE emp.dept_id IN (SELECT dept_id from dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	emp	ALL	dept_id	NULL	NULL	NULL	2	100.00	NULL
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index; FirstMatch(dept)
EXPLAIN EXTENDED UPDATE emp PARTITION(p1,p0) JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500 
WHERE dept.dept_id IN (SELECT dept_id from dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	emp	ALL	dept_id	NULL	NULL	NULL	2	100.00	NULL
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index; FirstMatch(dept)
EXPLAIN EXTENDED UPDATE emp PARTITION(p0,p3) RIGHT JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500 
WHERE emp.dept_id IN (SELECT dept_id from dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	emp	ALL	dept_id	NULL	NULL	NULL	2	100.00	Using where
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index; FirstMatch(dept)
EXPLAIN EXTENDED UPDATE LOW_PRIORITY emp PARTITION(p3,p2,p0) JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500 
WHERE emp.dept_id IN (SELECT dept_id from dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	emp	ALL	dept_id	NULL	NULL	NULL	3	100.00	NULL
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index; FirstMatch(dept)
EXPLAIN EXTENDED UPDATE IGNORE emp PARTITION(p3,p1,p2,p0) JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500 
WHERE emp.dept_id IN (SELECT dept_id from dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	dept	index	dept_id	dept_id	4	NULL	6	100.00	Using index; LooseScan
1	SIMPLE	emp	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	NULL
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	Using index
EXPLAIN EXTENDED UPDATE emp LEFT JOIN dept PARTITION(p0) ON emp.dept_id = dept.dept_id 
SET dept.dept_name = 'Junk' 
WHERE dept.dept_id IN (SELECT dept_id from emp);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	dept	ALL	dept_id	NULL	NULL	NULL	2	100.00	Using where
1	SIMPLE	emp	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	Using index
1	SIMPLE	emp	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	Using index; FirstMatch(emp)
EXPLAIN EXTENDED UPDATE emp INNER JOIN dept PARTITION(p1,p0) ON emp.dept_id = dept.dept_id 
SET dept.dept_name = 'Junk' 
WHERE dept.dept_id IN (SELECT DISTINCT dept_id from emp);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	emp	index	dept_id	dept_id	4	NULL	4	100.00	Using index; LooseScan
1	SIMPLE	emp	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	NULL
EXPLAIN EXTENDED UPDATE emp PARTITION(p0,p2), dept 
SET emp.store_id = 500 
WHERE emp.dept_id IN (SELECT dept_id FROM dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	emp	ALL	dept_id	NULL	NULL	NULL	2	100.00	NULL
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index; FirstMatch(emp)
1	SIMPLE	dept	index	NULL	dept_id	4	NULL	6	100.00	Using index; Using join buffer (Block Nested Loop)
EXPLAIN EXTENDED UPDATE emp INNER JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500, emp.lname = 'not SET', emp.fname = 'not SET' 
WHERE emp.dept_id IN (SELECT dept_id FROM dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	dept	index	dept_id	dept_id	4	NULL	6	100.00	Using index; LooseScan
1	SIMPLE	emp	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	NULL
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	Using index
EXPLAIN EXTENDED UPDATE emp INNER JOIN dept ON emp.dept_id = dept.dept_id AND emp.fname = 'Bob' OR emp.lname = 'Cole' 
SET emp.store_id = 500, emp.lname = 'not SET', emp.fname = 'not SET' 
WHERE emp.dept_id IN (SELECT dept_id FROM dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	dept	index	dept_id	dept_id	4	NULL	6	100.00	Using index; LooseScan
1	SIMPLE	emp	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	Using where
1	SIMPLE	dept	index	dept_id	dept_id	4	NULL	6	100.00	Using where; Using index; Using join buffer (Block Nested Loop)
EXPLAIN EXTENDED UPDATE emp PARTITION(p0,p1,p2) INNER JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500 
WHERE emp.dept_id IN (SELECT dept_id FROM dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	emp	ALL	dept_id	NULL	NULL	NULL	3	100.00	NULL
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index; FirstMatch(dept)
EXPLAIN EXTENDED UPDATE emp PARTITION(p1,p3) JOIN dept ON emp.dept_id IN (SELECT dept_id FROM dept) 
SET emp.store_id = 500;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	emp	ALL	dept_id	NULL	NULL	NULL	2	100.00	NULL
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index; FirstMatch(emp)
1	SIMPLE	dept	index	NULL	dept_id	4	NULL	6	100.00	Using index; Using join buffer (Block Nested Loop)
EXPLAIN EXTENDED DELETE emp FROM emp PARTITION(p1,p3) JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE emp.dept_id IN (SELECT dept_id from dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	emp	ALL	dept_id	NULL	NULL	NULL	2	100.00	NULL
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index; FirstMatch(dept)
EXPLAIN EXTENDED DELETE FROM emp USING emp PARTITION(p0) JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE dept.dept_id IN (SELECT dept_id from dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	emp	ALL	dept_id	NULL	NULL	NULL	2	100.00	NULL
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index; FirstMatch(dept)
EXPLAIN EXTENDED DELETE QUICK emp FROM emp PARTITION(p1,p2,p3) RIGHT JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE emp.dept_id IN (SELECT dept_id from dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	dept	index	dept_id	dept_id	4	NULL	6	100.00	Using where; Using index; LooseScan
1	SIMPLE	emp	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	NULL
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	Using index
EXPLAIN EXTENDED DELETE LOW_PRIORITY emp FROM emp PARTITION(p3,p0) JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE emp.dept_id IN (SELECT dept_id from dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	emp	ALL	dept_id	NULL	NULL	NULL	2	100.00	NULL
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.emp.dept_id	1	100.00	Using index; FirstMatch(dept)
EXPLAIN EXTENDED DELETE IGNORE emp FROM emp JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE emp.dept_id IN (SELECT dept_id from dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	dept	index	dept_id	dept_id	4	NULL	6	100.00	Using index; LooseScan
1	SIMPLE	emp	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	NULL
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	Using index
EXPLAIN EXTENDED DELETE emp FROM emp PARTITION(p1,p3,p0) LEFT JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE emp.dept_id IN (SELECT dept_id from dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	dept	index	dept_id	dept_id	4	NULL	6	100.00	Using index; LooseScan
1	SIMPLE	emp	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	NULL
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	Using index
EXPLAIN EXTENDED DELETE emp FROM emp PARTITION(p1,p3,p0,p2) INNER JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE emp.dept_id IN (SELECT dept_id from dept);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	dept	index	dept_id	dept_id	4	NULL	6	100.00	Using index; LooseScan
1	SIMPLE	emp	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	NULL
1	SIMPLE	dept	ref	dept_id	dept_id	4	test.dept.dept_id	1	100.00	Using index
UPDATE emp PARTITION(p1,p3) JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500 
WHERE emp.dept_id IN (SELECT dept_id from dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
1	Bob	Taylor	3	2
2	Frank	Williams	1	2
3	Ellen	Johnson	3	4
4	Jim	Smith	2	4
5	Mary	Jones	500	1
6	Linda	Black	500	3
7	Ed	Jones	500	1
8	June	Wilson	500	1
9	Andy	Smith	500	3
10	Lou	Waters	2	4
11	Jill	Stone	1	4
12	Roger	White	3	2
13	Howard	Andrews	1	2
14	Fred	Goldberg	3	3
15	Barbara	Brown	500	3
16	Alice	Rogers	500	2
17	Mark	Morgan	500	3
18	Karen	Cole	500	2
ROLLBACK;
UPDATE emp PARTITION(p1,p0) JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500 
WHERE dept.dept_id IN (SELECT dept_id from dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
1	Bob	Taylor	500	2
2	Frank	Williams	500	2
3	Ellen	Johnson	500	4
4	Jim	Smith	500	4
5	Mary	Jones	500	1
6	Linda	Black	500	3
7	Ed	Jones	500	1
8	June	Wilson	500	1
9	Andy	Smith	500	3
10	Lou	Waters	2	4
11	Jill	Stone	1	4
12	Roger	White	3	2
13	Howard	Andrews	1	2
14	Fred	Goldberg	3	3
15	Barbara	Brown	2	3
16	Alice	Rogers	2	2
17	Mark	Morgan	3	3
18	Karen	Cole	3	2
ROLLBACK;
UPDATE emp PARTITION(p0,p3) RIGHT JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500 
WHERE emp.dept_id IN (SELECT dept_id from dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
1	Bob	Taylor	500	2
2	Frank	Williams	500	2
3	Ellen	Johnson	500	4
4	Jim	Smith	500	4
5	Mary	Jones	1	1
6	Linda	Black	2	3
7	Ed	Jones	2	1
8	June	Wilson	3	1
9	Andy	Smith	1	3
10	Lou	Waters	2	4
11	Jill	Stone	1	4
12	Roger	White	3	2
13	Howard	Andrews	1	2
14	Fred	Goldberg	3	3
15	Barbara	Brown	500	3
16	Alice	Rogers	500	2
17	Mark	Morgan	500	3
18	Karen	Cole	500	2
ROLLBACK;
UPDATE LOW_PRIORITY emp PARTITION(p3,p2,p0) JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500 
WHERE emp.dept_id IN (SELECT dept_id from dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
1	Bob	Taylor	500	2
2	Frank	Williams	500	2
3	Ellen	Johnson	500	4
4	Jim	Smith	500	4
5	Mary	Jones	1	1
6	Linda	Black	2	3
7	Ed	Jones	2	1
8	June	Wilson	3	1
9	Andy	Smith	1	3
10	Lou	Waters	500	4
11	Jill	Stone	500	4
12	Roger	White	500	2
13	Howard	Andrews	500	2
14	Fred	Goldberg	500	3
15	Barbara	Brown	500	3
16	Alice	Rogers	500	2
17	Mark	Morgan	500	3
18	Karen	Cole	500	2
ROLLBACK;
UPDATE IGNORE emp PARTITION(p3,p1,p2,p0) JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500 
WHERE emp.dept_id IN (SELECT dept_id from dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
1	Bob	Taylor	500	2
2	Frank	Williams	500	2
3	Ellen	Johnson	500	4
4	Jim	Smith	500	4
5	Mary	Jones	500	1
6	Linda	Black	500	3
7	Ed	Jones	500	1
8	June	Wilson	500	1
9	Andy	Smith	500	3
10	Lou	Waters	500	4
11	Jill	Stone	500	4
12	Roger	White	500	2
13	Howard	Andrews	500	2
14	Fred	Goldberg	500	3
15	Barbara	Brown	500	3
16	Alice	Rogers	500	2
17	Mark	Morgan	500	3
18	Karen	Cole	500	2
ROLLBACK;
UPDATE emp LEFT JOIN dept PARTITION(p0) ON emp.dept_id = dept.dept_id 
SET dept.dept_name = 'Junk' 
WHERE dept.dept_id IN (SELECT dept_id from emp);
SELECT * FROM dept;
dept_id	dept_name
1	Junk
2	Junk
3	IT
4	security
5	ref
6	services
ROLLBACK;
UPDATE emp INNER JOIN dept PARTITION(p1,p0) ON emp.dept_id = dept.dept_id 
SET dept.dept_name = 'Junk' 
WHERE dept.dept_id IN (SELECT DISTINCT dept_id from emp);
SELECT * FROM dept;
dept_id	dept_name
1	Junk
2	Junk
3	Junk
4	Junk
5	ref
6	services
ROLLBACK;
UPDATE emp PARTITION(p0,p2), dept 
SET emp.store_id = 500 
WHERE emp.dept_id IN (SELECT dept_id FROM dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
1	Bob	Taylor	500	2
2	Frank	Williams	500	2
3	Ellen	Johnson	500	4
4	Jim	Smith	500	4
5	Mary	Jones	1	1
6	Linda	Black	2	3
7	Ed	Jones	2	1
8	June	Wilson	3	1
9	Andy	Smith	1	3
10	Lou	Waters	500	4
11	Jill	Stone	500	4
12	Roger	White	500	2
13	Howard	Andrews	500	2
14	Fred	Goldberg	500	3
15	Barbara	Brown	2	3
16	Alice	Rogers	2	2
17	Mark	Morgan	3	3
18	Karen	Cole	3	2
ROLLBACK;
UPDATE emp INNER JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500, emp.lname = 'not SET', emp.fname = 'not SET' 
WHERE emp.dept_id IN (SELECT dept_id FROM dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
1	not SET	not SET	500	2
2	not SET	not SET	500	2
3	not SET	not SET	500	4
4	not SET	not SET	500	4
5	not SET	not SET	500	1
6	not SET	not SET	500	3
7	not SET	not SET	500	1
8	not SET	not SET	500	1
9	not SET	not SET	500	3
10	not SET	not SET	500	4
11	not SET	not SET	500	4
12	not SET	not SET	500	2
13	not SET	not SET	500	2
14	not SET	not SET	500	3
15	not SET	not SET	500	3
16	not SET	not SET	500	2
17	not SET	not SET	500	3
18	not SET	not SET	500	2
ROLLBACK;
UPDATE emp INNER JOIN dept ON emp.dept_id = dept.dept_id AND emp.fname = 'Bob' OR emp.lname = 'Cole' 
SET emp.store_id = 500, emp.lname = 'not SET', emp.fname = 'not SET' 
WHERE emp.dept_id IN (SELECT dept_id FROM dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
1	not SET	not SET	500	2
2	Frank	Williams	1	2
3	Ellen	Johnson	3	4
4	Jim	Smith	2	4
5	Mary	Jones	1	1
6	Linda	Black	2	3
7	Ed	Jones	2	1
8	June	Wilson	3	1
9	Andy	Smith	1	3
10	Lou	Waters	2	4
11	Jill	Stone	1	4
12	Roger	White	3	2
13	Howard	Andrews	1	2
14	Fred	Goldberg	3	3
15	Barbara	Brown	2	3
16	Alice	Rogers	2	2
17	Mark	Morgan	3	3
18	not SET	not SET	500	2
ROLLBACK;
UPDATE emp PARTITION(p0,p1,p2) INNER JOIN dept ON emp.dept_id = dept.dept_id 
SET emp.store_id = 500 
WHERE emp.dept_id IN (SELECT dept_id FROM dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
1	Bob	Taylor	500	2
2	Frank	Williams	500	2
3	Ellen	Johnson	500	4
4	Jim	Smith	500	4
5	Mary	Jones	500	1
6	Linda	Black	500	3
7	Ed	Jones	500	1
8	June	Wilson	500	1
9	Andy	Smith	500	3
10	Lou	Waters	500	4
11	Jill	Stone	500	4
12	Roger	White	500	2
13	Howard	Andrews	500	2
14	Fred	Goldberg	500	3
15	Barbara	Brown	2	3
16	Alice	Rogers	2	2
17	Mark	Morgan	3	3
18	Karen	Cole	3	2
ROLLBACK;
UPDATE emp PARTITION(p1,p3) JOIN dept ON emp.dept_id IN (SELECT dept_id FROM dept) 
SET emp.store_id = 500;
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
1	Bob	Taylor	3	2
2	Frank	Williams	1	2
3	Ellen	Johnson	3	4
4	Jim	Smith	2	4
5	Mary	Jones	500	1
6	Linda	Black	500	3
7	Ed	Jones	500	1
8	June	Wilson	500	1
9	Andy	Smith	500	3
10	Lou	Waters	2	4
11	Jill	Stone	1	4
12	Roger	White	3	2
13	Howard	Andrews	1	2
14	Fred	Goldberg	3	3
15	Barbara	Brown	500	3
16	Alice	Rogers	500	2
17	Mark	Morgan	500	3
18	Karen	Cole	500	2
ROLLBACK;
DELETE emp FROM emp PARTITION(p1,p3) JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE emp.dept_id IN (SELECT dept_id from dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
1	Bob	Taylor	3	2
2	Frank	Williams	1	2
3	Ellen	Johnson	3	4
4	Jim	Smith	2	4
10	Lou	Waters	2	4
11	Jill	Stone	1	4
12	Roger	White	3	2
13	Howard	Andrews	1	2
14	Fred	Goldberg	3	3
ROLLBACK;
DELETE FROM emp USING emp PARTITION(p0) JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE dept.dept_id IN (SELECT dept_id from dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
5	Mary	Jones	1	1
6	Linda	Black	2	3
7	Ed	Jones	2	1
8	June	Wilson	3	1
9	Andy	Smith	1	3
10	Lou	Waters	2	4
11	Jill	Stone	1	4
12	Roger	White	3	2
13	Howard	Andrews	1	2
14	Fred	Goldberg	3	3
15	Barbara	Brown	2	3
16	Alice	Rogers	2	2
17	Mark	Morgan	3	3
18	Karen	Cole	3	2
ROLLBACK;
DELETE QUICK emp FROM emp PARTITION(p1,p2,p3) RIGHT JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE emp.dept_id IN (SELECT dept_id from dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
1	Bob	Taylor	3	2
2	Frank	Williams	1	2
3	Ellen	Johnson	3	4
4	Jim	Smith	2	4
ROLLBACK;
DELETE LOW_PRIORITY emp FROM emp PARTITION(p3,p0) JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE emp.dept_id IN (SELECT dept_id from dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
5	Mary	Jones	1	1
6	Linda	Black	2	3
7	Ed	Jones	2	1
8	June	Wilson	3	1
9	Andy	Smith	1	3
10	Lou	Waters	2	4
11	Jill	Stone	1	4
12	Roger	White	3	2
13	Howard	Andrews	1	2
14	Fred	Goldberg	3	3
ROLLBACK;
DELETE IGNORE emp FROM emp JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE emp.dept_id IN (SELECT dept_id from dept);
SELECT * FROM emp;
id	fname	lname	store_id	dept_id
ROLLBACK;
DELETE emp FROM emp PARTITION(p1,p3,p0) LEFT JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE emp.dept_id IN (SELECT dept_id from dept);
SELECT * FROM dept;
dept_id	dept_name
1	admin
2	finance
3	IT
4	security
5	ref
6	services
ROLLBACK;
DELETE emp FROM emp PARTITION(p1,p3,p0,p2) INNER JOIN dept 
ON emp.dept_id = dept.dept_id 
WHERE emp.dept_id IN (SELECT dept_id from dept);
SELECT * FROM dept;
dept_id	dept_name
1	admin
2	finance
3	IT
4	security
5	ref
6	services
ROLLBACK;
DROP TABLE emp;
DROP TABLE dept;
COMMIT;
# A test to verify multi-table UPDATE with BLOB data type
CREATE TABLE tb1(c1 TEXT(16), c2 TEXT(16)) ENGINE=INNODB;
CREATE TABLE tb2(c1 TEXT(16)) ENGINE=INNODB;
INSERT INTO tb1 VALUES(repeat('a',1000),repeat('b',1000));
Warnings:
Warning	1265	Data truncated for column 'c1' at row 1
Warning	1265	Data truncated for column 'c2' at row 1
INSERT INTO tb2 VALUES(repeat('a',1000));
Warnings:
Warning	1265	Data truncated for column 'c1' at row 1
COMMIT;
EXPLAIN EXTENDED UPDATE tb1 JOIN tb2 ON tb1.c1=tb2.c1 
SET tb1.c2='geography' 
WHERE tb1.c1 IN (SELECT c1 FROM tb2);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	tb1	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	SIMPLE	tb2	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	tb2	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; FirstMatch(tb2); Using join buffer (Block Nested Loop)
EXPLAIN EXTENDED DELETE FROM tb1 USING tb1 JOIN tb2 
ON tb1.c1=tb2.c1 
WHERE tb1.c1 IN (SELECT c1 FROM tb2);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	tb1	ALL	NULL	NULL	NULL	NULL	1	100.00	NULL
1	SIMPLE	tb2	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; Using join buffer (Block Nested Loop)
1	SIMPLE	tb2	ALL	NULL	NULL	NULL	NULL	1	100.00	Using where; FirstMatch(tb2); Using join buffer (Block Nested Loop)
UPDATE tb1 JOIN tb2 ON tb1.c1=tb2.c1 
SET tb1.c2='geography' 
WHERE tb1.c1 IN (SELECT c1 FROM tb2);
SELECT * FROM tb1;
c1	c2
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa	geography
ROLLBACK;
DELETE FROM tb1 USING tb1 JOIN tb2 
ON tb1.c1=tb2.c1 
WHERE tb1.c1 IN (SELECT c1 FROM tb2);
SELECT * FROM tb1;
c1	c2
ROLLBACK;
DROP TABLE tb1;
DROP TABLE tb2;
COMMIT;
DROP TABLE ot1,ot2,ot3,it1,it2,it3;
SET optimizer_switch=default;
COMMIT;
