# Original tests for WL#4443
# Must have InnoDB as engine to get the same statistics results.
# embedded uses MyISAM as default. CREATE SELECT uses the default engine.
SET @old_default_storage_engine = @@default_storage_engine;
SET @@default_storage_engine = 'InnoDB';
CREATE TABLE t1 (a int PRIMARY KEY, b varchar(128), KEY (b))
ENGINE = InnoDB
PARTITION BY HASH (a) PARTITIONS 13;
CREATE TABLE t2 (a int PRIMARY KEY AUTO_INCREMENT, b varchar(128))
ENGINE = InnoDB
PARTITION BY HASH (a) PARTITIONS 13;
#
#
# Test insert
#
FLUSH STATUS;
INSERT INTO t1 VALUES (1, 'First row, p1');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (table + partition lock/unlock)
# 1 commit
FLUSH STATUS;
INSERT INTO t1 VALUES (1, 'First row, duplicate');
ERROR 23000: Duplicate entry '1' for key 'PRIMARY'
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_EXTERNAL_LOCK	4
HANDLER_ROLLBACK	1
HANDLER_WRITE	18
# 4 locks (table + partition lock/unlock)
# 1 commit
FLUSH STATUS;
INSERT INTO t1 VALUES (0, 'First row, p0'), (2, 'First row, p2'),
(3, 'First row, p3'), (4, 'First row, p4');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	10
HANDLER_WRITE	21
# 10 locks (table + 4 partition * lock/unlock)
# 1 commit
FLUSH STATUS;
INSERT INTO t1 VALUES (1 * 13, 'Second row, p0'), (2 * 13, 'Third row, p0'),
(3 * 13, 'Fourth row, p0'), (4 * 13, 'Fifth row, p0');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	21
# 4 locks (table + 1 partition lock/unlock)
# 1 commit
FLUSH STATUS;
INSERT INTO t2 VALUES (NULL, 'First auto-inc row');
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	28
HANDLER_WRITE	18
# Auto increment value not know until write.
# 28 locks (table + 13 partition lock/unlock)
# 1 commit
#
# Test of pruning with secondary column auto_inc
#
CREATE TABLE t3 (a INT, b INT AUTO_INCREMENT, PRIMARY KEY (a, b))
ENGINE = MyISAM
PARTITION BY HASH (a) PARTITIONS 5;
FLUSH STATUS;
INSERT INTO t3 VALUES (1, 1);
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (table + partition lock/unlock)
# No commits, since MyISAM!
FLUSH STATUS;
INSERT INTO t3 VALUES (1, NULL);
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (table + partition lock/unlock)
SELECT @@sql_mode;
@@sql_mode

SET @old_sql_mode = @@sql_mode;
SET @@sql_mode = 'NO_AUTO_VALUE_ON_ZERO';
SELECT @@sql_mode;
@@sql_mode
NO_AUTO_VALUE_ON_ZERO
FLUSH STATUS;
INSERT INTO t3 VALUES (1, 0);
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (table + partition lock/unlock)
SET @@sql_mode = @old_sql_mode;
SELECT @@sql_mode;
@@sql_mode

FLUSH STATUS;
INSERT INTO t3 VALUES (1, 0);
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (table + partition lock/unlock)
SELECT * FROM t3;
a	b
1	0
1	1
1	2
1	3
DROP TABLE t3;
#
# Test insert select
#
FLUSH STATUS;
TRUNCATE TABLE t2;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	28
HANDLER_WRITE	17
# All partitions needs to be locked
# 28 locks (table + 13 partition lock/unlock)
# 1 commit
FLUSH STATUS;
INSERT INTO t2 SELECT a, b FROM t1 WHERE a IN (1,4);
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	34
HANDLER_READ_FIRST	2
HANDLER_READ_KEY	2
HANDLER_READ_NEXT	2
HANDLER_WRITE	19
# All partitions in t2 needs to be locked (no propagation from t1 yet).
# 2 partitions in t1 needs to be locked (for 1 and 4)
# 34 locks (2 table + 15 partition lock/unlock)
# 2 read_first, read_key and read_next.
# 1 commit
#
# Test TRUNCATE PARTITION
#
FLUSH STATUS;
ALTER TABLE t2 TRUNCATE PARTITION p1;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	17
# 4 locks (1 table, 1 partition lock/unlock)
INSERT INTO t2 SELECT a, b FROM t1 WHERE a = 1;
#
# Test insert on duplicated key update
#
FLUSH STATUS;
INSERT INTO t1 VALUES (65, "No duplicate")
ON DUPLICATE KEY UPDATE b = CONCAT(b, ", INSERT_DUP_KEY_UPDATE");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 lock (1 table + 1 partition lock/unlock)
# 1 write (insert)
# 1 commit
FLUSH STATUS;
INSERT INTO t1 VALUES (65, "No duplicate")
ON DUPLICATE KEY UPDATE b = CONCAT(b, ", INSERT_DUP_KEY_UPDATE");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_READ_KEY	1
HANDLER_UPDATE	1
HANDLER_WRITE	18
# 4 lock (1 table + 1 partition lock/unlock)
# 1 read_key
# 1 update
# 1 commit
FLUSH STATUS;
INSERT INTO t1 VALUES (78, "No duplicate")
ON DUPLICATE KEY UPDATE a = a + 13, b = CONCAT(b, ", INSERT_DUP_KEY_UPDATE");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	28
HANDLER_WRITE	18
# If a partitioning column is updated, no pruning
# 28 lock (1 table + 13 partition lock/unlock)
# 1 write (insert)
# 1 commit
FLUSH STATUS;
INSERT INTO t1 VALUES (78, "No duplicate")
ON DUPLICATE KEY UPDATE a = a + 13, b = CONCAT(b, ", INSERT_DUP_KEY_UPDATE");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	28
HANDLER_READ_KEY	1
HANDLER_UPDATE	1
HANDLER_WRITE	18
# If partitioning column is updated, no pruning
# 28 lock (1 table + 13 partition lock/unlock)
# 1 read_key
# 1 update
# 1 commit
#
# Test of failed update
#
FLUSH STATUS;
INSERT INTO t1 VALUES (78, "No duplicate")
ON DUPLICATE KEY UPDATE a = a + 13,
b = CONCAT(b, ", INSERT_DUP_KEY_UPDATE third");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	28
HANDLER_WRITE	18
# If partitioning column is updated, no pruning
# 28 lock (1 table + 13 partition lock/unlock)
# 1 commit
FLUSH STATUS;
INSERT INTO t1 VALUES (78, "No duplicate")
ON DUPLICATE KEY UPDATE a = a + 13,
b = CONCAT(b, ", INSERT_DUP_KEY_UPDATE fail?");
ERROR 23000: Duplicate entry '91' for key 'PRIMARY'
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_EXTERNAL_LOCK	28
HANDLER_READ_KEY	1
HANDLER_ROLLBACK	1
HANDLER_UPDATE	1
HANDLER_WRITE	18
# If partitioning column is updated, no pruning
# 28 lock (1 table + 13 partition lock/unlock)
# 1 read_key
# 1 update
# 1 rollback
#
# Test of update to different partition
#
FLUSH STATUS;
INSERT INTO t1 VALUES (104, "No duplicate")
ON DUPLICATE KEY UPDATE a = a + 1;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	28
HANDLER_WRITE	18
# If partitioning column is updated, no pruning
# 28 lock (1 table + 13 partition lock/unlock)
# 1 write
# 1 commit
FLUSH STATUS;
INSERT INTO t1 VALUES (104, "No duplicate")
ON DUPLICATE KEY UPDATE a = a + 1;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_DELETE	1
HANDLER_EXTERNAL_LOCK	28
HANDLER_READ_KEY	1
HANDLER_WRITE	19
# If partitioning column is updated, no pruning
# 28 lock (1 table + 13 partition lock/unlock)
# 1 delete
# 1 write
# 1 read_key
# 1 commit
FLUSH STATUS;
INSERT INTO t1 VALUES (104, "No duplicate 104")
ON DUPLICATE KEY UPDATE a = a + 1;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	28
HANDLER_WRITE	18
# If partitioning column is updated, no pruning
# 28 lock (1 table + 13 partition lock/unlock)
# 1 write
# 1 commit
FLUSH STATUS;
INSERT INTO t1 VALUES (104, "No duplicate 104 + 1")
ON DUPLICATE KEY UPDATE a = a + 1;
ERROR 23000: Duplicate entry '105' for key 'PRIMARY'
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_EXTERNAL_LOCK	28
HANDLER_READ_KEY	1
HANDLER_ROLLBACK	1
HANDLER_WRITE	19
# If partitioning column is updated, no pruning
# 28 lock (1 table + 13 partition lock/unlock)
# 1 write
# 1 read_key
# 1 rollback
#
# Test replace
#
FLUSH STATUS;
REPLACE INTO t1 VALUES (5, "REPLACE first");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 lock (1 table + 1 partition lock/unlock)
# 1 write
# 1 commit
FLUSH STATUS;
REPLACE INTO t1 VALUES (5, "REPLACE second");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_READ_KEY	1
HANDLER_UPDATE	1
HANDLER_WRITE	18
# 4 lock (1 table + 1 partition lock/unlock)
# 1 write
# 1 read_key
# 1 update (NOTE: write_record() may cheat instead of delete/insert!)
# 1 rollback
#
# Test select
#
FLUSH STATUS;
SELECT * FROM t1 ORDER BY a;
a	b
0	First row, p0
1	First row, p1
2	First row, p2
3	First row, p3
4	First row, p4
5	REPLACE second
13	Second row, p0
26	Third row, p0
39	Fourth row, p0
52	Fifth row, p0
65	No duplicate, INSERT_DUP_KEY_UPDATE
78	No duplicate
91	No duplicate, INSERT_DUP_KEY_UPDATE
104	No duplicate 104
105	No duplicate
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	28
HANDLER_READ_FIRST	13
HANDLER_READ_KEY	13
HANDLER_READ_NEXT	15
HANDLER_WRITE	17
# 28 locks
# 13 read_first
# 13 read_key
# 15 read_next
FLUSH STATUS;
SELECT * FROM t1 WHERE a IN (0, 1, 4) ORDER BY a;
a	b
0	First row, p0
1	First row, p1
4	First row, p4
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_FIRST	3
HANDLER_READ_KEY	3
HANDLER_READ_NEXT	12
HANDLER_WRITE	17
# 8 locks (1 table + 3 partitions lock/unlock)
# 3 read_first, read_key
# 12 read_next
FLUSH STATUS;
SELECT * FROM t1 WHERE a IN (13, 26, 39, 52);
a	b
13	Second row, p0
26	Third row, p0
39	Fourth row, p0
52	Fifth row, p0
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_READ_FIRST	1
HANDLER_READ_KEY	1
HANDLER_READ_NEXT	9
HANDLER_WRITE	17
# 4 locks (1 table + 1 partitions lock/unlock)
# 1 read_first, read_key
# 9 read_next
FLUSH STATUS;
SELECT * FROM t1 WHERE a = 3;
a	b
3	First row, p3
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_READ_KEY	1
HANDLER_WRITE	17
# 4 locks
# 1 read_key
FLUSH STATUS;
SELECT * FROM t1 WHERE b LIKE 'First%' ORDER BY a;
a	b
0	First row, p0
1	First row, p1
2	First row, p2
3	First row, p3
4	First row, p4
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	28
HANDLER_READ_KEY	13
HANDLER_READ_NEXT	5
HANDLER_WRITE	17
# 28 locks
# 13 read_key
# 5 read_next
#
# Test EXPLAIN select
#
FLUSH STATUS;
EXPLAIN SELECT * FROM t1;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	index	NULL	b	131	NULL	22	Using index
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	28
HANDLER_WRITE	17
# 28 locks (1 table + 13 partition lock/unlock)
FLUSH STATUS;
EXPLAIN SELECT * FROM t1 WHERE a IN (0, 1, 4) ORDER BY a;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	index	PRIMARY	PRIMARY	4	NULL	12	Using where
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	8
HANDLER_WRITE	17
# 8 locks (1 table + 3 partition lock/unlock)
FLUSH STATUS;
EXPLAIN SELECT * FROM t1 WHERE a IN (13, 26, 39, 52);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	index	PRIMARY	b	131	NULL	9	Using where; Using index
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	17
# 4 locks (1 table + 1 partition lock/unlock)
FLUSH STATUS;
EXPLAIN SELECT * FROM t1 WHERE a = 3;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	const	PRIMARY	PRIMARY	4	const	1	
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_READ_KEY	1
HANDLER_WRITE	17
# 4 locks (1 table + 1 partition lock/unlock)
FLUSH STATUS;
EXPLAIN SELECT * FROM t1 WHERE b LIKE 'First%' ORDER BY a;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	range	b	b	131	NULL	13	Using where; Using index; Using filesort
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	28
HANDLER_WRITE	17
# 28 locks (1 table + 13 partition lock/unlock)
FLUSH STATUS;
EXPLAIN PARTITIONS SELECT * FROM t1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12	index	NULL	b	131	NULL	22	Using index
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	28
HANDLER_WRITE	17
# 28 locks (1 table + 13 partition lock/unlock)
FLUSH STATUS;
EXPLAIN PARTITIONS SELECT * FROM t1 WHERE a IN (0, 1, 4) ORDER BY a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	p0,p1,p4	index	PRIMARY	PRIMARY	4	NULL	12	Using where
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	8
HANDLER_WRITE	17
# 8 locks (1 table + 3 partition lock/unlock)
FLUSH STATUS;
EXPLAIN PARTITIONS SELECT * FROM t1 WHERE a IN (13, 26, 39, 52);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	p0	index	PRIMARY	b	131	NULL	9	Using where; Using index
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	17
# 4 locks (1 table + 1 partition lock/unlock)
FLUSH STATUS;
EXPLAIN PARTITIONS SELECT * FROM t1 WHERE a = 3;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	p3	const	PRIMARY	PRIMARY	4	const	1	
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_READ_KEY	1
HANDLER_WRITE	17
# 4 locks (1 table + 1 partition lock/unlock)
FLUSH STATUS;
EXPLAIN PARTITIONS SELECT * FROM t1 WHERE b LIKE 'First%' ORDER BY a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12	range	b	b	131	NULL	13	Using where; Using index; Using filesort
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	28
HANDLER_WRITE	17
# 28 locks (1 table + 13 partition lock/unlock)
#
# Test pruning of non static values
# They will need to lock all partitions, but will allow pruning
# due to a second pruning call in optimize.
# TODO: Partition wise joins ?
#
CREATE TABLE t3 (a INT);
INSERT INTO t3 VALUES (1);
FLUSH STATUS;
SELECT * FROM t1 WHERE a = (SELECT a FROM t3);
a	b
1	First row, p1
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	30
HANDLER_READ_FIRST	1
HANDLER_READ_KEY	2
HANDLER_READ_RND_NEXT	2
HANDLER_WRITE	17
# 30 locks (2 table + 13 partitions lock/unlock)
# 1 read_first (NOTE only reads from one partition!)
# 2 read_key
# 2 read_rnd_next
FLUSH STATUS;
SELECT t1.a FROM t1 INNER JOIN t3 ON t1.a = t3.a;
a
1
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	30
HANDLER_READ_FIRST	1
HANDLER_READ_KEY	2
HANDLER_READ_RND_NEXT	2
HANDLER_WRITE	17
# 30 locks (2 table + 13 partitions lock/unlock)
# 1 read_first (NOTE only reads from one partition!)
# 2 read_key
FLUSH STATUS;
EXPLAIN PARTITIONS SELECT t1.a, t1.b FROM t1 INNER JOIN t3 ON t1.a = t3.a;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t3	NULL	ALL	NULL	NULL	NULL	NULL	1	Using where
1	SIMPLE	t1	p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12	eq_ref	PRIMARY	PRIMARY	4	test.t3.a	1	
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	30
HANDLER_WRITE	17
# 30 locks (2 table + 13 partitions lock/unlock)
FLUSH STATUS;
# EXPLAIN does not evaluate SUBQUERIES, so pruning will not show!
EXPLAIN PARTITIONS SELECT * FROM t1 WHERE a = (SELECT a FROM t3);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t1	p1	const	PRIMARY	PRIMARY	4	const	1	
2	SUBQUERY	t3	NULL	ALL	NULL	NULL	NULL	NULL	1	
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	30
HANDLER_READ_FIRST	1
HANDLER_READ_KEY	2
HANDLER_READ_RND_NEXT	2
HANDLER_WRITE	17
# 30 locks (2 table + 13 partitions lock/unlock)
FLUSH STATUS;
SELECT * FROM t1 WHERE a = 1;
a	b
1	First row, p1
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_READ_KEY	1
HANDLER_WRITE	17
# 4 locks
# 1 read_key
FLUSH STATUS;
SELECT * FROM t1 WHERE a = (SELECT COUNT(*) FROM t3);
a	b
1	First row, p1
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	30
HANDLER_READ_FIRST	1
HANDLER_READ_KEY	2
HANDLER_READ_RND_NEXT	2
HANDLER_WRITE	17
# 30 locks (2 table + 13 partitions lock/unlock)
# 1 read_first
# 2 read_key, read_rnd_next
#
# Test of non indexed partition column
#
CREATE TABLE t4 SELECT a, b FROM t1;
ALTER TABLE t4 PARTITION BY HASH (a) PARTITIONS 5;
FLUSH STATUS;
SELECT * FROM t4 WHERE a = (SELECT a FROM t3);
a	b
1	First row, p1
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	14
HANDLER_READ_FIRST	2
HANDLER_READ_KEY	2
HANDLER_READ_RND_NEXT	6
HANDLER_WRITE	17
# 14 locks (2 tables + 5 partitions lock/unlock)
# 2 read_first, read_key
# 6 read_rnd_next
FLUSH STATUS;
EXPLAIN PARTITIONS SELECT * FROM t4 WHERE a = (SELECT a FROM t3);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t4	p1	ALL	NULL	NULL	NULL	NULL	3	Using where
2	SUBQUERY	t3	NULL	ALL	NULL	NULL	NULL	NULL	1	
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	14
HANDLER_READ_FIRST	1
HANDLER_READ_KEY	1
HANDLER_READ_RND_NEXT	2
HANDLER_WRITE	17
# 14 locks (2 tables + 5 partitions lock/unlock)
INSERT INTO t3 VALUES (3);
SELECT * FROM t4 WHERE a = (SELECT a FROM t3);
ERROR 21000: Subquery returns more than 1 row
EXPLAIN PARTITIONS SELECT * FROM t4 WHERE a = (SELECT a FROM t3);
ERROR 21000: Subquery returns more than 1 row
EXPLAIN PARTITIONS SELECT * FROM t4 WHERE a = (SELECT a FROM t3 LIMIT 1);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t4	p1	ALL	NULL	NULL	NULL	NULL	3	Using where
2	SUBQUERY	t3	NULL	ALL	NULL	NULL	NULL	NULL	2	
EXPLAIN PARTITIONS SELECT * FROM t4 WHERE a = (SELECT MAX(a) FROM t3);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t4	p3	ALL	NULL	NULL	NULL	NULL	3	Using where
2	SUBQUERY	t3	NULL	ALL	NULL	NULL	NULL	NULL	2	
DROP TABLE t3;
DROP TABLE t4;
#
# Test select * from (select * from ...)
#
FLUSH STATUS;
SELECT * FROM (SELECT * FROM t1 WHERE a IN (0,2,3,13,26)) t3;
a	b
0	First row, p0
13	Second row, p0
26	Third row, p0
2	First row, p2
3	First row, p3
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_FIRST	3
HANDLER_READ_KEY	3
HANDLER_READ_NEXT	11
HANDLER_READ_RND_NEXT	6
HANDLER_WRITE	22
# 8 locks (1 table + 3 partitions lock/unlock)
# 3 read_first, read_key
# 11 read_next
# 6 read_rnd_next (tmp table)
FLUSH STATUS;
SELECT * FROM (SELECT * FROM (SELECT * FROM t1 WHERE a IN (0,2,3,13,26)) t3) t4;
a	b
0	First row, p0
13	Second row, p0
26	Third row, p0
2	First row, p2
3	First row, p3
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_FIRST	3
HANDLER_READ_KEY	3
HANDLER_READ_NEXT	11
HANDLER_READ_RND_NEXT	12
HANDLER_WRITE	27
# 8 locks (1 table + 3 partitions lock/unlock)
# 3 read_first, read_key
# 11 read_next
# 12 read_rnd_next (tmp table)
#
# Test EXPLAIN select * from (select * from ...)
#
FLUSH STATUS;
EXPLAIN SELECT * FROM (SELECT * FROM t1 WHERE a IN (0,2,3,13,26)) t3;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	<derived2>	ALL	NULL	NULL	NULL	NULL	5	
2	DERIVED	t1	index	PRIMARY	b	131	NULL	11	Using where; Using index
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	8
HANDLER_WRITE	17
# 8 locks (1 table + 3 partitions lock/unlock)
FLUSH STATUS;
EXPLAIN SELECT * FROM (SELECT * FROM (SELECT * FROM t1 WHERE a IN (0,2,3,13,26)) t3) t4;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	<derived2>	ALL	NULL	NULL	NULL	NULL	5	
2	DERIVED	<derived3>	ALL	NULL	NULL	NULL	NULL	5	
3	DERIVED	t1	index	PRIMARY	b	131	NULL	11	Using where; Using index
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	8
HANDLER_WRITE	17
# 8 locks (1 table + 3 partitions lock/unlock)
FLUSH STATUS;
EXPLAIN PARTITIONS SELECT * FROM (SELECT * FROM t1 WHERE a IN (0,2,3,13,26)) t3;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	5	
2	DERIVED	t1	p0,p2,p3	index	PRIMARY	b	131	NULL	11	Using where; Using index
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	8
HANDLER_WRITE	17
# 8 locks (1 table + 3 partitions lock/unlock)
FLUSH STATUS;
EXPLAIN PARTITIONS SELECT * FROM (SELECT * FROM (SELECT * FROM t1 WHERE a IN (0,2,3,13,26)) t3) t4;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	5	
2	DERIVED	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	5	
3	DERIVED	t1	p0,p2,p3	index	PRIMARY	b	131	NULL	11	Using where; Using index
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	8
HANDLER_WRITE	17
# 8 locks (1 table + 3 partitions lock/unlock)
#
# Test select ... UNION select ...
#
FLUSH STATUS;
SELECT * FROM t1 UNION SELECT * FROM t2;
a	b
0	First row, p0
1	First row, p1
104	No duplicate 104
105	No duplicate
13	Second row, p0
2	First row, p2
26	Third row, p0
3	First row, p3
39	Fourth row, p0
4	First row, p4
5	REPLACE second
52	Fifth row, p0
65	No duplicate, INSERT_DUP_KEY_UPDATE
78	No duplicate
91	No duplicate, INSERT_DUP_KEY_UPDATE
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	56
HANDLER_READ_FIRST	26
HANDLER_READ_KEY	26
HANDLER_READ_NEXT	15
HANDLER_READ_RND_NEXT	32
HANDLER_WRITE	34
# 56 locks (2 tables + 26 partitions lock/unlock)
FLUSH STATUS;
SELECT * FROM t1 WHERE a IN (0, 1, 13, 4) UNION SELECT * FROM t2;
a	b
0	First row, p0
13	Second row, p0
1	First row, p1
4	First row, p4
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	36
HANDLER_READ_FIRST	16
HANDLER_READ_KEY	16
HANDLER_READ_NEXT	12
HANDLER_READ_RND_NEXT	21
HANDLER_WRITE	23
# 36 locks (2 tables, 13 + 3 partitions lock/unlock)
FLUSH STATUS;
SELECT * FROM (SELECT * FROM t1 WHERE a IN (0, 1, 13, 4)) t3 UNION SELECT * FROM t2;
a	b
0	First row, p0
13	Second row, p0
1	First row, p1
4	First row, p4
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	36
HANDLER_READ_FIRST	16
HANDLER_READ_KEY	16
HANDLER_READ_NEXT	12
HANDLER_READ_RND_NEXT	26
HANDLER_WRITE	27
# 36 locks (2 tables, 13 + 3 partitions lock/unlock)
FLUSH STATUS;
SELECT * FROM (SELECT * FROM (SELECT * FROM t1 WHERE a IN (0, 1, 13, 4) UNION SELECT * FROM t2) t3) t4;
a	b
0	First row, p0
13	Second row, p0
1	First row, p1
4	First row, p4
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	36
HANDLER_READ_FIRST	16
HANDLER_READ_KEY	16
HANDLER_READ_NEXT	12
HANDLER_READ_RND_NEXT	31
HANDLER_WRITE	31
# 36 locks (2 tables, 13 + 3 partitions lock/unlock)
FLUSH STATUS;
SELECT * FROM (SELECT * FROM (SELECT * FROM t1 WHERE a IN (0, 1, 13, 4)) t3 UNION SELECT * FROM t2) t4;
a	b
0	First row, p0
13	Second row, p0
1	First row, p1
4	First row, p4
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	36
HANDLER_READ_FIRST	16
HANDLER_READ_KEY	16
HANDLER_READ_NEXT	12
HANDLER_READ_RND_NEXT	31
HANDLER_WRITE	31
# 36 locks (2 tables, 13 + 3 partitions lock/unlock)
FLUSH STATUS;
SELECT * FROM (SELECT * FROM (SELECT * FROM t1 WHERE a IN (0, 1, 13, 4)) t3) t4 UNION SELECT * FROM t2;
a	b
0	First row, p0
13	Second row, p0
1	First row, p1
4	First row, p4
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	36
HANDLER_READ_FIRST	16
HANDLER_READ_KEY	16
HANDLER_READ_NEXT	12
HANDLER_READ_RND_NEXT	31
HANDLER_WRITE	31
# 36 locks (2 tables, 13 + 3 partitions lock/unlock)
FLUSH STATUS;
SELECT * FROM (SELECT * FROM (SELECT * FROM t1 WHERE a IN (0, 1, 13, 4)) t3 UNION SELECT * FROM t2 WHERE a = 1) t4;
a	b
0	First row, p0
13	Second row, p0
1	First row, p1
4	First row, p4
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	12
HANDLER_READ_FIRST	3
HANDLER_READ_KEY	4
HANDLER_READ_NEXT	12
HANDLER_READ_RND_NEXT	16
HANDLER_WRITE	30
# 12 locks (2 tables, 3 + 1 partitions lock/unlock)
#
# Test EXPLAIN select ... UNION select ...
#
FLUSH STATUS;
EXPLAIN SELECT * FROM t1 UNION SELECT * FROM t2;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t1	index	NULL	b	131	NULL	22	Using index
2	UNION	t2	ALL	NULL	NULL	NULL	NULL	13	
NULL	UNION RESULT	<union1,2>	ALL	NULL	NULL	NULL	NULL	NULL	
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	56
HANDLER_WRITE	17
# 56 locks
FLUSH STATUS;
EXPLAIN SELECT * FROM t1 WHERE a IN (0, 1, 13, 4) UNION SELECT * FROM t2;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t1	index	PRIMARY	b	131	NULL	12	Using where; Using index
2	UNION	t2	ALL	NULL	NULL	NULL	NULL	13	
NULL	UNION RESULT	<union1,2>	ALL	NULL	NULL	NULL	NULL	NULL	
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	36
HANDLER_WRITE	17
# 36 locks (2 tables, 13 + 3 partitions lock/unlock)
FLUSH STATUS;
EXPLAIN SELECT * FROM (SELECT * FROM t1 WHERE a IN (0, 1, 13, 4)) t3 UNION SELECT * FROM t2;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	<derived2>	ALL	NULL	NULL	NULL	NULL	4	
2	DERIVED	t1	index	PRIMARY	b	131	NULL	12	Using where; Using index
3	UNION	t2	ALL	NULL	NULL	NULL	NULL	13	
NULL	UNION RESULT	<union1,3>	ALL	NULL	NULL	NULL	NULL	NULL	
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	36
HANDLER_WRITE	17
# 36 locks (2 tables, 13 + 3 partitions lock/unlock)
FLUSH STATUS;
EXPLAIN SELECT * FROM (SELECT * FROM (SELECT * FROM t1 WHERE a IN (0, 1, 13, 4) UNION SELECT * FROM t2) t3) t4;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	<derived2>	ALL	NULL	NULL	NULL	NULL	17	
2	DERIVED	<derived3>	ALL	NULL	NULL	NULL	NULL	17	
3	DERIVED	t1	index	PRIMARY	b	131	NULL	12	Using where; Using index
4	UNION	t2	ALL	NULL	NULL	NULL	NULL	13	
NULL	UNION RESULT	<union3,4>	ALL	NULL	NULL	NULL	NULL	NULL	
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	36
HANDLER_WRITE	17
# 36 locks (2 tables, 13 + 3 partitions lock/unlock)
FLUSH STATUS;
EXPLAIN SELECT * FROM (SELECT * FROM (SELECT * FROM t1 WHERE a IN (0, 1, 13, 4)) t3 UNION SELECT * FROM t2) t4;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	<derived2>	ALL	NULL	NULL	NULL	NULL	17	
2	DERIVED	<derived3>	ALL	NULL	NULL	NULL	NULL	4	
3	DERIVED	t1	index	PRIMARY	b	131	NULL	12	Using where; Using index
4	UNION	t2	ALL	NULL	NULL	NULL	NULL	13	
NULL	UNION RESULT	<union2,4>	ALL	NULL	NULL	NULL	NULL	NULL	
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	36
HANDLER_WRITE	17
# 36 locks (2 tables, 13 + 3 partitions lock/unlock)
FLUSH STATUS;
EXPLAIN SELECT * FROM (SELECT * FROM (SELECT * FROM t1 WHERE a IN (0, 1, 13, 4)) t3) t4 UNION SELECT * FROM t2;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	<derived2>	ALL	NULL	NULL	NULL	NULL	4	
2	DERIVED	<derived3>	ALL	NULL	NULL	NULL	NULL	4	
3	DERIVED	t1	index	PRIMARY	b	131	NULL	12	Using where; Using index
4	UNION	t2	ALL	NULL	NULL	NULL	NULL	13	
NULL	UNION RESULT	<union1,4>	ALL	NULL	NULL	NULL	NULL	NULL	
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	36
HANDLER_WRITE	17
# 36 locks (2 tables, 13 + 3 partitions lock/unlock)
FLUSH STATUS;
EXPLAIN SELECT * FROM (SELECT * FROM (SELECT * FROM t1 WHERE a IN (0, 1, 13, 4)) t3 UNION SELECT * FROM t2 WHERE a = 1) t4;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	<derived2>	ALL	NULL	NULL	NULL	NULL	5	
2	DERIVED	<derived3>	ALL	NULL	NULL	NULL	NULL	4	
3	DERIVED	t1	index	PRIMARY	b	131	NULL	12	Using where; Using index
4	UNION	t2	const	PRIMARY	PRIMARY	4	const	1	
NULL	UNION RESULT	<union2,4>	ALL	NULL	NULL	NULL	NULL	NULL	
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	12
HANDLER_READ_KEY	1
HANDLER_WRITE	17
# 12 locks (2 tables, 3 + 1 partitions lock/unlock)
FLUSH STATUS;
EXPLAIN PARTITIONS SELECT * FROM t1 UNION SELECT * FROM t2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t1	p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12	index	NULL	b	131	NULL	22	Using index
2	UNION	t2	p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12	ALL	NULL	NULL	NULL	NULL	13	
NULL	UNION RESULT	<union1,2>	NULL	ALL	NULL	NULL	NULL	NULL	NULL	
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	56
HANDLER_WRITE	17
# 56 locks
FLUSH STATUS;
EXPLAIN PARTITIONS SELECT * FROM t1 WHERE a IN (0, 1, 13, 4) UNION SELECT * FROM t2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t1	p0,p1,p4	index	PRIMARY	b	131	NULL	12	Using where; Using index
2	UNION	t2	p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12	ALL	NULL	NULL	NULL	NULL	13	
NULL	UNION RESULT	<union1,2>	NULL	ALL	NULL	NULL	NULL	NULL	NULL	
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	36
HANDLER_WRITE	17
# 36 locks (2 tables, 13 + 3 partitions lock/unlock)
FLUSH STATUS;
EXPLAIN PARTITIONS SELECT * FROM (SELECT * FROM t1 WHERE a IN (0, 1, 13, 4)) t3 UNION SELECT * FROM t2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	4	
2	DERIVED	t1	p0,p1,p4	index	PRIMARY	b	131	NULL	12	Using where; Using index
3	UNION	t2	p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12	ALL	NULL	NULL	NULL	NULL	13	
NULL	UNION RESULT	<union1,3>	NULL	ALL	NULL	NULL	NULL	NULL	NULL	
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	36
HANDLER_WRITE	17
# 36 locks (2 tables, 13 + 3 partitions lock/unlock)
FLUSH STATUS;
EXPLAIN PARTITIONS SELECT * FROM (SELECT * FROM (SELECT * FROM t1 WHERE a IN (0, 1, 13, 4) UNION SELECT * FROM t2) t3) t4;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	17	
2	DERIVED	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	17	
3	DERIVED	t1	p0,p1,p4	index	PRIMARY	b	131	NULL	12	Using where; Using index
4	UNION	t2	p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12	ALL	NULL	NULL	NULL	NULL	13	
NULL	UNION RESULT	<union3,4>	NULL	ALL	NULL	NULL	NULL	NULL	NULL	
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	36
HANDLER_WRITE	17
# 36 locks (2 tables, 13 + 3 partitions lock/unlock)
FLUSH STATUS;
EXPLAIN PARTITIONS SELECT * FROM (SELECT * FROM (SELECT * FROM t1 WHERE a IN (0, 1, 13, 4)) t3 UNION SELECT * FROM t2) t4;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	17	
2	DERIVED	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	4	
3	DERIVED	t1	p0,p1,p4	index	PRIMARY	b	131	NULL	12	Using where; Using index
4	UNION	t2	p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12	ALL	NULL	NULL	NULL	NULL	13	
NULL	UNION RESULT	<union2,4>	NULL	ALL	NULL	NULL	NULL	NULL	NULL	
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	36
HANDLER_WRITE	17
FLUSH STATUS;
EXPLAIN PARTITIONS SELECT * FROM (SELECT * FROM (SELECT * FROM t1 WHERE a IN (0, 1, 13, 4)) t3) t4 UNION SELECT * FROM t2;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	4	
2	DERIVED	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	4	
3	DERIVED	t1	p0,p1,p4	index	PRIMARY	b	131	NULL	12	Using where; Using index
4	UNION	t2	p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12	ALL	NULL	NULL	NULL	NULL	13	
NULL	UNION RESULT	<union1,4>	NULL	ALL	NULL	NULL	NULL	NULL	NULL	
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	36
HANDLER_WRITE	17
# 36 locks (2 tables, 13 + 3 partitions lock/unlock)
FLUSH STATUS;
EXPLAIN PARTITIONS SELECT * FROM (SELECT * FROM (SELECT * FROM t1 WHERE a IN (0, 1, 13, 4)) t3 UNION SELECT * FROM t2 WHERE a = 1) t4;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	<derived2>	NULL	ALL	NULL	NULL	NULL	NULL	5	
2	DERIVED	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	4	
3	DERIVED	t1	p0,p1,p4	index	PRIMARY	b	131	NULL	12	Using where; Using index
4	UNION	t2	p1	const	PRIMARY	PRIMARY	4	const	1	
NULL	UNION RESULT	<union2,4>	NULL	ALL	NULL	NULL	NULL	NULL	NULL	
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	12
HANDLER_READ_KEY	1
HANDLER_WRITE	17
# 12 locks (2 tables, 3 + 1 partitions lock/unlock)
#
# Test update
#
SELECT * FROM t1 ORDER BY a;
a	b
0	First row, p0
1	First row, p1
2	First row, p2
3	First row, p3
4	First row, p4
5	REPLACE second
13	Second row, p0
26	Third row, p0
39	Fourth row, p0
52	Fifth row, p0
65	No duplicate, INSERT_DUP_KEY_UPDATE
78	No duplicate
91	No duplicate, INSERT_DUP_KEY_UPDATE
104	No duplicate 104
105	No duplicate
# This should be prunable (does not change the partitioning key)
FLUSH STATUS;
UPDATE t1 SET b = CONCAT(b, ", updated 1") WHERE a IN (13, 26, 39, 52);
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_READ_KEY	4
HANDLER_UPDATE	4
HANDLER_WRITE	17
# 4 locks (1 table + 1 partition lock/unlock)
# 4 read_key
# 4 update
#
# This should not be prunable (only after implementing 'update pruning')
# i.e if all changed partitioning field is set to constant values,
# set lock_partitions to be a union of read_partition and the matching
# partition for the constants. Easy if all partitioning fields are set,
# probably needs a second round of prune_partitions() with these fields
# set to see if possible to prune locks.
FLUSH STATUS;
UPDATE t1 SET a = 99, b = CONCAT(b, ", updated 2 -> p8") WHERE a = 13;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_DELETE	1
HANDLER_EXTERNAL_LOCK	28
HANDLER_READ_KEY	2
HANDLER_READ_RND	1
HANDLER_WRITE	18
# 28 locks (1 table + 13 partition lock/unlock)
# 2 read_key
# 1 read_rnd
# 1 delete (due to moved to another partition)
# 1 write
#
# This should use ha_update_row instead of ha_write_row + ha_delete_row
FLUSH STATUS;
UPDATE t1 SET a = 13 + 99, b = CONCAT(b, ", updated 3") WHERE a = 99;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	28
HANDLER_READ_KEY	2
HANDLER_READ_RND	1
HANDLER_UPDATE	1
HANDLER_WRITE	17
# 28 locks (1 table + 13 partition lock/unlock)
# 2 read_key
# 1 read_rnd
# 1 update
#
# This should not be prunable (only after implementing
# 'optimized update pruning', which will probably never happen, since
# it depends on which partitioning type is used (for this only hash is
# simple, but range and list is possible, key is very hard)
FLUSH STATUS;
UPDATE t1 SET a = a + 1, b = CONCAT(b, ", updated 4 -> p9") WHERE a = 112;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_DELETE	1
HANDLER_EXTERNAL_LOCK	28
HANDLER_READ_KEY	2
HANDLER_READ_RND	1
HANDLER_WRITE	18
# 28 locks (1 table + 13 partition lock/unlock)
# 2 read_key
# 1 read_rnd
# 1 delete (due to moved to another partition)
# 1 write
FLUSH STATUS;
UPDATE t1 SET b = CONCAT(b, ", same as min(a) + 2 in t2") WHERE a = (SELECT MIN(a) + 2 FROM t2);
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	56
HANDLER_READ_FIRST	13
HANDLER_READ_KEY	14
HANDLER_UPDATE	1
HANDLER_WRITE	17
# 56 locks (2 tables, 13 + 13 partitions lock/unlock)
FLUSH STATUS;
UPDATE t1 SET b = CONCAT(b, ", max(a) in t2: ", (SELECT MAX(a) FROM t2)) WHERE a = 5;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	32
HANDLER_READ_KEY	14
HANDLER_READ_LAST	13
HANDLER_UPDATE	1
HANDLER_WRITE	17
# 32 locks (2 tables, 1 + 13 partitions lock/unlock)
#
# Test multi table update
#
SELECT * FROM t1 ORDER BY a;
a	b
0	First row, p0
1	First row, p1
2	First row, p2
3	First row, p3, same as min(a) + 2 in t2
4	First row, p4
5	REPLACE second, max(a) in t2: 4
26	Third row, p0, updated 1
39	Fourth row, p0, updated 1
52	Fifth row, p0, updated 1
65	No duplicate, INSERT_DUP_KEY_UPDATE
78	No duplicate
91	No duplicate, INSERT_DUP_KEY_UPDATE
104	No duplicate 104
105	No duplicate
113	Second row, p0, updated 1, updated 2 -> p8, updated 3, updated 4 -> p9
SELECT * FROM t2 ORDER BY a;
a	b
1	First row, p1
4	First row, p4
FLUSH STATUS;
EXPLAIN UPDATE t1, t2
SET t1.b = CONCAT(t1.b, ", t2.b:", t2.b),
t2.b = CONCAT(t2.b, ", t1.b:", t1.b)
WHERE t2.b = t1.b and t2.a = 4;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	const	PRIMARY	PRIMARY	4	const	1	
1	SIMPLE	t1	ref	b	b	131	const	13	
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	32
HANDLER_READ_KEY	1
HANDLER_WRITE	17
# 32 locks (2 table, 13 + 1 partitions lock/unlock)
FLUSH STATUS;
EXPLAIN PARTITIONS UPDATE t1, t2
SET t1.b = CONCAT(t1.b, ", t2.b:", t2.b),
t2.b = CONCAT(t2.b, ", t1.b:", t1.b)
WHERE t2.b = t1.b and t2.a = 4;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	p4	const	PRIMARY	PRIMARY	4	const	1	
1	SIMPLE	t1	p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12	ref	b	b	131	const	13	
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	32
HANDLER_READ_KEY	1
HANDLER_WRITE	17
# 32 locks (2 table, 13 + 1 partitions lock/unlock)
FLUSH STATUS;
UPDATE t1, t2
SET t1.b = CONCAT(t1.b, ", t2.b:", t2.b),
t2.b = CONCAT(t2.b, ", t1.b:", t1.b)
WHERE t2.b = t1.b and t2.a = 4;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	32
HANDLER_READ_KEY	15
HANDLER_READ_NEXT	1
HANDLER_READ_RND	1
HANDLER_READ_RND_NEXT	2
HANDLER_UPDATE	2
HANDLER_WRITE	18
# 32 locks (2 table, 13 + 1 partitions lock/unlock)
# 15 read_key
# 1 read_next, read_rnd
# 2 rean_rnd_next
# 2 update
#
# Test of views
#
# Found bug#13559657 (partition selection does not work with views)
FLUSH STATUS;
CREATE VIEW v1_25 AS SELECT a, b FROM t1 PARTITION (p2, p5);
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	6
HANDLER_WRITE	17
# 6 locks (1 table, 2 partitions lock/unlock)
FLUSH STATUS;
CREATE VIEW v1_25_check AS SELECT a, b FROM t1 PARTITION (p2, p5) t1_alias WITH CHECK OPTION;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	6
HANDLER_WRITE	17
# 6 locks (1 table, 2 partitions lock/unlock)
FLUSH STATUS;
CREATE VIEW v1_9 AS SELECT a, b FROM t1 WHERE a = 9;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	17
# 4 locks (1 table, 1 partitions lock/unlock)
FLUSH STATUS;
CREATE VIEW v1_9_check AS SELECT a, b FROM t1 WHERE a = 9 WITH CHECK OPTION;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	17
# 4 locks (1 table, 1 partitions lock/unlock)
FLUSH STATUS;
CREATE VIEW v1_all AS SELECT a, b FROM t1;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	28
HANDLER_WRITE	17
# 28 locks (1 table, 13 partitions lock/unlock)
SELECT TABLE_NAME, CHECK_OPTION, IS_UPDATABLE, VIEW_DEFINITION
FROM INFORMATION_SCHEMA.VIEWS
WHERE TABLE_SCHEMA = 'test' AND TABLE_NAME LIKE 'v1_%';
TABLE_NAME	CHECK_OPTION	IS_UPDATABLE	VIEW_DEFINITION
v1_25	NONE	YES	select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b` from `test`.`t1` PARTITION (`p2`,`p5`)
v1_25_check	CASCADED	YES	select `t1_alias`.`a` AS `a`,`t1_alias`.`b` AS `b` from `test`.`t1` PARTITION (`p2`,`p5`) `t1_alias`
v1_9	NONE	YES	select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b` from `test`.`t1` where (`test`.`t1`.`a` = 9)
v1_9_check	CASCADED	YES	select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b` from `test`.`t1` where (`test`.`t1`.`a` = 9)
v1_all	NONE	YES	select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b` from `test`.`t1`
FLUSH STATUS;
INSERT INTO v1_all VALUES (23, "Insert in v1_all");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
INSERT INTO v1_25 VALUES (18, "Insert in v1_25");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
INSERT INTO v1_25 VALUES (17, "Insert in v1_25 fail");
ERROR HY000: Found a row not matching the given partition set
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_EXTERNAL_LOCK	2
HANDLER_WRITE	17
# 2 locks (1 table, 0 partition lock/unlock)
FLUSH STATUS;
INSERT IGNORE INTO v1_25 VALUES (17, "Insert ignore in v1_25");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_EXTERNAL_LOCK	2
HANDLER_WRITE	17
# 2 locks (1 table, 0 partition lock/unlock)
FLUSH STATUS;
INSERT INTO v1_25_check VALUES (31, "Insert in v1_25_check");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
# Bug#13559657, this should fail!
FLUSH STATUS;
INSERT INTO v1_25_check VALUES (30, "Insert in v1_25_check fail");
ERROR HY000: Found a row not matching the given partition set
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_EXTERNAL_LOCK	2
HANDLER_WRITE	17
# 2 locks (1 table, 0 partition lock/unlock)
FLUSH STATUS;
INSERT IGNORE INTO v1_25_check VALUES (30, "Insert ignore in v1_25_check");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_EXTERNAL_LOCK	2
HANDLER_WRITE	17
# 2 locks (1 table, 0 partition lock/unlock)
FLUSH STATUS;
INSERT INTO v1_9 VALUES (9, "Insert in v1_9");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
INSERT INTO v1_9 VALUES (8, "Insert in v1_9 NO CHECK!");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
SELECT * FROM t1 WHERE a = 8;
a	b
8	Insert in v1_9 NO CHECK!
# DELETE will not find row not in view
FLUSH STATUS;
DELETE FROM v1_9_check WHERE a = 8;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_WRITE	17
# 0 locks, impossible where!
# TODO: See if the reviewer in optimizer notices the difference :)
# I.e. EXPLAIN DELETE for non partitioned tables does not optimize this
# as SELECT would!
EXPLAIN EXTENDED DELETE FROM v1_9_check WHERE a = 8;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	No matching rows after partition pruning
EXPLAIN EXTENDED SELECT * FROM v1_9_check WHERE a = 8;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	SIMPLE	NULL	NULL	NULL	NULL	NULL	NULL	NULL	NULL	Impossible WHERE
Warnings:
Note	1003	/* select#1 */ select `test`.`t1`.`a` AS `a`,`test`.`t1`.`b` AS `b` from `test`.`t1` where 0
SELECT * FROM t1 WHERE a = 8;
a	b
8	Insert in v1_9 NO CHECK!
FLUSH STATUS;
INSERT INTO v1_9_check VALUES (10, "Insert in v1_9_check fail");
ERROR HY000: CHECK OPTION failed 'test.v1_9_check'
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_EXTERNAL_LOCK	4
HANDLER_ROLLBACK	1
HANDLER_WRITE	17
# 4 locks (1 table, 1 partition lock/unlock)
SELECT * FROM t1 WHERE a = 9;
a	b
9	Insert in v1_9
FLUSH STATUS;
DELETE FROM v1_9_check WHERE a = 9;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_DELETE	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_READ_KEY	1
HANDLER_WRITE	17
# 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
INSERT INTO v1_9_check VALUES (9, "Insert in v1_9_check");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
FLUSH STATUS;
SELECT * FROM v1_9;
a	b
9	Insert in v1_9_check
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_READ_KEY	1
HANDLER_WRITE	17
# 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
SELECT * FROM v1_25;
a	b
18	Insert in v1_25
2	First row, p2
31	Insert in v1_25_check
5	REPLACE second, max(a) in t2: 4
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	6
HANDLER_READ_FIRST	2
HANDLER_READ_KEY	2
HANDLER_READ_NEXT	4
HANDLER_WRITE	17
# 6 locks (1 table, 2 partition lock/unlock)
FLUSH STATUS;
SELECT * FROM v1_all;
a	b
0	First row, p0
1	First row, p1
104	No duplicate 104
105	No duplicate
113	Second row, p0, updated 1, updated 2 -> p8, updated 3, updated 4 -> p9
18	Insert in v1_25
2	First row, p2
23	Insert in v1_all
26	Third row, p0, updated 1
3	First row, p3, same as min(a) + 2 in t2
31	Insert in v1_25_check
39	Fourth row, p0, updated 1
4	First row, p4, t2.b:First row, p4
5	REPLACE second, max(a) in t2: 4
52	Fifth row, p0, updated 1
65	No duplicate, INSERT_DUP_KEY_UPDATE
78	No duplicate
8	Insert in v1_9 NO CHECK!
9	Insert in v1_9_check
91	No duplicate, INSERT_DUP_KEY_UPDATE
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	28
HANDLER_READ_FIRST	13
HANDLER_READ_KEY	13
HANDLER_READ_NEXT	20
HANDLER_WRITE	17
# 28 locks (1 table, 13 partition lock/unlock)
DROP VIEW v1_all;
DROP VIEW v1_9, v1_9_check;
DROP VIEW v1_25, v1_25_check;
#
# Test CREATE SELECT
#
FLUSH STATUS;
CREATE TABLE t3 SELECT a, b FROM t1 WHERE a IN (0, 1, 13, 113);
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	10
HANDLER_READ_FIRST	3
HANDLER_READ_KEY	3
HANDLER_READ_NEXT	12
HANDLER_WRITE	20
# 10 locks (2 tables, 3 partitions lock/unlock)
SELECT * FROM t3 ORDER BY a;
a	b
0	First row, p0
1	First row, p1
113	Second row, p0, updated 1, updated 2 -> p8, updated 3, updated 4 -> p9
DROP TABLE t3;
FLUSH STATUS;
CREATE TABLE t3 SELECT a, b FROM t1 WHERE b LIKE 'First%';
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	30
HANDLER_READ_KEY	13
HANDLER_READ_NEXT	5
HANDLER_WRITE	22
# 30 locks (2 tables, 13 partitions lock/unlock)
SELECT * FROM t3 ORDER BY a;
a	b
0	First row, p0
1	First row, p1
2	First row, p2
3	First row, p3, same as min(a) + 2 in t2
4	First row, p4, t2.b:First row, p4
DROP TABLE t3;
#
# Test Stored procedures
#
DROP PROCEDURE IF EXISTS sp_insert;
DROP PROCEDURE IF EXISTS sp_insert_partition;
DROP PROCEDURE IF EXISTS sp_select_all;
DROP PROCEDURE IF EXISTS sp_select_exact;
DROP PROCEDURE IF EXISTS sp_select_partition;
DROP PROCEDURE IF EXISTS sp_select_range;
CREATE PROCEDURE sp_insert(a INT, b CHAR(16))
INSERT INTO test.t1 VALUES (a, b);
CREATE PROCEDURE sp_insert_partition(p CHAR(16), a INT, b CHAR(16))
BEGIN
SET @str = CONCAT("INSERT INTO test.t1 PARTITION(", p, ") VALUES (?, ?)");
SET @x = a, @y = b;
PREPARE stmt FROM @str;
EXECUTE stmt USING @x, @y;
END|
CREATE PROCEDURE sp_select_all()
SELECT * FROM test.t1;
CREATE PROCEDURE sp_select_exact(x INT)
SELECT * FROM test.t1 WHERE a = x;
CREATE PROCEDURE sp_select_partition(p CHAR(16))
BEGIN
SET @str = CONCAT("SELECT * FROM test.t1 PARTITION(", p, ")");
PREPARE stmt FROM @str;
EXECUTE stmt;
END|
CREATE PROCEDURE sp_select_range(x INT, y INT)
SELECT * FROM test.t1 WHERE a between x and y;
FLUSH STATUS;
CALL sp_insert(313,"Test313");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	6
HANDLER_READ_KEY	1
HANDLER_WRITE	18
# 6 locks (proc table, t1 + 1 partition lock/unlock)
FLUSH STATUS;
CALL sp_insert_partition("p7", 98, "Test98");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	6
HANDLER_READ_KEY	1
HANDLER_WRITE	18
# 6 locks (proc table, t1 + 1 partition lock/unlock)
FLUSH STATUS;
CALL sp_insert_partition("p8", 111, "Test111");
ERROR HY000: Found a row not matching the given partition set
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_EXTERNAL_LOCK	2
HANDLER_WRITE	17
# no proc locking since already in proc cache.
# 2 locks (1 table, no partitions lock/unlock)
FLUSH STATUS;
CALL sp_insert_partition("p7,p8", 111, "Test111");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	18
# 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
CALL sp_select_all();
a	b
0	First row, p0
1	First row, p1
104	No duplicate 104
105	No duplicate
111	Test111
113	Second row, p0, updated 1, updated 2 -> p8, updated 3, updated 4 -> p9
18	Insert in v1_25
2	First row, p2
23	Insert in v1_all
26	Third row, p0, updated 1
3	First row, p3, same as min(a) + 2 in t2
31	Insert in v1_25_check
313	Test313
39	Fourth row, p0, updated 1
4	First row, p4, t2.b:First row, p4
5	REPLACE second, max(a) in t2: 4
52	Fifth row, p0, updated 1
65	No duplicate, INSERT_DUP_KEY_UPDATE
78	No duplicate
8	Insert in v1_9 NO CHECK!
9	Insert in v1_9_check
91	No duplicate, INSERT_DUP_KEY_UPDATE
98	Test98
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	30
HANDLER_READ_FIRST	13
HANDLER_READ_KEY	14
HANDLER_READ_NEXT	23
HANDLER_WRITE	17
# 30 locks (procs table, t1 + 13 partitions lock/unlock)
FLUSH STATUS;
CALL sp_select_exact(98);
a	b
98	Test98
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	6
HANDLER_READ_KEY	2
HANDLER_WRITE	17
# 6 locks (proc table, t1 + 1 partition lock/unlock)
FLUSH STATUS;
CALL sp_select_partition("p7");
a	b
111	Test111
98	Test98
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	6
HANDLER_READ_FIRST	1
HANDLER_READ_KEY	2
HANDLER_READ_NEXT	2
HANDLER_WRITE	17
# 6 locks (proc table, t1 + 1 partition lock/unlock)
FLUSH STATUS;
CALL sp_select_partition("p8");
a	b
8	Insert in v1_9 NO CHECK!
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_READ_FIRST	1
HANDLER_READ_KEY	1
HANDLER_READ_NEXT	1
HANDLER_WRITE	17
# no proc locking since already in proc cache.
# 4 locks (t1 + 1 partition lock/unlock)
FLUSH STATUS;
CALL sp_select_partition("p7,p8");
a	b
111	Test111
8	Insert in v1_9 NO CHECK!
98	Test98
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	6
HANDLER_READ_FIRST	2
HANDLER_READ_KEY	2
HANDLER_READ_NEXT	3
HANDLER_WRITE	17
# 6 locks (t1 + 2 partitions lock/unlock)
FLUSH STATUS;
CALL sp_select_range(1,5);
a	b
1	First row, p1
2	First row, p2
3	First row, p3, same as min(a) + 2 in t2
4	First row, p4, t2.b:First row, p4
5	REPLACE second, max(a) in t2: 4
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	14
HANDLER_READ_KEY	6
HANDLER_READ_NEXT	5
HANDLER_WRITE	17
# 14 locks (proc table, t1 + 5 partitions lock/unlock)
DROP PROCEDURE sp_insert;
DROP PROCEDURE sp_insert_partition;
DROP PROCEDURE sp_select_all;
DROP PROCEDURE sp_select_partition;
DROP PROCEDURE sp_select_range;
DROP PROCEDURE sp_select_exact;
#
# Test EXPLAIN delete
#
SELECT * FROM t1 ORDER BY a;
a	b
0	First row, p0
1	First row, p1
2	First row, p2
3	First row, p3, same as min(a) + 2 in t2
4	First row, p4, t2.b:First row, p4
5	REPLACE second, max(a) in t2: 4
8	Insert in v1_9 NO CHECK!
9	Insert in v1_9_check
18	Insert in v1_25
23	Insert in v1_all
26	Third row, p0, updated 1
31	Insert in v1_25_check
39	Fourth row, p0, updated 1
52	Fifth row, p0, updated 1
65	No duplicate, INSERT_DUP_KEY_UPDATE
78	No duplicate
91	No duplicate, INSERT_DUP_KEY_UPDATE
98	Test98
104	No duplicate 104
105	No duplicate
111	Test111
113	Second row, p0, updated 1, updated 2 -> p8, updated 3, updated 4 -> p9
313	Test313
FLUSH STATUS;
EXPLAIN DELETE FROM t1 WHERE a = 105;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	range	PRIMARY,b	PRIMARY	4	NULL	1	Using where
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	17
# 4 locks (1 table + 1 partition lock/unlock)
# This EXPLAIN DELETE have an unstable row estimation.
FLUSH STATUS;
EXPLAIN DELETE FROM t1 WHERE b = "No duplicate";
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	range	PRIMARY,b	b	131	NULL	#	Using where
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	28
HANDLER_WRITE	17
# 28 locks (1 table + 13 partition lock/unlock)
FLUSH STATUS;
EXPLAIN PARTITIONS DELETE FROM t1 WHERE a = 105;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	p1	range	PRIMARY,b	PRIMARY	4	NULL	1	Using where
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_WRITE	17
# 4 locks (1 table + 1 partition lock/unlock)
# This EXPLAIN DELETE have an unstable row estimation.
FLUSH STATUS;
EXPLAIN PARTITIONS DELETE FROM t1 WHERE b = "No duplicate";
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12	range	PRIMARY,b	b	131	NULL	#	Using where
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	28
HANDLER_WRITE	17
# 28 locks (1 table + 13 partition lock/unlock)
#
# Test DELETE
#
FLUSH STATUS;
DELETE FROM t1 WHERE a = 105;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_DELETE	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_READ_KEY	1
HANDLER_WRITE	17
# 4 locks (1 table + 1 partition lock/unlock)
# 1 read_key
# 1 delete
FLUSH STATUS;
DELETE FROM t1 WHERE b = "No duplicate";
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_DELETE	1
HANDLER_EXTERNAL_LOCK	28
HANDLER_READ_KEY	13
HANDLER_READ_NEXT	1
HANDLER_WRITE	17
# 28 locks (1 table + 13 partition lock/unlock)
# 13 read_key
# 1 read_next (if more matches after the first match)
# 1 delete
#
# Test multi table delete
#
SELECT * FROM t1 ORDER BY a;
a	b
0	First row, p0
1	First row, p1
2	First row, p2
3	First row, p3, same as min(a) + 2 in t2
4	First row, p4, t2.b:First row, p4
5	REPLACE second, max(a) in t2: 4
8	Insert in v1_9 NO CHECK!
9	Insert in v1_9_check
18	Insert in v1_25
23	Insert in v1_all
26	Third row, p0, updated 1
31	Insert in v1_25_check
39	Fourth row, p0, updated 1
52	Fifth row, p0, updated 1
65	No duplicate, INSERT_DUP_KEY_UPDATE
91	No duplicate, INSERT_DUP_KEY_UPDATE
98	Test98
104	No duplicate 104
111	Test111
113	Second row, p0, updated 1, updated 2 -> p8, updated 3, updated 4 -> p9
313	Test313
SELECT * FROM t2 ORDER BY a;
a	b
1	First row, p1
4	First row, p4, t1.b:First row, p4
FLUSH STATUS;
EXPLAIN DELETE t1, t2 FROM t1, t2
WHERE t1.a = t2.a AND t1.b = 'First row, p1';
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	ref	PRIMARY,b	b	131	const	13	Using where
1	SIMPLE	t2	eq_ref	PRIMARY	PRIMARY	4	test.t1.a	1	
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	56
HANDLER_WRITE	17
# 56 locks (2 tables + 26 partitions lock/unlock)
FLUSH STATUS;
EXPLAIN DELETE FROM t2, t1 USING t2, t1
WHERE t1.b = t2.b AND t2.a = 4;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	const	PRIMARY	PRIMARY	4	const	1	
1	SIMPLE	t1	ref	b	b	131	const	13	
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	32
HANDLER_READ_KEY	1
HANDLER_WRITE	17
# 32 locks (2 tables , 13 + 1 partition lock/unlock)
FLUSH STATUS;
EXPLAIN PARTITIONS DELETE t1, t2 FROM t1, t2
WHERE t1.a = t2.a AND t1.b = 'First row, p1';
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12	ref	PRIMARY,b	b	131	const	13	Using where
1	SIMPLE	t2	p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12	eq_ref	PRIMARY	PRIMARY	4	test.t1.a	1	
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	56
HANDLER_WRITE	17
# 56 locks (2 tables + 26 partitions lock/unlock)
FLUSH STATUS;
EXPLAIN PARTITIONS DELETE FROM t2, t1 USING t2, t1
WHERE t1.b = t2.b AND t2.a = 4;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	p4	const	PRIMARY	PRIMARY	4	const	1	
1	SIMPLE	t1	p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12	ref	b	b	131	const	13	
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	32
HANDLER_READ_KEY	1
HANDLER_WRITE	17
# 32 locks (2 tables , 13 + 1 partition lock/unlock)
FLUSH STATUS;
DELETE t1, t2 FROM t1, t2
WHERE t1.a = t2.a AND t1.b = 'First row, p1';
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_DELETE	2
HANDLER_EXTERNAL_LOCK	56
HANDLER_READ_KEY	15
HANDLER_READ_NEXT	1
HANDLER_READ_RND	1
HANDLER_WRITE	17
# 56 locks (2 tables + 26 partitions lock/unlock)
# 15 read_key
# 1 read_next, read_rnd
# 2 delete
FLUSH STATUS;
DELETE FROM t2, t1 USING t2, t1
WHERE t1.b = t2.b AND t2.a = 4;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	32
HANDLER_READ_KEY	14
HANDLER_WRITE	17
# 32 locks (2 tables , 13 + 1 partition lock/unlock)
# 15 read_key
# 1 read_next, read_rnd
# 2 delete
SELECT * FROM t1 ORDER BY a;
a	b
0	First row, p0
2	First row, p2
3	First row, p3, same as min(a) + 2 in t2
4	First row, p4, t2.b:First row, p4
5	REPLACE second, max(a) in t2: 4
8	Insert in v1_9 NO CHECK!
9	Insert in v1_9_check
18	Insert in v1_25
23	Insert in v1_all
26	Third row, p0, updated 1
31	Insert in v1_25_check
39	Fourth row, p0, updated 1
52	Fifth row, p0, updated 1
65	No duplicate, INSERT_DUP_KEY_UPDATE
91	No duplicate, INSERT_DUP_KEY_UPDATE
98	Test98
104	No duplicate 104
111	Test111
113	Second row, p0, updated 1, updated 2 -> p8, updated 3, updated 4 -> p9
313	Test313
SELECT * FROM t2 ORDER BY a;
a	b
4	First row, p4, t1.b:First row, p4
#
# Test triggers
#
CREATE TABLE t3
(old_a int,
new_a int,
old_b varchar(255),
new_b varchar(255),
key (new_a, new_b),
key(new_b))
PARTITION BY HASH (new_a) PARTITIONS 5;
CREATE TRIGGER t1_after_insert AFTER INSERT
ON t1 FOR EACH ROW
INSERT INTO t3 VALUES (2, NEW.a, NULL, CONCAT("AI: ", NEW.b));
CREATE TRIGGER t1_after_update AFTER UPDATE
ON t1 FOR EACH ROW
INSERT INTO t3 VALUES (OLD.a, NEW.a, CONCAT("AU: ", OLD.b), CONCAT("AU: ", NEW.b));
FLUSH STATUS;
INSERT INTO t1 VALUES (2, "First row, p2")
ON DUPLICATE KEY UPDATE b = CONCAT(b, ", duplicate key 2");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	28
HANDLER_READ_KEY	1
HANDLER_UPDATE	1
HANDLER_WRITE	19
# 28 locks (3 tables, 1 + 5 + 5 partition lock/unlock)
# (t1 to insert, t3 after insert trigger, t3 after update trigger)
SELECT * FROM t1 WHERE a = 2;
a	b
2	First row, p2, duplicate key 2
FLUSH STATUS;
REPLACE INTO t1 VALUES (0, "First row, p0 REPLACED");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	16
HANDLER_READ_KEY	1
HANDLER_UPDATE	1
HANDLER_WRITE	19
# 16 locks (2 tables, 1 + 5 partition lock/unlock)
# (t1 to replace, t3 after insert trigger)
# Note that since there is no delete trigger, REPLACE cheats by
# doing update instead of delete+insert!
SELECT * FROM t1 WHERE a = 0;
a	b
0	First row, p0 REPLACED
FLUSH STATUS;
EXPLAIN PARTITIONS UPDATE t1 SET b = CONCAT(b, ", UPDATED2") WHERE a = 3;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	p3	range	PRIMARY,b	PRIMARY	4	NULL	1	Using where
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	16
HANDLER_WRITE	17
# 16 locks (2 tables, 1 + 5 partition lock/unlock)
# (t1 to insert, t3 after update trigger)
CREATE TRIGGER t1_after_delete AFTER DELETE
ON t1 FOR EACH ROW
INSERT INTO t3 VALUES (OLD.a, NULL, CONCAT("AD: ", OLD.b), NULL);
FLUSH STATUS;
REPLACE INTO t1 VALUES (0, "First row, p0 REPLACED2");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_DELETE	1
HANDLER_EXTERNAL_LOCK	28
HANDLER_READ_KEY	1
HANDLER_WRITE	21
# 28 locks (3 tables, 1 + 5 + 5 partition lock/unlock)
# (t1 to replace, t3 after insert trigger, t3 after delete trigger)
# Note that now it does delete+insert instead, due to delete trigger!
SELECT * FROM t1 WHERE a = 0;
a	b
0	First row, p0 REPLACED2
CREATE TRIGGER t1_before_delete BEFORE DELETE
ON t1 FOR EACH ROW
INSERT INTO t3 VALUES (OLD.a, NULL, CONCAT("BD: ", OLD.b), NULL);
FLUSH STATUS;
REPLACE INTO t1 VALUES (0, "First row, p0 REPLACED3");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_DELETE	1
HANDLER_EXTERNAL_LOCK	40
HANDLER_READ_KEY	1
HANDLER_WRITE	22
# 40 locks (4 tables, 1 + 5 + 5 + 5 partition lock/unlock)
# (t1 to replace, t3 after insert trigger, t3 before delete trigger,
#  t3 after delete trigger)
SELECT * FROM t1 WHERE a = 0;
a	b
0	First row, p0 REPLACED3
CREATE TRIGGER t1_before_update BEFORE UPDATE
ON t1 FOR EACH ROW
INSERT INTO t3 VALUES (OLD.a, NEW.a, CONCAT("BU: ", OLD.b), CONCAT("BU: ", NEW.b));
FLUSH STATUS;
INSERT INTO t1 VALUES (2, "First row, p2")
ON DUPLICATE KEY UPDATE b = CONCAT(b, ", duplicate key 2");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	64
HANDLER_READ_KEY	1
HANDLER_UPDATE	1
HANDLER_WRITE	20
# No pruning possible, due to BEFORE UPDATE trigger
# 64 locks (4 tables, 13 + 5 + 5 + 5 partitions lock/unlock)
# t1, t3 after insert, t3 before update, t3 after update
SELECT * FROM t1 WHERE a = 2;
a	b
2	First row, p2, duplicate key 2, duplicate key 2
FLUSH STATUS;
REPLACE INTO t1 VALUES (0, "First row, p0 REPLACED4");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_DELETE	1
HANDLER_EXTERNAL_LOCK	40
HANDLER_READ_KEY	1
HANDLER_WRITE	22
# 40 locks (4 tables, 1 + 5 + 5 + 5 partition lock/unlock)
# t1, t3 after insert, t3 before delete, t3 after delete
SELECT * FROM t1 WHERE a = 0;
a	b
0	First row, p0 REPLACED4
FLUSH STATUS;
EXPLAIN PARTITIONS UPDATE t1 SET b = CONCAT(b, ", UPDATED2") WHERE a = 3;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	p3	range	PRIMARY,b	PRIMARY	4	NULL	1	Using where; Using temporary
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	52
HANDLER_WRITE	17
# 52 locks (3 tables, 13 + 5 + 5 partition lock/unlock)
# t1, before update, after update
SELECT * FROM t1 WHERE a = 3;
a	b
3	First row, p3, same as min(a) + 2 in t2
FLUSH STATUS;
UPDATE t1 SET b = CONCAT(b, ", UPDATED2") WHERE a = 3;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	52
HANDLER_READ_KEY	2
HANDLER_READ_RND	1
HANDLER_UPDATE	1
HANDLER_WRITE	19
# 52 locks (3 tables, 13 + 5 + 5 partition lock/unlock)
# t1, before update, after update
SELECT * FROM t1 WHERE a = 3;
a	b
3	First row, p3, same as min(a) + 2 in t2, UPDATED2
FLUSH STATUS;
INSERT INTO t1 VALUES (12, "First row, p12");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	16
HANDLER_WRITE	19
# 16 locks (2 table, 1 + 5 partition lock/unlock)
# t1, t3 after insert trigger
CREATE TRIGGER t1_before_insert BEFORE INSERT
ON t1 FOR EACH ROW
INSERT INTO t3 VALUES (1, NEW.a, NULL, CONCAT("BI: ", NEW.b));
FLUSH STATUS;
INSERT INTO t1 VALUES (11, "First row, p11");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	52
HANDLER_WRITE	20
# Nothing can be pruned, due to triggers.
# 52 locks (3 tables, 13 + 5 + 5 partition lock/unlock)
# t1, t3 before insert, t3 after insert.
FLUSH STATUS;
EXPLAIN PARTITIONS DELETE FROM t1 WHERE a = 98;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	p7	range	PRIMARY,b	PRIMARY	4	NULL	1	Using where
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	28
HANDLER_WRITE	17
# 28 locks (3 tables, 1 + 5 + 5 partitions)
# t1, t3 before delete trigger, t3 after delete trigger
# part 7, part 0-4, part 0-4.
SELECT * FROM t1 ORDER BY a;
a	b
0	First row, p0 REPLACED4
2	First row, p2, duplicate key 2, duplicate key 2
3	First row, p3, same as min(a) + 2 in t2, UPDATED2
4	First row, p4, t2.b:First row, p4
5	REPLACE second, max(a) in t2: 4
8	Insert in v1_9 NO CHECK!
9	Insert in v1_9_check
11	First row, p11
12	First row, p12
18	Insert in v1_25
23	Insert in v1_all
26	Third row, p0, updated 1
31	Insert in v1_25_check
39	Fourth row, p0, updated 1
52	Fifth row, p0, updated 1
65	No duplicate, INSERT_DUP_KEY_UPDATE
91	No duplicate, INSERT_DUP_KEY_UPDATE
98	Test98
104	No duplicate 104
111	Test111
113	Second row, p0, updated 1, updated 2 -> p8, updated 3, updated 4 -> p9
313	Test313
FLUSH STATUS;
DELETE FROM t1 WHERE a = 98;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_DELETE	1
HANDLER_EXTERNAL_LOCK	28
HANDLER_READ_KEY	1
HANDLER_WRITE	19
# 28 locks (3 tables, 1 + 5 + 5 partitions)
# t1, t3 before delete trigger, t3 after delete trigger
INSERT INTO t2 VALUES (1, "First row, p1");
INSERT INTO t2 VALUES (3, "First row, p3");
CREATE TRIGGER t2_before_insert BEFORE INSERT
ON t2 FOR EACH ROW
SET NEW.a = NEW.a + 1;
# Test that one cannot update a row in BEFORE UPDATE
CREATE TRIGGER t2_before_update BEFORE UPDATE
ON t2 FOR EACH ROW
SET OLD.a = OLD.a - 1;
ERROR HY000: Updating of OLD row is not allowed in trigger
CREATE TRIGGER t2_before_update BEFORE UPDATE
ON t2 FOR EACH ROW
SET NEW.a = NEW.a - 1;
# Test that one cannot update a row in BEFORE DELETE
CREATE TRIGGER t2_before_delete BEFORE DELETE
ON t2 FOR EACH ROW
SET OLD.a = OLD.a - 1;
ERROR HY000: Updating of OLD row is not allowed in trigger
FLUSH STATUS;
INSERT INTO t2 VALUES (1, "Second row, p1");
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	28
HANDLER_WRITE	18
# 28 locks (1 tables, 13 partitions lock/unlock)
SELECT * FROM t2 ORDER BY a;
a	b
1	First row, p1
2	Second row, p1
3	First row, p3
4	First row, p4, t1.b:First row, p4
FLUSH STATUS;
UPDATE t2 SET b = CONCAT(b, ", UPDATED3") WHERE a = 4;
ERROR 23000: Duplicate entry '3' for key 'PRIMARY'
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_EXTERNAL_LOCK	28
HANDLER_READ_KEY	2
HANDLER_READ_RND	1
HANDLER_ROLLBACK	1
HANDLER_WRITE	18
# 28 locks (1 tables, 13 partitions lock/unlock)
FLUSH STATUS;
UPDATE t2 SET b = CONCAT(b, ", UPDATED3") WHERE a = 1;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_DELETE	1
HANDLER_EXTERNAL_LOCK	28
HANDLER_READ_KEY	2
HANDLER_READ_RND	1
HANDLER_WRITE	18
# 28 locks (1 tables, 13 partitions lock/unlock)
SELECT * FROM t1 ORDER BY a;
a	b
0	First row, p0 REPLACED4
2	First row, p2, duplicate key 2, duplicate key 2
3	First row, p3, same as min(a) + 2 in t2, UPDATED2
4	First row, p4, t2.b:First row, p4
5	REPLACE second, max(a) in t2: 4
8	Insert in v1_9 NO CHECK!
9	Insert in v1_9_check
11	First row, p11
12	First row, p12
18	Insert in v1_25
23	Insert in v1_all
26	Third row, p0, updated 1
31	Insert in v1_25_check
39	Fourth row, p0, updated 1
52	Fifth row, p0, updated 1
65	No duplicate, INSERT_DUP_KEY_UPDATE
91	No duplicate, INSERT_DUP_KEY_UPDATE
104	No duplicate 104
111	Test111
113	Second row, p0, updated 1, updated 2 -> p8, updated 3, updated 4 -> p9
313	Test313
SELECT * FROM t2 ORDER BY a;
a	b
0	First row, p1, UPDATED3
2	Second row, p1
3	First row, p3
4	First row, p4, t1.b:First row, p4
SELECT * FROM t3 ORDER BY new_a;
old_a	new_a	old_b	new_b
0	NULL	AD: First row, p0 REPLACED	NULL
0	NULL	AD: First row, p0 REPLACED2	NULL
0	NULL	AD: First row, p0 REPLACED3	NULL
0	NULL	BD: First row, p0 REPLACED2	NULL
0	NULL	BD: First row, p0 REPLACED3	NULL
1	11	NULL	BI: First row, p11
2	0	NULL	AI: First row, p0 REPLACED
2	0	NULL	AI: First row, p0 REPLACED2
2	0	NULL	AI: First row, p0 REPLACED3
2	0	NULL	AI: First row, p0 REPLACED4
2	11	NULL	AI: First row, p11
2	12	NULL	AI: First row, p12
2	2	AU: First row, p2	AU: First row, p2, duplicate key 2
2	2	AU: First row, p2, duplicate key 2	AU: First row, p2, duplicate key 2, duplicate key 2
2	2	BU: First row, p2, duplicate key 2	BU: First row, p2, duplicate key 2, duplicate key 2
3	3	AU: First row, p3, same as min(a) + 2 in t2	AU: First row, p3, same as min(a) + 2 in t2, UPDATED2
3	3	BU: First row, p3, same as min(a) + 2 in t2	BU: First row, p3, same as min(a) + 2 in t2, UPDATED2
98	NULL	AD: Test98	NULL
98	NULL	BD: Test98	NULL
DROP TABLE t1, t2, t3;
#
# DO is not supported by WL#4443 !!!
# Test of DO (eg. SELECT without returning values)
#
CREATE TABLE t1 (a INT, b VARCHAR(66))
PARTITION BY HASH (a) PARTITIONS 3;
INSERT INTO t1 VALUES (1, "One"), (2, "Two"), (3, "Three"), (4, "Four"), (5, "Five"), (6, "Six"), (0, "Zero");
DO (SELECT a FROM t1);
Warnings:
Error	1242	Subquery returns more than 1 row
FLUSH STATUS;
DO (SELECT @x:= b FROM t1 WHERE a = 5);
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_FIRST	1
HANDLER_READ_KEY	1
HANDLER_READ_RND_NEXT	3
HANDLER_WRITE	17
# 8 locks (1 table + 3 partitions lock/unlock)
SELECT @x;
@x
Five
FLUSH STATUS;
DO (SELECT @x:= b FROM t1 WHERE a = 5 or a = 1 ORDER BY b LIMIT 1);
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	8
HANDLER_READ_FIRST	2
HANDLER_READ_KEY	2
HANDLER_READ_RND_NEXT	6
HANDLER_WRITE	17
SELECT @x;
@x
Five
DROP TABLE t1;
#
# Test EXCHANGE PARTITION to only lock exchanged partition
#
CREATE TABLE t1 (a INT, b VARCHAR(44));
CREATE TABLE t2 (a INT, b VARCHAR(44))
PARTITION BY HASH (a) PARTITIONS 3;
INSERT INTO t1 VALUES (10, "Ten"), (13, "Thirteen"), (16, "Sixteen");
INSERT INTO t2 VALUES (0, "Zero"), (1, "One"), (2, "Two"),
(3, "Three"), (4, "Four"), (5, "Five"),
(6, "Six"), (7, "Seven"), (8, "Eight");
FLUSH STATUS;
ALTER TABLE t2 EXCHANGE PARTITION p1 WITH TABLE t1;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	6
HANDLER_READ_FIRST	1
HANDLER_READ_KEY	1
HANDLER_READ_RND_NEXT	4
HANDLER_WRITE	17
# 6 locks (2 table + 1 partition lock/unlock)
SELECT * FROM t1 ORDER BY a;
a	b
1	One
4	Four
7	Seven
SELECT * FROM t2 ORDER BY a;
a	b
0	Zero
2	Two
3	Three
5	Five
6	Six
8	Eight
10	Ten
13	Thirteen
16	Sixteen
DROP TABLE t1, t2;
#
# Prepared statement
#
CREATE TABLE t1 (N int, M tinyint)
PARTITION BY HASH (N) PARTITIONS 3;
INSERT INTO t1 VALUES (1,0),(1,0),(2,0),(2,0),(3,0);
PREPARE stmt FROM 'UPDATE t1 AS P1 INNER JOIN (SELECT N FROM t1 GROUP BY N HAVING COUNT(M) > 1) AS P2 ON P1.N = P2.N SET P1.M = 2';
FLUSH STATUS;
EXECUTE stmt;
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	16
HANDLER_READ_FIRST	6
HANDLER_READ_KEY	16
HANDLER_READ_NEXT	4
HANDLER_READ_RND	2
HANDLER_READ_RND_NEXT	20
HANDLER_UPDATE	6
HANDLER_WRITE	22
# 16 locks (2 table + 6 partition lock/unlock)
SELECT * FROM t1 ORDER BY N, M;
N	M
1	2
1	2
2	2
2	2
3	0
DEALLOCATE PREPARE stmt;
PREPARE stmt FROM 'SELECT * FROM t1 WHERE N = 2';
FLUSH STATUS;
EXECUTE stmt;
N	M
2	2
2	2
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_COMMIT	1
HANDLER_EXTERNAL_LOCK	4
HANDLER_READ_FIRST	1
HANDLER_READ_KEY	1
HANDLER_READ_RND_NEXT	3
HANDLER_WRITE	17
# 4 locks (1 table + 1 partition lock/unlock)
DROP TABLE t1;
# Check if we can infer from condition on partition fields that 
# no records will match.
CREATE TABLE t1 ( a int NOT NULL) PARTITION BY HASH(a) PARTITIONS 2;
INSERT INTO t1 VALUES (1),(2),(3);
FLUSH STATUS;
EXPLAIN SELECT * FROM t1 WHERE a=5 AND a=6;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	NULL	NULL	NULL	NULL	NULL	NULL	NULL	Impossible WHERE
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_EXTERNAL_LOCK	2
HANDLER_WRITE	17
# 2 locks (1 table + 0 partition lock/unlock)
FLUSH STATUS;
SELECT * FROM t1 WHERE a=5 AND a=6;
a
SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;
VARIABLE_NAME	VARIABLE_VALUE
HANDLER_EXTERNAL_LOCK	2
HANDLER_WRITE	17
# 2 locks (1 table + 0 partition lock/unlock)
DROP TABLE t1;
#
# Test of subqueries in INSERT
#
CREATE TABLE t1 (a INT, b VARCHAR(64));
INSERT INTO t1 VALUES (1, "test 1");
INSERT INTO t1 VALUES (SELECT * FROM t1);
ERROR 42000: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'SELECT * FROM t1)' at line 1
DROP TABLE t1;
# TODO: Add variants for LOCK TABLES
# TODO: Document that functions in WHERE clause can now be evaluated
#       before any locks are taken (i.e. if optimization is possible
#       before locking). Like GET_LOCK/RELEASE_LOCK ?
# TODO: How to make a stored function or trigger prune?
# Stored procedures does not prelock, so it will prune locks.
# Stored functions, triggers and events prelocks all used tables
# which makes prune locks impossible.
