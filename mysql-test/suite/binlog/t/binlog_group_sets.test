--source include/have_gtid.inc
--source include/have_innodb.inc
--let $rpl_topology= 1
--source include/rpl_init.inc
--connection default

--echo ######## Initialize ########

# Auxiliary table listing all variables that we are going to test.
CREATE TABLE variables (var_id INT PRIMARY KEY, name TEXT(100));
INSERT INTO variables VALUES
 (1, 'session_partial'), (2, 'global_partial'),
 (3, 'session_ended'), (4, 'global_ended');

--delimiter |

# Return nonzero if the two group_sets are equal.
CREATE FUNCTION GROUPS_EQUAL(g1 TEXT(10000), g2 TEXT(10000))
RETURNS INT
BEGIN
  RETURN GROUP_SUBSET(g1, g2) AND GROUP_SUBSET(g2, g1);
END|

# Return true if t1 union t2 = sum, and t1 and t2 are disjoint.
CREATE FUNCTION GROUP_DISJOINT_UNION(t1 TEXT(10000), t2 TEXT(10000), sum TEXT(10000))
RETURNS INT
BEGIN
  RETURN GROUPS_EQUAL(GROUP_SUBTRACT(sum, t1), t2) AND
         GROUPS_EQUAL(GROUP_SUBTRACT(sum, t2), t1);
END|

# Return true if group_set 'new' is obtained by adding 'diff' to 'old'.
CREATE FUNCTION CHECK_GROUP_SET(old TEXT(10000), diff TEXT(10000), new TEXT(10000))
RETURNS INT
BEGIN
  DECLARE tilde_pos INT DEFAULT LOCATE('~', diff);
  DECLARE to_add TEXT(10000);
  DECLARE to_remove TEXT(10000);
  IF tilde_pos != 0 THEN
    SET to_add = SUBSTR(diff, 1, tilde_pos - 1);
    SET to_remove = SUBSTR(diff, tilde_pos + 1);
    RETURN GROUP_SUBSET(to_remove, old) AND
           GROUP_DISJOINT_UNION(GROUP_SUBTRACT(old, to_remove), to_add, new);
  ELSE
    RETURN GROUP_DISJOINT_UNION(old, diff, new);
  END IF;
END|

# convert strings like '1:4-5,97:1' to
# '01010101-0101-0101-0101-010101010101:4-5,97979797-9797-9797-9797-979797979797:1'
CREATE FUNCTION NUMBER_TO_UUID(str TEXT(10000))
RETURNS TEXT(10000)
BEGIN
  DECLARE pos INT DEFAULT 0;# pos. before next number to replace by UUID in str
  DECLARE colon INT;               # position of next ':' after pos in str
  DECLARE n TEXT(3);               # number between comma and colon
  DECLARE nn TEXT(5);              # n, zero-padded to 2 digits, repeated twice
  DECLARE _uuid TEXT(37);          # UUID generated from nn
  DECLARE comma INT;               # position of next ',' after pos
  DECLARE tilde INT;               # position of next '~' after pos
  IF str = '' or str IS NULL THEN
    RETURN str;
  END IF;
  IF SUBSTR(str, 1, 1) = '~' THEN
    SET pos = 1;
  END IF;
  REPEAT
    # find end of number
    SET colon = LOCATE(':', str, pos + 1);
    # get number
    SET n = SUBSTR(str, pos + 1, colon - pos - 1);
    # convert number to uuid
    SET nn = REPEAT(LPAD(n, 2, '0'), 2);
    SET _uuid = CONCAT(nn, nn, '-', nn, '-', nn, '-', nn, '-', nn, nn, nn);
    # replace number by uuid
    SET str = CONCAT(SUBSTR(str, 1, pos), _uuid, SUBSTR(str, colon));
    # find next substring to replace
    SET comma = LOCATE(',', str, pos + 1), tilde = LOCATE('~', str, pos + 1);
    SET pos = IF(comma != 0 AND (tilde = 0 OR comma < tilde), comma, tilde);
  UNTIL pos = 0 END REPEAT;
  RETURN str;
END|

# convert strings like '01010101-0101-0101-0101-010101010101:4-5,
# 97979797-9797-9797-9797-979797979797:1'
# to '1:4-5,97:1'
CREATE FUNCTION UUID_TO_NUMBER(str TEXT(10000))
RETURNS TEXT(10000)
BEGIN
  DECLARE pos INT DEFAULT 0;       # position before next UUID in str
  DECLARE colon INT;               # position of first ':' after pos in str
  DECLARE _uuid TEXT(37);          # UUID between ',' and ':'
  DECLARE n TEXT(5);               # the two digits that are repeated in UUID
  DECLARE comma INT;               # position of next ',' after pos
  DECLARE tilde INT;               # position of next '~' after pos
  IF str = '' or str IS NULL THEN
    RETURN str;
  END IF;
  IF SUBSTR(str, 1, 1) = '~' THEN
    SET pos = 1;
  END IF;
  # trim newlines
  SET str = REPLACE(str, '\n', '');
  REPEAT
    # find end of substring of the form ",uuid:"
    SET colon = LOCATE(':', str, pos + 1);
    # get the uuid
    SET _uuid = SUBSTR(str, pos + 1, colon - pos - 1);
    IF _uuid = @@GLOBAL.SERVER_UUID THEN
      # strip server_uuid from string. make sure we dont strip ~
      # before or after server_uuid.
      SET comma = LOCATE(',', str, pos + 1), tilde = LOCATE('~', str, pos + 1);
      IF comma != 0 AND (tilde = 0 OR tilde > comma) THEN
        SET str = CONCAT(SUBSTR(str, 1, pos), SUBSTR(str, comma + 1));
      ELSEIF tilde != 0 THEN
        SET str = CONCAT(SUBSTR(str, 1, pos - 1), SUBSTR(str, tilde));
      ELSE
        SET str = SUBSTR(str, 1, pos - 1);
      END IF;
    ELSE
      # get the number that repeats in UUID and remove leading zero
      SET n = SUBSTR(str, pos + 1, 2);
      IF SUBSTR(n, 1, 1) = '0' THEN
        SET n = SUBSTR(n, 2, 1);
      END IF;
      # replace UUID by number
      SET str = CONCAT(SUBSTR(str, 1, pos), n, SUBSTR(str, colon));
    END IF;
    # find next substring
    SET comma = LOCATE(',', str, pos + 1), tilde = LOCATE('~', str, pos + 1);
    SET pos = IF(comma != 0 AND (tilde = 0 OR comma < tilde), comma, tilde);
  UNTIL pos = 0 END REPEAT;
  RETURN str;
END|

--delimiter ;

CREATE table t (a INT) ENGINE = InnoDB;

--echo ######## Specify test cases ########

# This table contains specifications of all tests we are going to
# perform. It contains the values of the GTID_NEXT* variables, a
# statement, and the expected outcome in terms of
# @@[SESSION|GLOBAL].GTID_[ENDED|PARTIAL]_GROUPS.
# Columns:
#  id
#    autoinc PK
#  stmt_type
#    Code specifying what type of statement to execute. Can be one of
#    "CRE" (CREATE TABLE), "INS" (INSERT), "BEG" (BEGIN), "COM"
#    (COMMIT), "ROL" (ROLLBACK).
#  next
#    Value of GTID_NEXT before executing the statement.
#    For convenience, you can use two-digit integers instead of UUIDs:
#    e.g., 37 is an abbreviation for
#    37373737-3737-3737-3737-373737373737.
#    The value 0 means that the previous value is retained and no SET
#    statement is generate for GTID_NEXT.
#  next_list
#    Value of GTID_NEXT_LIST before executing the statement. UUIDs
#    can be abbreviated as for 'next'.
#    The value 0 means that the previous value is retained and no SET
#    statement is generate for GTID_NEXT_LIST.
#  [global|session]_done
#    Specifies how @@[SESSION|GLOBAL].GTID_DONE is expected to change
#    after the statement.  This has the form of a group_set containing
#    the groups that were added by the statement.  If the group_set
#    begins with '~', the groups are expected to be removed instead.
#  error
#    Expected errno for the statement, or 0 if the statement is
#    expected to succeed.
CREATE TABLE stmts (
  id INT PRIMARY KEY NOT NULL,
  stmt_type TEXT(10) NOT NULL,
  next TEXT(100),
  next_list TEXT(10000),
  global_done TEXT(10000) NOT NULL,
  session_done TEXT(10000) NOT NULL,
  error INT NOT NULL);

eval INSERT INTO stmts VALUES
#  id  STMT  NEXT  NEXT_LIST  GLOBAL    SESSION     S_PART   ERR
  # DML statements
  (100,'AC1', 0,    0,        '',       '',       0)
 ,(101,'INS','1:1', 0,        '1:1',    '',       0)
 ,(102,'INS','1:3', 0,        '1:3',    '',       0)
  # skipped DML statements
 ,(110,'INS','1:1', 0,        '',       '',       0)
 ,(111,'INS','1:3', 0,        '',       '',       0)
  # DDL statements
 ,(120,'CRE','3:4', 0,        '3:4',    '',       0)
 ,(121,'CRE','3:1', 0,        '3:1',    '',       0)
  # skipped DDL statements
 ,(130,'CRE','3:4', 0,        '',       '',       0)
 ,(131,'CRE','3:1', 0,        '',       '',       0)
  # simple transaction
 ,(140,'BEG','5:1', 0,        '',       '5:1',    0)
 ,(141,'INS', 0,    0,        '',       '',       0)
 ,(142,'INS', 0,    0,        '',       '',       0)
 ,(143,'COM', 0,    0,        '5:1',    '~5:1',   0)
  # skipped simple transaction
 ,(150,'BEG','',    0,        '',       '',       0)
 ,(151,'INS', 0,    0,        '',       '',       0)
 ,(152,'INS', 0,    0,        '',       '',       0)
 ,(153,'COM', 0,    0,        '',       '',       0)
  # empty group
 ,(160,'COM','7:1', 0,        '7:2',    '',       0)
  # skipped empty group
 ,(170,'COM','8:1', 0,        '',       '',       0)
  # transaction with DDL
 ,(180,'BEG','9:1', 0,        '',       '9:1',    0)
 ,(181,'INS', 0,    0,        '',       '',       0)
 ,(182,'CRE', 0,    0,        '9:1',    '',       0)
 ,(183,'COM', 0,    0,        '9:1',    '',       0)
  # skipped transaction with DDL
 ,(190,'BEG','4:1', 0,        '1:2',    '',       0)
 ,(191,'INS','4:1', 0,        '1:2',    '',       0)
 ,(192,'CRE','4:1', 0,        '1:2',    '',       0)
 ,(193,'COM','4:1', 0,        '1:2',    '',       0)
;

--echo ######## Test ########

--let $id= 1
--let $max_id= `SELECT MAX(id) FROM stmts`
while ($id <= $max_id)
{
  while (`SELECT COUNT(*) = 0 FROM stmts WHERE id = $id`)
  {
    --inc $id
  }
  --echo ======== row-id = $id ========
  --let $stmt_type= `SELECT stmt_type FROM stmts WHERE id = $id`
  let $set_stmt= `
    SELECT CONCAT_WS(', ',
      IF(next = 0, NULL, CONCAT('GTID_NEXT=', QUOTE(NUMBER_TO_UUID(next)))),
      IF(next_list = 0, NULL, CONCAT('GTID_NEXT_LIST=',
                                     QUOTE(NUMBER_TO_UUID(next_list)))))
      FROM stmts WHERE id = $id`;

  if ($stmt_type == 'INS')
  {
    --let $stmt= INSERT INTO t VALUES ($id)
  }
  if ($stmt_type == 'CRE')
  {
    --let $stmt= CREATE TABLE t_$id (a INT) ENGINE = InnoDB
    --let $drop_stmt= $drop_stmt DROP TABLE t_$id;
  }
  if ($stmt_type == 'CTS')
  {
    --let $stmt= CREATE TABLE t_$id (a INT) ENGINE = InnoDB SELECT * FROM t;
    --let $drop_stmt= $drop_stmt DROP TABLE t_$id;
  }
  if ($stmt_type == 'BEG')
  {
    --let $stmt= BEGIN
  }
  if ($stmt_type == 'COM')
  {
    --let $stmt= COMMIT
  }
  if ($stmt_type == 'ROL')
  {
    --let $stmt= ROLLBACK
  }
  if ($stmt_type == 'AC0')
  {
    --let $stmt= SET AUTOCOMMIT = 0
  }
  if ($stmt_type == 'AC1')
  {
    --let $stmt= SET AUTOCOMMIT = 1
  }

  --let $error= `SELECT error FROM stmts WHERE id = $id`

  --connection server_1_1

  --let $session_before= `SELECT @@SESSION.GTID_DONE`
  --let $global_before= `SELECT @@GLOBAL.GTID_DONE`
  --echo session='$session_before'
  --echo global='$global_before'

  --echo '$set_stmt'
  if ($set_stmt != '')
  {
    eval SET $set_stmt;
  }
  if ($error != 0)
  {
    --error $error
    eval $stmt;
  }
  if ($error == 0)
  {
    eval $stmt;
  }

  --let $scope= session
  --let $before= $session_before
  --let $i= 0
  while ($i < 2)
  {
    # $after = the value of the $variable now
    --connection server_1_1
    --let $after= `SELECT @@$scope.GTID_DONE`

    --connection default
    --let $_done= _done
    --let $diff= `SELECT NUMBER_TO_UUID($scope$_done) FROM stmts WHERE id = $id`

    # Assert that before + diff = after
    let $assert_text= `
      SELECT CONCAT("@@$scope.GTID_DONE = '",
                    UUID_TO_NUMBER('$before'), "' + '",
                    UUID_TO_NUMBER('$diff'), "' = '",
                    UUID_TO_NUMBER('$after'), "'")`;
    --let $assert_cond= CHECK_GROUP_SET("$before", "$diff", "$after")
    --source include/assert.inc

    --let $scope= global
    --let $before= global_before
    --inc $i
  }

  --inc $id
}

--echo ######## Clean up ########

--eval $drop_stmt
DROP TABLE variables;
DROP TABLE stmts;
DROP TABLE t;
DROP FUNCTION GROUPS_EQUAL;
DROP FUNCTION CHECK_GROUP_SET;
DROP FUNCTION GROUP_DISJOINT_UNION;
DROP FUNCTION NUMBER_TO_UUID;
DROP FUNCTION UUID_TO_NUMBER;

--source include/rpl_end.inc
