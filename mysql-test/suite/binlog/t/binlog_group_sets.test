--source include/have_innodb.inc
--let $rpl_topology= 1
--source include/rpl_init.inc
--connection default

--echo ######## Initialize ########

# Auxiliary table listing all variables that we are going to test.
CREATE TABLE variables (var_id INT PRIMARY KEY, name TEXT(100));
INSERT INTO variables VALUES
 (1, 'session_partial'), (2, 'global_partial'),
 (3, 'session_ended'), (4, 'global_ended');

--delimiter |

# Return nonzero if the two group_sets are equal.
CREATE FUNCTION GROUPS_EQUAL(g1 TEXT(10000), g2 TEXT(10000))
RETURNS INT
BEGIN
  RETURN GROUP_SUBSET(g1, g2) AND GROUP_SUBSET(g2, g1);
END|

# Return true if t1 union t2 = sum, and t1 and t2 are disjoint.
CREATE FUNCTION GROUP_DISJOINT_UNION(t1 TEXT(10000), t2 TEXT(10000), sum TEXT(10000))
RETURNS INT
BEGIN
  RETURN GROUPS_EQUAL(GROUP_SUBTRACT(sum, t1), t2) AND
         GROUPS_EQUAL(GROUP_SUBTRACT(sum, t2), t1);
END|

# Return true if group_set 'new' is obtained by adding 'diff' to 'old'.
CREATE FUNCTION CHECK_GROUP_SET(old TEXT(10000), diff TEXT(10000), new TEXT(10000))
RETURNS INT
BEGIN
  DECLARE tilde_pos INT DEFAULT LOCATE('~', diff);
  DECLARE to_add TEXT(10000);
  DECLARE to_remove TEXT(10000);
  IF tilde_pos != 0 THEN
    SET to_add = SUBSTR(diff, 1, tilde_pos - 1);
    SET to_remove = SUBSTR(diff, tilde_pos + 1);
    RETURN GROUP_SUBSET(to_remove, old) AND
           GROUP_DISJOINT_UNION(GROUP_SUBTRACT(old, to_remove), to_add, new);
  ELSE
    RETURN GROUP_DISJOINT_UNION(old, diff, new);
  END IF;
END|

# convert strings like '1:4-5,97:1' to
# '01010101-0101-0101-0101-010101010101:4-5,97979797-9797-9797-9797-979797979797:1'
CREATE FUNCTION NUMBER_TO_UUID(str TEXT(10000))
RETURNS TEXT(10000)
BEGIN
  DECLARE pos INT DEFAULT 0;# pos. before next number to replace by UUID in str
  DECLARE colon INT;               # position of next ':' after pos in str
  DECLARE n TEXT(3);               # number between comma and colon
  DECLARE nn TEXT(5);              # n, zero-padded to 2 digits, repeated twice
  DECLARE _uuid TEXT(37);          # UUID generated from nn
  DECLARE comma INT;               # position of next ',' after pos
  DECLARE tilde INT;               # position of next '~' after pos
  IF str = '' or str IS NULL THEN
    RETURN str;
  END IF;
  IF SUBSTR(str, 1, 1) = '~' THEN
    SET pos = 1;
  END IF;
  REPEAT
    # find end of number
    SET colon = LOCATE(':', str, pos + 1);
    # get number
    SET n = SUBSTR(str, pos + 1, colon - pos - 1);
    # convert number to uuid
    SET nn = REPEAT(LPAD(n, 2, '0'), 2);
    SET _uuid = CONCAT(nn, nn, '-', nn, '-', nn, '-', nn, '-', nn, nn, nn);
    # replace number by uuid
    SET str = CONCAT(SUBSTR(str, 1, pos), _uuid, SUBSTR(str, colon));
    # find next substring to replace
    SET comma = LOCATE(',', str, pos + 1), tilde = LOCATE('~', str, pos + 1);
    SET pos = IF(comma != 0 AND (tilde = 0 OR comma < tilde), comma, tilde);
  UNTIL pos = 0 END REPEAT;
  RETURN str;
END|

# convert strings like '01010101-0101-0101-0101-010101010101:4-5,
# 97979797-9797-9797-9797-979797979797:1'
# to '1:4-5,97:1'
CREATE FUNCTION UUID_TO_NUMBER(str TEXT(10000))
RETURNS TEXT(10000)
BEGIN
  DECLARE pos INT DEFAULT 0;       # position before next UUID in str
  DECLARE colon INT;               # position of first ':' after pos in str
  DECLARE _uuid TEXT(37);          # UUID between ',' and ':'
  DECLARE n TEXT(5);               # the two digits that are repeated in UUID
  DECLARE comma INT;               # position of next ',' after pos
  DECLARE tilde INT;               # position of next '~' after pos
  IF str = '' or str IS NULL THEN
    RETURN str;
  END IF;
  IF SUBSTR(str, 1, 1) = '~' THEN
    SET pos = 1;
  END IF;
  # trim newlines
  SET str = REPLACE(str, '\n', '');
  REPEAT
    # find end of substring of the form ",uuid:"
    SET colon = LOCATE(':', str, pos + 1);
    # get the uuid
    SET _uuid = SUBSTR(str, pos + 1, colon - pos - 1);
    IF _uuid = @@GLOBAL.SERVER_UUID THEN
      # strip server_uuid from string. make sure we dont strip ~
      # before or after server_uuid.
      SET comma = LOCATE(',', str, pos + 1), tilde = LOCATE('~', str, pos + 1);
      IF comma != 0 AND (tilde = 0 OR tilde > comma) THEN
        SET str = CONCAT(SUBSTR(str, 1, pos), SUBSTR(str, comma + 1));
      ELSEIF tilde != 0 THEN
        SET str = CONCAT(SUBSTR(str, 1, pos - 1), SUBSTR(str, tilde));
      ELSE
        SET str = SUBSTR(str, 1, pos - 1);
      END IF;
    ELSE
      # get the number that repeats in UUID and remove leading zero
      SET n = SUBSTR(str, pos + 1, 2);
      IF SUBSTR(n, 1, 1) = '0' THEN
        SET n = SUBSTR(n, 2, 1);
      END IF;
      # replace UUID by number
      SET str = CONCAT(SUBSTR(str, 1, pos), n, SUBSTR(str, colon));
    END IF;
    # find next substring
    SET comma = LOCATE(',', str, pos + 1), tilde = LOCATE('~', str, pos + 1);
    SET pos = IF(comma != 0 AND (tilde = 0 OR comma < tilde), comma, tilde);
  UNTIL pos = 0 END REPEAT;
  RETURN str;
END|

--delimiter ;

CREATE table t (a INT) ENGINE = InnoDB;

--echo ######## Specify test cases ########

# This table contains specifications of all tests we are going to
# perform. It contains the values of the UGID_NEXT* variables, a
# statement, and the expected outcome in terms of
# @@[SESSION|GLOBAL].UGID_[ENDED|PARTIAL]_GROUPS.
# Columns:
#  id
#    autoinc PK
#  stmt_type
#    Code specifying what type of statement to execute. Can be one of
#    "CRE" (CREATE TABLE), "INS" (INSERT), "BEG" (BEGIN), "COM"
#    (COMMIT), "ROL" (ROLLBACK).
#  next
#    Value of UGID_NEXT before executing the statement.
#    For convenience, you can use two-digit integers instead of UUIDs:
#    e.g., 37 is an abbreviation for
#    37373737-3737-3737-3737-373737373737.
#    The value 0 means that the previous value is retained and no SET
#    statement is generate for UGID_NEXT.
#  next_list
#    Value of UGID_NEXT_LIST before executing the statement. UUIDs
#    can be abbreviated as for 'next'.
#    The value 0 means that the previous value is retained and no SET
#    statement is generate for UGID_NEXT_LIST.
#  flags
#    String containing zero, one, or both of the letters 'C' and 'E'.
#    If C is in the string, UGID_COMMIT is set to 1. If E is in the
#    string, UGID_END is set to 1.
#  [global|session]_[ended|partial]
#    Specifies how @@[SESSION|GLOBAL].UGID_[ENDED|PARTIAL]_GROUPS is
#    expected to change after the statement.  This has the form of a
#    group_set containing the groups that were added by the statement.
#    If the group_set begins with '~', the groups are expected to be
#    removed instead.
#  error
#    Expected errno for the statement, or 0 if the statement is
#    expected to succeed.
CREATE TABLE stmts (
  id INT PRIMARY KEY NOT NULL,
  stmt_type TEXT(10) NOT NULL,
  next TEXT(100),
  next_list TEXT(10000),
  flags TEXT(3) NOT NULL,
  global_ended TEXT(10000) NOT NULL,
  global_partial TEXT(10000) NOT NULL,
  session_ended TEXT(10000) NOT NULL,
  session_partial TEXT(10000) NOT NULL,
  error INT NOT NULL);

eval INSERT INTO stmts VALUES
#  id  STMT  NEXT  NEXT_LIST  FLAGS G_END     G_PART     S_END     S_PART   ERR
  # simple groups
  (10,'CRE','1:1', NULL,     'CE', '1:1',    '',        '',       '',       0)
 ,(11,'INS','1:3', NULL,     'CE', '1:3',    '',        '',       '',       0)
 ,(12,'CRE','1:2', NULL,     'CE', '1:2',    '',        '',       '',       0)
  # split master-super-group over several, interleaved, one-stmt transactions
 ,(20,'INS','2:9', NULL,     'C',  '',       '2:9',     '',       '',       0)
 ,(21,'INS','2:8', NULL,     'C',  '',       '2:8',     '',       '',       0)
 ,(22,'INS','2:8', NULL,     'CE', '2:8',    '~2:8',    '',       '',       0)
 ,(23,'INS','2:9', NULL,     'CE', '2:9',    '~2:9',    '',       '',       0)
  # split master-super-group over several, multi-stmt-transactions
 ,(30,'BEG','3:1', NULL,     '',   '',       '',        '',       '',       0)
 ,(31,'INS', 0,    0,        '',   '',       '',        '',       '3:1',    0)
 ,(32,'INS', 0,    0,        '',   '',       '',        '',       '',       0)
 ,(33,'INS', 0,    0,        'EC', '3:1',    '',        '',       '~3:1',   0)
 ,(34,'COM', 0,    0,        'C',  '',       '',        '',       '',       0)
  # master-super-group containing several groups
 ,(40,'AC0','4:1','4:1-7',   '',   '',       '',        '',       '',       0)
 ,(41,'INS','4:2', 0,        '',   '',       '',        '',       '4:2',    0)
 ,(42,'INS','4:1', 0,        '',   '',       '',        '',       '4:1',    0)
 ,(43,'INS','4:3', 0,        'E',  '',       '',        '4:3',    '',       0)
 ,(44,'INS','4:1', 0,        'E',  '',       '',        '4:1',    '~4:1',   0)
 ,(45,'CRE','4:4', 0,        '',   '4:1:3',  '4:2:4',   '~4:1:3', '~4:2',   0)
 ,(46,'INS','4:5', 0,        '',   '',       '',        '',       '4:5',    0)
 ,(47,'INS','4:4', 0,        'E',  '',       '',        '4:4',    '',       0)
 ,(48,'COM','4:6', 0,        'EC', '4:4:6',  '4:5:7~4:4','~4:4',  '~4:5',   0)
  # master-super-group with implicit pre-commit in the middle
 ,(50,'AC0','5:1','5:1-2',   '',   '',       '',        '',       '',       0)
 ,(51,'INS','5:1', 0,        '',   '',       '',        '',       '5:1',    0)
 ,(52,'CRE','5:2', 0,        'E',  '5:2',    '5:1',     '',       '~5:1',   0)
 ,(53,'INS','5:1', 0,        '',   '',       '',        '',       '5:1',    0)
 ,(54,'INS','5:1', 0,        'EC', '5:1',    '~5:1',    '',       '~5:1',   0)
  # generate dummy subgroups
# todo: COMMIT with empty transaction does not invoke handler, hence nothing written
# ,(61,'INS','6:1','6:1-6',   '',   '',       '',        '',       '6:1',    0)
# ,(62,'COM','6:1', 0,        '',   '',       '6:1',     '',       '~6:1',   0)
# ,(63,'INS','6:2', 0,        '',   '',       '',        '',       '6:2',    0)
# ,(64,'COM','6:2', 0,        'E',  '6:2',    '',        '',       '~6:2',   0)
# ,(65,'COM','6:3', 0,        '',   '',       '',        '',       '',       0)
# ,(66,'COM','6:4', 0,        'E',  '6:4',    '',        '',       '',       0)
# ,(67,'COM','6:1', 0,        'E',  '6:1',    '~6:1',    '',       '',       0)
# ,(68,'COM','6:1', 0,        'C',  '6:5-6',  '',        '',       '',       0)
;

--echo ######## Test ########

--let $id= 1
--let $max_id= `SELECT MAX(id) FROM stmts`
while ($id <= $max_id)
{
  while (`SELECT COUNT(*) = 0 FROM stmts WHERE id = $id`)
  {
    --inc $id
  }
  --echo ======== row-id = $id ========
  --let $stmt_type= `SELECT stmt_type FROM stmts WHERE id = $id`
  let $set_stmt= `
    SELECT CONCAT('SET ',
                  IF(next = 0, '',
                     CONCAT('UGID_NEXT=', QUOTE(NUMBER_TO_UUID(next)), ', ')),
                  IF(next_list = 0, '',
                     CONCAT('UGID_NEXT_LIST=', QUOTE(NUMBER_TO_UUID(next_list)),
                            ', ')),
                  'UGID_END=', IF(LOCATE('E', flags) != 0, 1, 0),
                  ', UGID_COMMIT=', IF(LOCATE('C', flags) != 0, 1, 0))
           FROM stmts WHERE id = $id`;
  if ($stmt_type == 'INS')
  {
    --let $stmt= INSERT INTO t VALUES ($id)
  }
  if ($stmt_type == 'CRE')
  {
    --let $stmt= CREATE TABLE t_$id (a INT) ENGINE = InnoDB
    --let $drop_stmt= $drop_stmt DROP TABLE t_$id;
  }
  if ($stmt_type == 'CTS')
  {
    --let $stmt= CREATE TABLE t_$id (a INT) ENGINE = InnoDB SELECT * FROM t;
    --let $drop_stmt= $drop_stmt DROP TABLE t_$id;
  }
  if ($stmt_type == 'BEG')
  {
    --let $stmt= BEGIN
  }
  if ($stmt_type == 'COM')
  {
    --let $stmt= COMMIT
  }
  if ($stmt_type == 'ROL')
  {
    --let $stmt= ROLLBACK
  }
  if ($stmt_type == 'AC0')
  {
    --let $stmt= SET AUTOCOMMIT = 0
  }
  if ($stmt_type == 'AC1')
  {
    --let $stmt= SET AUTOCOMMIT = 1
  }

  --let $error= `SELECT error FROM stmts WHERE id = $id`

  --connection server_1_1

  let $before_all=
    `SELECT CONCAT_WS('|', @@SESSION.UGID_PARTIAL_GROUPS,
                           @@GLOBAL.UGID_PARTIAL_GROUPS,
                           @@SESSION.UGID_ENDED_GROUPS,
                           @@GLOBAL.UGID_ENDED_GROUPS)`;

  eval $set_stmt;
  #if ($error != 0)
  #{
  #  --error $error
  #  eval $stmt;
  #}
  #if ($error == 0)
  #{
    eval $stmt;
  #}

  --connection default

  #--echo before_all=$before_all;
  --let $var_id= 1
  while ($var_id <= 4)
  {
    # $column = [session|global]_[partial|ended]
    --let $column= `SELECT name FROM variables WHERE var_id = $var_id` 
    # $variable = @@[SESSION|GLOBAL].UGID_[PARTIAL|ENDED]_GROUPS
    --let $variable= `SELECT UCASE(CONCAT('@@', REPLACE('$column', '_', '.UGID_'), '_GROUPS'))`
    # $before = the Nth '|'-separated substring of $before_all
    --let $before= `SELECT SUBSTRING_INDEX(SUBSTRING_INDEX('$before_all', '|', $var_id), '|', -1)`
    # $after = the value of the $variable now
    --connection server_1_1
    --let $after= `SELECT $variable`
    --connection default
    # $diff = expected difference according to the test specification in stmts
    --let $diff= `SELECT NUMBER_TO_UUID($column) FROM stmts WHERE id = $id`

    #--echo var_id=$var_id;
    #--echo column=$column;
    #--echo variable=$variable;
    #--echo before=$before;
    #--echo after=$after;
    #--echo diff=$diff;
    #--echo CURRENT_CONNECTION=$CURRENT_CONNECTION;
    #SELECT @@SESSION.UGID_NEXT, @@SESSION.UGID_NEXT_LIST, @@SESSION.UGID_END, @@SESSION.UGID_COMMIT;
    #SELECT CHECK_GROUP_SET('', '', '');

    # Assert that before + diff = after
    let $assert_text= `
      SELECT CONCAT("$variable = '",
                    UUID_TO_NUMBER('$before'), "' + '",
                    UUID_TO_NUMBER('$diff'), "' = '",
                    UUID_TO_NUMBER('$after'), "'")`;
    --let $assert_cond= CHECK_GROUP_SET("$before", "$diff", "$after")
    --source include/assert.inc
    --inc $var_id
  }

  --inc $id
}

--echo ######## Clean up ########

--eval $drop_stmt
DROP TABLE variables;
DROP TABLE stmts;
DROP TABLE t;
DROP FUNCTION GROUPS_EQUAL;
DROP FUNCTION CHECK_GROUP_SET;
DROP FUNCTION GROUP_DISJOINT_UNION;
DROP FUNCTION NUMBER_TO_UUID;
DROP FUNCTION UUID_TO_NUMBER;

--source include/rpl_end.inc
