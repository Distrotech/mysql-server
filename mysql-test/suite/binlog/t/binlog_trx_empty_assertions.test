# ==== Purpose ====
#
# When GTID_NEXT=='SID:GNO', and a statement begins to execute, we
# acquire ownership of the GTID.  In order to correctly release the
# ownership when the statement ends, we register the binlog_handler
# (because that's the only way to know when the transaction ends).
#
# It is a little bit unorthodox to register a handler so early.  Other
# handlers are typically registered much later; for instance, the
# binlog_handler would otherwise be registered only when the statement
# is written to the binary log.  Therefore, there are many places in
# the code that assert that there is no handler registered, like:
#
#   DBUG_ASSERT(thd->transaction.stmt.is_empty())
#
# To avoid that such an assertion is raised when GTID_NEXT=='SID:GNO',
# we changed all such assertions in WL#3584, so they are now something
# like:
#
#   DBUG_ASSERT(thd->transaction.stmt.is_empty() ||
#               thd->get_gtid_next_list() != NULL ||
#               thd->variables.gtid_next.type == GTID_GROUP);
#
# This test case verifies that, indeed, none of those assertions is
# raised after WL#3584.
#
# ==== Method ====
#
# Execute statements where the assertion would fail, if the two extra
# disjunctions were not added.
#
# ==== References ====
#
# WL#3584: Global Transaction Identifiers

# This test does not depend on binlog_format, so we force statement in
# order to only execute it once.
--source include/have_binlog_format_statement.inc

--echo ==== Initialize ====

--let $ida= aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa
CREATE TABLE t1 (a INT);

--echo ==== Test ====

--echo ---- Prepared statements ----

# Case 1.
# Covers assertions in:
#  - close_thread_tables
#  - Prepared_statement::prepare(const char *, uint)
eval SET GTID_NEXT = '$ida:1';
PREPARE prep FROM 'INSERT INTO t1 VALUES (1)';

# Case 2.
# Covers assertions in:
#  - mysql_execute_command (beginning)
eval SET GTID_NEXT = '$ida:2';
EXECUTE prep;

--echo ---- Stored procedures ----

# Case 3.
# Covers assertions in:
#  - mysql_execute_command (case SQLCOM_CREATE_PROCEDURE)
eval SET GTID_NEXT = '$ida:3';
--eval CREATE PROCEDURE proc () BEGIN INSERT INTO t1 VALUES (1); END

# Case 4.
# Covers assertions in:
eval SET GTID_NEXT = '$ida:4';
CALL proc();

# Case 5.
# Covers assertions in:
#  - mysql_execute_command (case SQLCOM_DROP_PROCEDURE)
eval SET GTID_NEXT = '$ida:5';
DROP PROCEDURE proc;

# Case 6.
# Covers assertions in:
#  - trans_check(THD*)
eval SET GTID_NEXT = '$ida:6';
LOCK TABLES t1 READ;

# Case 7.
# Covers assertions in:
#  - Locked_tables_list::unlock_locked_tables(THD *)
eval SET GTID_NEXT = '$ida:7';
UNLOCK TABLES;

# Case 8.
# Covers assertions in:
#  - close_mysql_tables(THD *)
eval SET GTID_NEXT = '$ida:10';
FLUSH PRIVILEGES;

--echo ==== Clean up ====

SET GTID_NEXT = 'AUTOMATIC';
DEALLOCATE PREPARE prep;
DROP TABLE t1;
