# This is the test for Metrics Monitor Table feature.
# Test the metrics monitor system's control system
# and counter accuracy.

--source include/have_innodb.inc

select * from information_schema.innodb_metrics;

# Test turn on/off the monitor counter  with "all" option
# By default, they will be off
select name, status from information_schema.innodb_metrics;

# Turn on all monitor counters
set global innodb_enable_monitor_counter = all;

# status should all change to "started"
select name, status from information_schema.innodb_metrics;

# Test wrong argument to the global configure option
--error ER_WRONG_VALUE_FOR_VAR
set global innodb_enable_monitor_counter = aaa;

# We require a valid monitor counter/module name. There is no default
# counter name or module. A warning will be printed asking user to
# specify a valid counter name.
#--disable_warnings
#set global innodb_enable_monitor_counter = default;
#--enable_warnings

# Turn off all monitor counters, option name should be case
# insensitive
set global innodb_disable_monitor_counter = All;

# status should all change to "stopped"
select name, status from information_schema.innodb_metrics;

# Reset all counter values
set global innodb_reset_all_monitor_counter = all;

# count should all change to 0
select name, count, status from information_schema.innodb_metrics;

# Test wildcard match, turn on all counters contain string "lock"
set  global innodb_enable_monitor_counter = "%lock%";

# All lock related counter should be enabled
select name, status from information_schema.innodb_metrics
where name like "%lock%";

# Disable them
set  global innodb_disable_monitor_counter = "%lock%";

# All lock related counter should be disabled
select name, status from information_schema.innodb_metrics
where name like "%lock%";

# No match for "%lock*"
--error ER_WRONG_VALUE_FOR_VAR
set global innodb_enable_monitor_counter = "%lock*";

# All counters will be turned on with wildcard match string with all "%"
set global innodb_enable_monitor_counter="%%%%%%%%%%%%%%%%%%%%%%%%%%%";

select name, status from information_schema.innodb_metrics;

# Turn off all counters
set global innodb_disable_monitor_counter="%%%%%";

select name, status from information_schema.innodb_metrics;

# One more round testing. All counters will be turned on with
# single wildcard character "%"
set global innodb_enable_monitor_counter="%";

select name, status from information_schema.innodb_metrics;

# Turn off all the counters with "%_%"
set global innodb_disable_monitor_counter="%_%";

select name, status from information_schema.innodb_metrics;

# Turn on all counters start with "log"
set global innodb_enable_monitor_counter="log%%%%";

select name, status from information_schema.innodb_metrics;

# Turn on counters "os_num_fsync" with wildcard match "os_%m_fs_nc", "_"
# is single character wildcard match word
set global innodb_enable_monitor_counter="os_%m_fs_nc";

# Turn on counters whose name contains "os" and "pending" with
# wildcard match "os%pending%"
set global innodb_enable_monitor_counter="os%pending%";

select name, status from information_schema.innodb_metrics
where name like "os%";

# Empty string is an invalid option
--error ER_WRONG_VALUE_FOR_VAR
set global innodb_enable_monitor_counter="";

--error ER_WRONG_VALUE_FOR_VAR
set global innodb_enable_monitor_counter="_";

# Only turn on "table_open" counter
set global innodb_enable_monitor_counter = metadata_table_opened;

# Create a new table to test "metadata_table_opened" counter
create table monitor_test(col int) engine = innodb;

# This will open the monitor_test table
select * from monitor_test;

# "metadata_table_opened" should increment by 1
select name, max_count, min_count, count,
	max_count_since_reset, min_count_since_reset, count_since_reset, status
from information_schema.innodb_metrics
where name = "metadata_table_opened";

# Reset the counter value while counter is still on (started)
# This will reset value "count_since_reset" but not
# "count"
set global innodb_reset_monitor_counter = metadata_table_opened;

select name, max_count, min_count, count,
	max_count_since_reset, min_count_since_reset, count_since_reset, status
from information_schema.innodb_metrics
where name = "metadata_table_opened";

# re-create table again to increment "metadata_table_opened" again
drop table monitor_test;

# Create a new table to test "metadata_table_opened" counter
create table monitor_test(col int) engine = innodb;

select * from monitor_test;

# "metadata_table_opened" should increment
select name, max_count, min_count, count,
	max_count_since_reset, min_count_since_reset, count_since_reset, status
from information_schema.innodb_metrics
where name = "metadata_table_opened";

# Cannot reset all monitor value while the counter is on
set global innodb_reset_all_monitor_counter = metadata_table_opened;

select name, max_count, min_count, count,
	max_count_since_reset, min_count_since_reset, count_since_reset, status
from information_schema.innodb_metrics
where name = "metadata_table_opened";

# Turn off the counter "metadata_table_opened"
set global innodb_disable_monitor_counter = metadata_table_opened;

# Reset the counter value while counter is off (stopped)
set global innodb_reset_monitor_counter = metadata_table_opened;

select name, max_count, min_count, count,
	max_count_since_reset, min_count_since_reset, count_since_reset, status
from information_schema.innodb_metrics
where name = "metadata_table_opened";

# re-create table again. Since monitor is off, "metadata_table_opened"
# should not be incremented
drop table monitor_test;

# Create a new table to test "metadata_table_opened" counter
create table monitor_test(col int) engine = innodb;

# "metadata_table_opened" should increment
select * from monitor_test;

select name, max_count, min_count, count,
	max_count_since_reset, min_count_since_reset, count_since_reset, status
from information_schema.innodb_metrics
where name = "metadata_table_opened";

# Reset all the counters, include those counter *_since_start
set global innodb_reset_all_monitor_counter = metadata_table_opened;

select name, max_count, min_count, count,
	max_count_since_reset, min_count_since_reset, count_since_reset, status
from information_schema.innodb_metrics
where name = "metadata_table_opened";

# Turn on "table_open" counter again
set global innodb_enable_monitor_counter = metadata_table_opened;

# Test metadata_table_opened again to see if it is working correctly
# after above round of turning on/off/reset
drop table monitor_test;

# Create a new table to test "metadata_table_opened" counter
create table monitor_test(col int) engine = innodb;

select * from monitor_test;

# "metadata_table_opened" should increment
select name, max_count, min_count, count,
	max_count_since_reset, min_count_since_reset, count_since_reset, status
from information_schema.innodb_metrics
where name = "metadata_table_opened";

# Test counter "metadata_table_closed", create index will close the old handle
set global innodb_enable_monitor_counter = metadata_table_closed;

create index idx on monitor_test(col);

select name, max_count, min_count, count,
	max_count_since_reset, min_count_since_reset, count_since_reset, status
from information_schema.innodb_metrics
where name = "metadata_table_closed";

select name, max_count, min_count, count,
	max_count_since_reset, min_count_since_reset, count_since_reset, status
from information_schema.innodb_metrics
where name like "metadata%";

# Reset counters only in "module_metadata" module
set global innodb_disable_monitor_counter = module_metadata;

set global innodb_reset_monitor_counter = module_metadata;

select name, max_count, min_count, count,
	max_count_since_reset, min_count_since_reset, count_since_reset, status
from information_schema.innodb_metrics
where name like "metadata%";

set global innodb_reset_all_monitor_counter = module_metadata;

select name, max_count, min_count, count,
	max_count_since_reset, min_count_since_reset, count_since_reset, status
from information_schema.innodb_metrics
where name like "metadata%";

# Test Transaction Module
set global innodb_enable_monitor_counter = module_trx;

begin;
insert into monitor_test values(9);
commit;

begin;
insert into monitor_test values(9);
rollback;

select name, max_count, min_count, count,
	max_count_since_reset, min_count_since_reset, count_since_reset, status
from information_schema.innodb_metrics
where name like "trx_num_abort" or name like "trx_active_trx";

set global innodb_disable_monitor_counter = module_trx;

# Test DML Module
set global innodb_enable_monitor_counter = module_dml;

insert into monitor_test values(9);

update monitor_test set col = 10 where col = 9;

select name, max_count, min_count, count,
	max_count_since_reset, min_count_since_reset, count_since_reset, status
from information_schema.innodb_metrics
where name like "dml%";

delete from monitor_test;

select name, max_count, min_count, count,
	max_count_since_reset, min_count_since_reset, count_since_reset, status
	from information_schema.innodb_metrics
	where name like "dml%";

# test reset counter while the counter is on
set global innodb_reset_monitor_counter =  module_dml;

select name, max_count, min_count, count,
	max_count_since_reset, min_count_since_reset, count_since_reset, status
from information_schema.innodb_metrics
where name like "dml%";

# insert/delete some rows after the reset
insert into monitor_test values(9);
insert into monitor_test values(1);

delete from monitor_test;

select name, max_count, min_count, count,
	max_count_since_reset, min_count_since_reset, count_since_reset, status
from information_schema.innodb_metrics
where name like "dml%";

# We do not allow reset_all while the counter is on, nothing
# should be reset here
set global innodb_reset_all_monitor_counter  =  module_dml;

select name, max_count, min_count, count,
	max_count_since_reset, min_count_since_reset, count_since_reset, status
from information_schema.innodb_metrics
where name like "dml%";

# Turn off the counter
set global innodb_disable_monitor_counter = module_dml;

select name, max_count, min_count, count,
	max_count_since_reset, min_count_since_reset, count_since_reset, status
from information_schema.innodb_metrics
where name like "dml%";

# Reset all counter values
set global innodb_reset_all_monitor_counter  = module_dml;

select name, max_count, min_count, count,
	max_count_since_reset, min_count_since_reset, count_since_reset, status
from information_schema.innodb_metrics
where name like "dml%";

# Open individual counter "dml_num_inserts"
set global innodb_enable_monitor_counter = dml_num_inserts;

insert into monitor_test values(9);
insert into monitor_test values(1);

delete from monitor_test;

# Only counter "dml_num_inserts" should be updated
select name, max_count, min_count, count,
	max_count_since_reset, min_count_since_reset, count_since_reset, status
from information_schema.innodb_metrics
where name like "dml%";

set global innodb_disable_monitor_counter = module_dml;

drop table monitor_test;

set global innodb_enable_monitor_counter = fil_system_num_open_file;

select name, max_count, min_count, count,
       max_count_since_reset, min_count_since_reset, count_since_reset, status
from information_schema.innodb_metrics
where name like "fil_system_num_open_file";

set global innodb_disable_monitor_counter = fil_system_num_open_file;

-- disable_warnings
set global innodb_enable_monitor_counter = default;
set global innodb_disable_monitor_counter = default;
set global innodb_reset_monitor_counter = default;
set global innodb_reset_all_monitor_counter = default;
-- enable_warnings
