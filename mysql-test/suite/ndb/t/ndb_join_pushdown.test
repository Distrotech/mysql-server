-- source include/have_ndb.inc

--disable_warnings
DROP TABLE IF EXISTS t1,t2,t3,t4;
--enable_warnings

set @save_ndb_join_pushdown = @@session.ndb_join_pushdown;
set ndb_join_pushdown = on;

CREATE TABLE t1 (
  a int NOT NULL,
  b int NOT NULL,
  c int NOT NULL,
  d int NOT NULL,
  PRIMARY KEY (`a`,`b`)
) ENGINE=ndbcluster;

insert into t1 values
(1,1,1,1), (2,2,2,2), (3,3,3,3), (4,4,4,4),
(1,2,5,1), (1,3,1,2), (1,4,2,3),
(2,1,3,4), (2,3,4,5), (2,4,5,1),
(3,1,1,2), (3,2,2,3), (3,4,3,4),
(4,1,4,5), (4,2,5,1), (4,3,1,2);

explain
select *
from t1
join t1 as t2 on t2.a = t1.b and t2.b = t1.c;
--sorted_result
select *
from t1
join t1 as t2 on t2.a = t1.b and t2.b = t1.c;

explain
select *
from t1
left join t1 as t2 on t2.a = t1.b and t2.b = t1.c;
--sorted_result
select *
from t1
left join t1 as t2 on t2.a = t1.b and t2.b = t1.c;

explain
select *
from t1
join t1 as t2 on t2.a = t1.b and t2.b = t1.c
join t1 as t3 on t3.a = t2.a and t3.b = t2.b;
--sorted_result
select *
from t1
join t1 as t2 on t2.a = t1.b and t2.b = t1.c
join t1 as t3 on t3.a = t2.a and t3.b = t2.b;

explain
select *
from t1
join t1 as t2 on t2.a = t1.b and t2.b = t1.c
join t1 as t3 on t3.a = t2.a and t3.b = t2.b;
--sorted_result
select *
from t1
join t1 as t2 on t2.a = t1.b and t2.b = t1.c
join t1 as t3 on t3.a = t2.a and t3.b = t2.b;

explain
select *
from t1
join t1 as t2 on t2.a = t1.b and t2.b = t1.c
left join t1 as t3 on t3.a = t2.a and t3.b = t2.b;
--sorted_result
select *
from t1
join t1 as t2 on t2.a = t1.b and t2.b = t1.c
left join t1 as t3 on t3.a = t2.a and t3.b = t2.b;

explain
select *
from t1
left join t1 as t2 on t2.a = t1.b and t2.b = t1.c
left join t1 as t3 on t3.a = t2.a and t3.b = t2.b;
--sorted_result
select *
from t1
left join t1 as t2 on t2.a = t1.b and t2.b = t1.c
left join t1 as t3 on t3.a = t2.a and t3.b = t2.b;

set ndb_join_pushdown=on;
explain
select *
from t1
join t1 as t2 on t2.a = t1.c and t2.b = t1.d
where t1.a = 2 and t1.b = 3;
select *
from t1
join t1 as t2 on t2.a = t1.c and t2.b = t1.d
where t1.a = 2 and t1.b = 3;

explain
select *
from t1
left join t1 as t2 on t2.a = t1.c and t2.b = t1.d
where t1.a = 2 and t1.b = 3;
select *
from t1
left join t1 as t2 on t2.a = t1.c and t2.b = t1.d
where t1.a = 2 and t1.b = 3;

set ndb_join_pushdown=off;
explain
select *
from t1
join t1 as t2 on t2.a = t1.c and t2.b = t1.d
where t1.a = 2 and t1.b = 3;
select *
from t1
join t1 as t2 on t2.a = t1.c and t2.b = t1.d
where t1.a = 2 and t1.b = 3;

explain
select *
from t1
left join t1 as t2 on t2.a = t1.c and t2.b = t1.d
where t1.a = 2 and t1.b = 3;
select *
from t1
left join t1 as t2 on t2.a = t1.c and t2.b = t1.d
where t1.a = 2 and t1.b = 3;

set ndb_join_pushdown=on;
explain
select *
from t1
join t1 as t2 on t2.a = t1.c and t2.b = t1.d
where t1.a = 1 and t1.b = 1;
select *
from t1
join t1 as t2 on t2.a = t1.c and t2.b = t1.d
where t1.a = 1 and t1.b = 1;

explain
select *
from t1
left join t1 as t2 on t2.a = t1.c and t2.b = t1.d
where t1.a = 1 and t1.b = 1;
select *
from t1
left join t1 as t2 on t2.a = t1.c and t2.b = t1.d
where t1.a = 1 and t1.b = 1;

set ndb_join_pushdown=off;
explain
select *
from t1
join t1 as t2 on t2.a = t1.c and t2.b = t1.d
where t1.a = 1 and t1.b = 1;
select *
from t1
join t1 as t2 on t2.a = t1.c and t2.b = t1.d
where t1.a = 1 and t1.b = 1;

explain
select *
from t1
left join t1 as t2 on t2.a = t1.c and t2.b = t1.d
where t1.a = 1 and t1.b = 1;
select *
from t1
left join t1 as t2 on t2.a = t1.c and t2.b = t1.d
where t1.a = 1 and t1.b = 1;


#
# Test index scan w/ equal-bounds (low == high)
# NOTE: There is temp restriction of not allowing ordered index scans to be pushed.
# SQL stmt. are therefore written with pushable JT_REFs from table 2 -> 
#
set ndb_join_pushdown=on;
explain
select *
from t1
join t1 as t2 on t2.a = t1.c
join t1 as t3 on t3.a = t2.c and t3.b = t2.d
where t1.a = 1 and t1.b = 1;
--sorted_result
select *
from t1
join t1 as t2 on t2.a = t1.c
join t1 as t3 on t3.a = t2.c and t3.b = t2.d
where t1.a = 1 and t1.b = 1;

explain
select *
from t1
left join t1 as t2 on t2.a = t1.c
left join t1 as t3 on t3.a = t2.c and t3.b = t2.d
where t1.a = 1 and t1.b = 1;
--sorted_result
select *
from t1
left join t1 as t2 on t2.a = t1.c
left join t1 as t3 on t3.a = t2.c and t3.b = t2.d
where t1.a = 1 and t1.b = 1;

set ndb_join_pushdown=off;
explain
select *
from t1
join t1 as t2 on t2.a = t1.c
join t1 as t3 on t3.a = t2.c and t3.b = t2.d
where t1.a = 1 and t1.b = 1;
--sorted_result
select *
from t1
join t1 as t2 on t2.a = t1.c
join t1 as t3 on t3.a = t2.c and t3.b = t2.d
where t1.a = 1 and t1.b = 1;

explain
select *
from t1
left join t1 as t2 on t2.a = t1.c
left join t1 as t3 on t3.a = t2.c and t3.b = t2.d
where t1.a = 1 and t1.b = 1;
--sorted_result
select *
from t1
left join t1 as t2 on t2.a = t1.c
left join t1 as t3 on t3.a = t2.c and t3.b = t2.d
where t1.a = 1 and t1.b = 1;


# Test a combination of pushed table scan (x, y)
#  & pushed EQ-bound (indexScan) (z, t1)
# This used to give incorrect results with random result for last table (t1)
set ndb_join_pushdown=on;
explain 
  select * from t1 x, t1 y, t1 z, t1 where 
    y.a=x.d and y.b=x.b and 
    z.a=y.d and 
    t1.a = z.d and t1.b=z.b;
--sorted_result
  select * from t1 x, t1 y, t1 z, t1 where 
    y.a=x.d and y.b=x.b and 
    z.a=y.d and 
    t1.a = z.d and t1.b=z.b;

# Pushed scanIndex() with (multi-)range:
explain 
  select * from t1 x, t1 y where
    x.a <= 2 and
    y.a=x.d and y.b=x.b;
--sorted_result
  select * from t1 x, t1 y where
    x.a <= 2 and
    y.a=x.d and y.b=x.b;

explain 
  select * from t1 x, t1 y where
    (x.a <= 2 or x.a > 3) and
    y.a=x.d and y.b=x.b;
--sorted_result
  select * from t1 x, t1 y where
    (x.a <= 2 or x.a > 3) and
    y.a=x.d and y.b=x.b;

# 'open' range:
explain 
  select * from t1 x, t1 y where
    (x.a >= 2 or x.a < 3) and
    y.a=x.d and y.b=x.b;
--sorted_result
  select * from t1 x, t1 y where
    (x.a >= 2 or x.a < 3) and
    y.a=x.d and y.b=x.b;

# Combination of range and 'in' list
explain 
  select * from t1 x, t1 y where
    (x.a <= 2 or x.a in (0,5,4)) and
    y.a=x.d and y.b=x.b;
--sorted_result
  select * from t1 x, t1 y where
    (x.a <= 2 or x.a in (0,5,4)) and
    y.a=x.d and y.b=x.b;

# Combination of range and 'in' list with exact match
# NOTE: Due to simplification in pushed mrr, exact matches are also
#       executed as range scans
explain 
  select * from t1 x, t1 y where
    (x.a <= 2 or (x.a,x.b) in ((0,0),(5,0),(4,3))) and
    y.a=x.d and y.b=x.b;
--sorted_result
  select * from t1 x, t1 y where
    (x.a <= 2 or (x.a,x.b) in ((0,0),(5,0),(4,3))) and
    y.a=x.d and y.b=x.b;


set ndb_join_pushdown=on;

drop table t1;

create table t1 (a int, b int, primary key(a)) engine = ndb;
insert into t1 values (0x1f, 0x2f);
insert into t1 values (0x2f, 0x3f);
insert into t1 values (0x3f, 0x1f);

create table t2 (c int, d int, primary key(c)) engine = ndb;
insert into t2 values (0x1f, 0x2f);
insert into t2 values (0x2f, 0x3f);
insert into t2 values (0x3f, 0x1f);

create table t3 (a3 int, b3 int, c3 int not null, d3 int not null,
 primary key(a3, b3)) engine = ndb;
insert into t3 values (0x1f, 0x2f, 1, 0x1f);
insert into t3 values (0x2f, 0x3f, 2, 0x2f);
insert into t3 values (0x3f, 0x1f, 3, 0x3f);

explain
select * from t3 x, t3 y, t1 where y.a3=x.d3 and y.b3=x.b3 and t1.a = y.d3;
--sorted_result
select * from t3 x, t3 y, t1 where y.a3=x.d3 and y.b3=x.b3 and t1.a = y.d3;

explain
select *
from t3 x, t3 y, t3 z, t3 z2, t1
where y.a3=x.d3 and y.b3=x.b3 and
      z.a3=y.d3 and z.b3=y.b3 and
      z2.a3=z.d3 and z2.b3=z.b3 and
      t1.a = z2.d3;
--sorted_result
select *
from t3 x, t3 y, t3 z, t3 z2, t1
where y.a3=x.d3 and y.b3=x.b3 and
      z.a3=y.d3 and z.b3=y.b3 and
      z2.a3=z.d3 and z2.b3=z.b3 and
      t1.a = z2.d3;

# Tests usage of unique index
create unique index t3_d3 on t3(d3); 
commit;

# Use an unique key to lookup root in pushed join:
explain
  select * from t3 x, t3 y where x.d3=31 and y.a3=x.d3 and y.b3=x.b3;
  select * from t3 x, t3 y where x.d3=31 and y.a3=x.d3 and y.b3=x.b3;

# Use an unique key to lookup joined child tables
explain
  select * from t1 x, t3 y where y.d3=x.b;
--sorted_result
  select * from t1 x, t3 y where y.d3=x.b;

# Unique index used both for root lookup and child linkage.
explain
  select * from t3 x, t3 y where x.d3=31 and y.d3=x.b3;
  select * from t3 x, t3 y where x.d3=31 and y.d3=x.b3;

# Any ordered index may also be used to scan a 'range'
explain
  select * from t3 x, t3 y where x.d3>=31 and y.d3=x.b3;
--sorted_result
  select * from t3 x, t3 y where x.d3>=31 and y.d3=x.b3;


# handle "null" key
insert into t1 values (0x4f, null);
--sorted_result
select * from t1 left join t1 as t2 on t2.a = t1.b;

drop table t1,t2,t3;

# test index scan disguised as JT_ALL
create table t1 (a int primary key, b int, c int, index(b,c)) engine = ndb;
insert into t1 values (1,null, 2);
insert into t1 values (2,1, null);
insert into t1 values (3,2,2);
insert into t1 values (4,null, 2);
insert into t1 values (5,1, null);
insert into t1 values (6,2,2);
analyze table t1; # needed to get row-count into table :(

set ndb_join_pushdown=off;

--sorted_result
select *
from t1
join t1 as t2 on (t2.b = t1.b or t2.b = t1.a)
join t1 as t3 on t3.a = t2.a
join t1 as t4 on t4.a = t3.b
;

set ndb_join_pushdown=on;

--sorted_result
select *
from t1
join t1 as t2 on (t2.b = t1.b or t2.b = t1.a)
join t1 as t3 on t3.a = t2.a
join t1 as t4 on t4.a = t3.b
;

drop table t1;

# mixed engines

create table t1 (a int primary key, b int) engine = ndb;
create table t2 (a int primary key, b int) engine = myisam;
insert into t1 values(1,1), (2,2), (3,3), (4,4);
insert into t2 values(1,1), (2,2), (3,3), (4,4);

explain
select * from t1, t2, t1 as t3
where t2.a = t1.b
  and t3.a = t2.b;
--sorted_result
select * from t1, t2, t1 as t3
where t2.a = t1.b
  and t3.a = t2.b;

drop table t1, t2;

set ndb_join_pushdown = @save_ndb_join_pushdown;

