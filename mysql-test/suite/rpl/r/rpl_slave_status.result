stop slave;
drop table if exists t1,t2,t3,t4,t5,t6,t7,t8,t9;
reset master;
reset slave;
drop table if exists t1,t2,t3,t4,t5,t6,t7,t8,t9;
start slave;
==== Create new replication user ====
[on master]
GRANT REPLICATION SLAVE ON *.* TO rpl@127.0.0.1 IDENTIFIED BY 'rpl';
[on slave]
include/stop_slave.inc
CHANGE MASTER TO master_user='rpl', master_password='rpl';
include/start_slave.inc
==== Do replication as new user ====
[on master]
CREATE TABLE t1 (n INT);
INSERT INTO t1 VALUES (1);
[on slave]
SELECT * FROM t1;
n
1
==== Delete new replication user ====
[on master]
DROP USER rpl@127.0.0.1;
FLUSH PRIVILEGES;
[on slave]
==== Restart slave without privileges =====
include/stop_slave.inc
START SLAVE;
==== Verify that Slave_IO_Running = No ====
Slave_IO_Running = No (should be No)
==== Cleanup ====
[on master]
DROP TABLE t1;
[on slave]
include/stop_slave.inc
CHANGE MASTER TO master_user='root', master_password='';
include/start_slave.inc

# Bug#47699 rpl.rpl_backup_block fails sporadically
#
# START SLAVE released the lock and returned before it cleared the error,
# so there is a possibility that Slave_SQL_Error is not 0.
[on slave]
CALL mtr.add_suppression("Slave: Table 't1' already exists Error_code: 1050");
# The statement makes SQL thread to fail.
CREATE TABLE t1(c1 INT);
[on master]
CREATE TABLE t1(c1 INT);
[on slave]
DROP TABLE t1;
# Block SQL thread immediately after it starts.
SET DEBUG_SYNC='after_start_slave WAIT_FOR signal.continue';
START SLAVE SQL_THREAD;
# Check Slave_SQL_Error, there should not be an error.
# Resume SQL thread
SET DEBUG_SYNC="now SIGNAL signal.continue";
[on master]
DROP TABLE t1;
