# Verify that after CHANGE MASTER, replication (I/O thread and SQL
# thread) restart from where SQL thread left, not from where
# I/O thread left (some old bug fixed in 4.0.17)

source include/master-slave.inc;

connection master;
# Make SQL slave thread advance a bit
create table t1(n int);
sync_slave_with_master;
select * from t1;
# Now stop it and make I/O slave thread be ahead
stop slave sql_thread;
connection master;
insert into t1 values(1);
insert into t1 values(2);
save_master_pos;
let $slave_param= Read_Master_Log_Pos;
let $slave_param_value= query_get_value(SHOW MASTER STATUS, Position, 1);
connection slave;
source include/wait_for_slave_param.inc;
source include/stop_slave.inc;

let $read_pos= query_get_value(SHOW SLAVE STATUS, Read_Master_Log_Pos, 1);
let $exec_pos= query_get_value(SHOW SLAVE STATUS, Exec_Master_Log_Pos, 1);
if (`SELECT $read_pos = $exec_pos`)
{
  source include/show_rpl_debug_info.inc;
  echo 'Read_Master_Log_Pos: $read_pos' == 'Exec_Master_Log_Pos: $exec_pos';
  die Failed because Read_Master_Log_Pos is equal to Exec_Master_Log_Pos;
} 
change master to master_user='root';
let $read_pos= query_get_value(SHOW SLAVE STATUS, Read_Master_Log_Pos, 1);
let $exec_pos= query_get_value(SHOW SLAVE STATUS, Exec_Master_Log_Pos, 1);
if (`SELECT $read_pos <> $exec_pos`)
{
  source include/show_rpl_debug_info.inc;
  echo 'Read_Master_Log_Pos: $read_pos' <> 'Exec_Master_Log_Pos: $exec_pos';
  die Failed because Read_Master_Log_Pos is not equal to Exec_Master_Log_Pos;
}

start slave;
sync_with_master;
select * from t1;
connection master;
drop table t1;
sync_slave_with_master;

# End of 4.1 tests

#
# BUG#12190 CHANGE MASTER has differ path requiremts on MASTER_LOG_FILE and RELAY_LOG_FILE
#

source include/master-slave-reset.inc;

connection master;
create table t1 (a int);
insert into t1 values (1);
flush logs;
insert into t1 values (2);

# Note: the master positon saved by this will also be used by the
# 'sync_with_master' below.
sync_slave_with_master;

# Check if the table t1 and t2 are identical on master and slave;
let $diff_table_1= master:test.t1
let $diff_table_2= slave:test.t1
source include/diff_tables.inc;

connection slave;
source include/stop_slave.inc;
delete from t1 where a=2;

# start replication from the second insert, after fix of BUG#12190,
# relay_log_file does not use absolute path, only the filename is
# required
#
# Note: the follow change master will automatically reset
# relay_log_purge to false, save the old value to restore
let $relay_log_purge= `select @@global.relay_log_purge`;
CHANGE MASTER TO relay_log_file='slave-relay-bin.000005', relay_log_pos=4;
start slave sql_thread;
source include/wait_for_slave_sql_to_start.inc;

# Sync to the same position saved by the 'sync_slave_with_master' above.
sync_with_master;

# Check if the table t1 and t2 are identical on master and slave;
let $diff_table_1= master:test.t1
let $diff_table_2= slave:test.t1
source include/diff_tables.inc;

# clean up
connection slave;
start slave io_thread;
source include/wait_for_slave_io_to_start.inc;
eval set global relay_log_purge=$relay_log_purge;
connection master;
drop table t1;
sync_slave_with_master;

#
# BUG#44209: MASTER_CONNECT_RETRY and --master-retry-count disconnected from each other
#

-- connection master
-- source include/master-slave-reset.inc

-- connection slave
-- let $retry_count0= query_get_value(SHOW SLAVE STATUS, Master_Retry_Count, 1)

# assertion: show that the command line is still valid (MTR sets it to 10)
-- echo Master_Retry_Count: $retry_count

-- source include/stop_slave.inc

# action: change the initial value to some other value
-- let $retry_count1= `SELECT $retry_count0+10`
-- eval CHANGE MASTER TO master_retry_count=$retry_count1

-- source include/start_slave.inc

-- let $retry_count1= query_get_value(SHOW SLAVE STATUS, Master_Retry_Count, 1)
# assertion: it shows the new value -- retry_count0 +10
if (`SELECT $retry_count1 <> ($retry_count0+10)`)
{
  -- let $expected= `SELECT $retry_count0+10`
  -- echo Unexpected retry count value! Got: $retry_count1, expected: $expected
  -- die
}

-- source include/stop_slave.inc

# action: change master_retry_count to zero, which should produce no change.
CHANGE MASTER TO master_retry_count=0;

-- source include/start_slave.inc

-- let $retry_count2= query_get_value(SHOW SLAVE STATUS, Master_Retry_Count, 1)
# assertion: it shows no changes
if (`SELECT $retry_count2 <> $retry_count1`)
{
  -- echo Unexpected retry count value! Got: $retry_count2, expected: $retry_count1
  -- die
}

-- source include/stop_slave.inc

# action: change the value to the smallest value possible
CHANGE MASTER TO master_retry_count=1;

-- source include/start_slave.inc

-- let $retry_count3= query_get_value(SHOW SLAVE STATUS, Master_Retry_Count, 1)
# assertion: it should show 1
if (`SELECT $retry_count3 <> 1`)
{
  -- echo Unexpected retry count value! Got: $retry_count3, expected: 1
  -- die
}

-- source include/stop_slave.inc

# action: change the value back to the original one
-- eval CHANGE MASTER TO master_retry_count=$retry_count0

-- source include/start_slave.inc

-- let $retry_count4= query_get_value(SHOW SLAVE STATUS, Master_Retry_Count, 1)
# assertion: it should show 1
if (`SELECT $retry_count4 <> $retry_count0`)
{
  -- echo Unexpected retry count value! Got: $retry_count4, expected: $retry_count0
  -- die
}

## Now lets change master_retry_count to 1 and stop and restart the slave 
## to check whether master_retry_count persists or not
-- source include/stop_slave.inc
-- let $retry_count_expected= 1
-- eval CHANGE MASTER TO master_retry_count=$retry_count_expected

# Stop master server
--echo ### stop slave server
--write_file $MYSQLTEST_VARDIR/tmp/mysqld.2.expect
wait
EOF
--shutdown_server 10
--source include/wait_until_disconnected.inc
  
--echo ### start slave server
--append_file $MYSQLTEST_VARDIR/tmp/mysqld.2.expect
restart
EOF
--enable_reconnect
--source include/wait_until_connected_again.inc

-- connection slave
-- source include/start_slave.inc

-- let $retry_count5= query_get_value(SHOW SLAVE STATUS, Master_Retry_Count, 1)
if (`SELECT $retry_count5 <> $retry_count_expected`)
{
  -- echo Unexpected retry count value! Got: $retry_count5, expected: $retry_count_expected
  -- die
}

## Checks that the slave actually gives up after retrying N times, where
## N was set with CHANGE MASTER TO master_retry_count=N

-- source include/stop_slave.inc
CHANGE MASTER TO master_retry_count=3, master_host='dummy', master_connect_retry=1;
START SLAVE io_thread;

# We wait for slave to stop and inspect the number of retries in 
# the error message.
-- source include/wait_for_slave_io_to_stop.inc
-- let $error= query_get_value("SHOW SLAVE STATUS", Last_IO_Error, 1)
if (!`SELECT "$error" LIKE "%retries: 3"`)
{
  -- echo Unexpected retry count value! Got: $error
  -- echo Expected number of retries was: 3
  -- die
}

## check that there is a parse error if not using a numerical value
-- error ER_PARSE_ERROR
CHANGE MASTER TO master_retry_count='a';

-- source include/master-slave-reset.inc
-- source include/master-slave-end.inc
