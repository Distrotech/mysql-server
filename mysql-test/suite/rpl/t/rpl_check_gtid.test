################################################################################
# 1. Guarantee that an event generated on the master appears everywhere.
#
# Property 1.1 The set of GTids generated on the master are unique and
#              monotonically created.
#
# Property 1.2 The set of GTids generated on the master are preserved
#              in the relay log after being fetched.
#
# Property 1.2 The set of GTids generated on the master are preserved
#              in the slave's binary log after execution.
#
# 2. Guarantee that the Previous GTids events are correctly stored everywhere.
#
# Property 2.1 - The Previous GTids stored in a binary log must represent the
#                set of transactions stored in the previous binary logs.
#
# Property 2.2 - The Previous GTids stored in a relay log must represent the
#                set of transactions stored in the previous relay logs.
#
# 3. Guarantee that RESET SLAVE/RESET MASTER cleans the appropriate states.
#
# Property 3.1 - RESET SLAVE cleans the GTids and previous GTids' state
#                storead in the relay log.
#
# Property 3.2 - RESET MASTER cleans the GTids and previous GTids' state
#                storead in the binary log.
#
# 4. With CHANGE MASTER TO MASTER_AUTO_POSITION coordinates are not used.
#
# Property 4.1 - When MASTER_AUTO_POSITION is specified only missing data
#                transactions on the slave are retrieved from the master.
#          
# We check if the aforementioned properties hold after generating a set
# of transactions and rotating logs through different methods: 
#
# 1. On both master and slave, rotate logs through FLUSH LOGS.
# 2. On the slave, generate spreaded events by rotating the relay log when
#    its size is greater than 500 bytes. On the master, rotate logs through
#    FLUSH LOGS.
# 3. On the slave, rotate logs by restarting the server. On the master,
#    rotate logs through FLUSH LOGS.
# 4. On the slave, rotate logs by start/stop. On the master, rotate logs by
#    restarting the server.
# 5. RESET SLAVE must not affect its binary log. On the master, rotate logs
#    by restarting the server.
# 6. On the slave, rotate logs by start/stop and calling CHANGE MASTER TO
#    with MASTER_AUTO_POSITION enabled. On the master, rotate logs through
#    FLUSH LOGS.
# 7. On the slave, rotate logs by start/stop and calling START SLAVE UNTIL
#    GTID_SET. On the master, rotate logs through FLUSH LOGS.
#
# --- TODO ---
# There are two cases not consider here:
# . Events being generated at both master and slave.
# . Crahes after creating logs and corrupted Previous Gtids.
################################################################################
--source include/master-slave.inc
--source include/not_embedded.inc
--source include/not_windows.inc
--source include/have_debug.inc

call mtr.add_suppression("Recovery from master pos .*");

--let $master_uuid= query_get_value(SELECT @@SERVER_UUID, @@SERVER_UUID, 1)
CREATE TABLE t1(id INTEGER) ENGINE= Innodb;


#
# 1. This part of the test case:
#
#  1.1 - Generates a set of transactions on the master.
#
#  1.2 - Makes the slave to retrieve and apply these transactions.
#
#  1.3 - Rotates both the binary logs on the slave and master
#        by calling FLUSH LOGS.
#
--let $i=1
while ($i != 4)
{
  #  1.1 - Generates a set of transactions on the master.
  BEGIN;
  INSERT INTO t1 VALUES(1);
  INSERT INTO t1 VALUES(2);
  COMMIT;

  # Check property 1.1 and 2.1.
  --let $binlog= binlog
  if ($i == 1)
  {
    --let $gtid_set_ini= 0
    --let $gtid_set_end= 0
    --let $gtid_ini= 1
    --let $gtid_end= 3
  }
  if ($i != 1)
  {
    --let $gtid_set_ini= 1
    --let $gtid_set_end= `SELECT $i + 1`
    --let $gtid_ini= `SELECT $i + 2`
    --let $gtid_end= `SELECT $i + 2`
  }
  --source extra/rpl_tests/rpl_check_gtid.inc

  #  1.2 - Makes the slave to retrieve and apply these transactions.
  --sync_slave_with_master
  --connection slave

  # Check property 1.2 and 2.1.
  --let $binlog= binlog
  if ($i == 1)
  {
    --let $gtid_set_ini= 0
    --let $gtid_set_end= 0
    --let $gtid_ini= 1
    --let $gtid_end= 3
  }
  if ($i != 1)
  {
    --let $gtid_set_ini= 1
    --let $gtid_set_end= `SELECT $i + 1`
    --let $gtid_ini= `SELECT $i + 2`
    --let $gtid_end= `SELECT $i + 2`
  }
  --source extra/rpl_tests/rpl_check_gtid.inc
  
  # Check property 1.3 and 2.2.
  --let $binlog= relaylog
  if ($i == 1)
  {
    --let $gtid_set_ini= 0
    --let $gtid_set_end= 0
    --let $gtid_ini= 1
    --let $gtid_end= 3
  }
  if ($i != 1)
  {
    --let $gtid_set_ini= 1
    --let $gtid_set_end= `SELECT $i + 1`
    --let $gtid_ini= `SELECT $i + 2`
    --let $gtid_end= `SELECT $i + 2`
  }
  --source extra/rpl_tests/rpl_check_gtid.inc

#  1.3 - Rotates both the binary logs on the slave and master.
  FLUSH LOGS;
  --connection master
  FLUSH LOGS;

  inc $i;
}

#
# 2. This part of the test case:
#
#  2.1 - Generates a set of transactions on the master.
#
#  2.2 - Makes the slave to retrieve these transactions and
#        spread their events into two relay logs. Then apply
#        the events.
#
#  2.3 - Rotates the binary log on the master
#        by calling FLUSH LOGS.
#
--connection slave
--source include/stop_slave.inc
RESET MASTER;
RESET SLAVE;
--connection master
RESET MASTER;
--connection slave
SET GLOBAL debug="d,rotate_slave_debug_group";
--source include/start_slave.inc

--let $i=1
while ($i != 5)
{
  #  2.1 - Generates a set of transactions on the master.
  --connection master
  BEGIN;
  INSERT INTO t1 VALUES(1);
  INSERT INTO t1 VALUES(2);
  COMMIT;

  #  2.2 - Makes the slave to retrieve these transactions and
  #        spread their events into two relay logs. Then apply
  #        the events.
  --sync_slave_with_master

  # Check property 2.2.
  --let $binlog= relaylog
  --let $gtid_set_ini= 1
  --let $gtid_set_end= `SELECT $i`
  --let $gtid_ini=
  --let $gtid_end=
  --source extra/rpl_tests/rpl_check_gtid.inc

  #  2.3 - Rotates the binary log on the master.
  --connection master
  FLUSH LOGS;

  inc $i;
}

#
# 3. This part of the test case:
#
#  3.1 - Generates a set of transactions on the master.
#
#  3.2 - Makes the slave to retrieve and apply these transactions
#
#  3.3 - Restarts the slave server to rotate binary and relay logs.
#
#  3.4 - Rotates both the binary logs on the slave and master
#        by calling FLUSH LOGS.
#
--connection slave
--source include/stop_slave.inc
SET GLOBAL debug="-d,rotate_slave_debug_group";
RESET MASTER;
RESET SLAVE;
--connection master
RESET MASTER;
--connection slave
--source include/start_slave.inc

--let $i=1
while ($i != 5)
{
  #  3.1 - Generates a set of transactions on the master.
  --connection master
  BEGIN;
  INSERT INTO t1 VALUES(1);
  INSERT INTO t1 VALUES(2);
  COMMIT;

  #  3.2 - Makes the slave to retrieve and apply these transactions.
  --sync_slave_with_master
 
  # Check property 1.2 and 2.1.
  --connection slave
  --let $binlog= binlog
  if ($i == 1)
  {
    --let $gtid_set_ini= 0
    --let $gtid_set_end= 0
    --let $gtid_ini= 1
    --let $gtid_end= 1
  }
  if ($i != 1)
  {
    --let $gtid_set_ini= 1
    --let $gtid_set_end= `SELECT $i - 1`
    --let $gtid_ini= `SELECT $i`
    --let $gtid_end= `SELECT $i`
  }
  --source extra/rpl_tests/rpl_check_gtid.inc

  # Check property 1.3 and 2.2.
  --let $binlog= relaylog
  if ($i == 1)
  {
    --let $gtid_set_ini= 0
    --let $gtid_set_end= 0
    --let $gtid_ini= 1
    --let $gtid_end= 1
  }
  if ($i != 1)
  {
    --let $gtid_set_ini= 1
    --let $gtid_set_end= `SELECT $i - 1`
    --let $gtid_ini= `SELECT $i`
    --let $gtid_end= `SELECT $i`
  }
  --source extra/rpl_tests/rpl_check_gtid.inc

  #  3.3 - Restarts the slave server to rotate binary and relay logs.
  --source include/stop_slave.inc
  --let $rpl_server_number= 2
  --source include/rpl_restart_server.inc
  --connection slave
  --source include/start_slave.inc
  
  #  3.4 - Rotates both the binary logs on the slave and master.
  FLUSH LOGS;
  --connection master
  FLUSH LOGS;

  inc $i;
}

#
# 4. This part of the test case:
#
#  4.1 - Generates a set of transactions on the master.
#
#  4.2 - Makes the slave to retrieve and apply these transactions
#
#  4.3 - Stops the slave, restart the master server and starts the
#        slave to rotate both slave and master's binary and slave's
#        relay logs.
#
#  4.4 - Rotates both the binary logs on the slave and master
#        by calling FLUSH LOGS.
#
--connection slave
--source include/stop_slave.inc
RESET MASTER;
RESET SLAVE;
--connection master
RESET MASTER;
--connection slave
--source include/start_slave.inc

--let $i=1
while ($i != 5)
{
  #  4.1 - Generates a set of transactions on the master.
  --connection master
  BEGIN;
  INSERT INTO t1 VALUES(1);
  INSERT INTO t1 VALUES(2);
  COMMIT;

  # Check property 1.1 and 2.1.
  --let $binlog= binlog
  if ($i == 1)
  {
    --let $gtid_set_ini= 0
    --let $gtid_set_end= 0
    --let $gtid_ini= 1
    --let $gtid_end= 1
  }
  if ($i != 1)
  {
    --let $gtid_set_ini= 1
    --let $gtid_set_end= `SELECT $i - 1`
    --let $gtid_ini= `SELECT $i`
    --let $gtid_end= `SELECT $i`
  }
  --source extra/rpl_tests/rpl_check_gtid.inc

  #  4.2 - Makes the slave to retrieve and apply these transactions.
  --sync_slave_with_master
 
  # Check property 1.2 and 2.1.
  --connection slave
  --let $binlog= binlog
  if ($i == 1)
  {
    --let $gtid_set_ini= 0
    --let $gtid_set_end= 0
    --let $gtid_ini= 1
    --let $gtid_end= 1
  }
  if ($i != 1)
  {
    --let $gtid_set_ini= 1
    --let $gtid_set_end= `SELECT $i - 1`
    --let $gtid_ini= `SELECT $i`
    --let $gtid_end= `SELECT $i`
  }
  --source extra/rpl_tests/rpl_check_gtid.inc

  # Check property 1.3 and 2.2.
  --let $binlog= relaylog
  if ($i == 1)
  {
    --let $gtid_set_ini= 0
    --let $gtid_set_end= 0
    --let $gtid_ini= 1
    --let $gtid_end= 1
  }
  if ($i != 1)
  {
    --let $gtid_set_ini= 1
    --let $gtid_set_end= `SELECT $i - 1`
    --let $gtid_ini= `SELECT $i`
    --let $gtid_end= `SELECT $i`
  }
  --source extra/rpl_tests/rpl_check_gtid.inc

  #  4.3 - Stops the slave, restart the master server and starts the
  #        slave.
  --source include/stop_slave.inc
  --connection master
  --let $rpl_server_number= 1
  --source include/rpl_restart_server.inc
  --connection slave
  --source include/start_slave.inc
  
  #  4.4 - Rotates both the binary logs on the slave and master.
  FLUSH LOGS;
  --connection master
  FLUSH LOGS;

  inc $i;
}

#
# 5. This part of the test case:
#
#  5.1 - Resets the IO Thread's state but not SQL Thread's state.
#
#  5.2 - Generates a set of transactions on the master.
#
#  5.3 - Stops the slave, restart the master server and starts the
#        slave to rotate both slave and master's binary and slave's
#        relay logs.
#
#  5.4 - Rotates both the binary logs on the slave and master
#        by calling FLUSH LOGS.
#

--let $i=1
while ($i != 5)
{

  #  5.1 - Resets the IO Thread's state but not SQL Thread's state.
  --connection slave
  --source include/stop_slave.inc
  RESET SLAVE;
  --connection master
  RESET MASTER;
  --connection slave
  --source include/start_slave.inc

  #  5.2 - Generates a set of transactions on the master.
  --connection master
  BEGIN;
  INSERT INTO t1 VALUES(1);
  INSERT INTO t1 VALUES(2);
  COMMIT;

  BEGIN;
  INSERT INTO t1 VALUES(1);
  INSERT INTO t1 VALUES(2);
  COMMIT;

  #  5.3 - Makes the slave to retrieve and apply these transactions.
  --sync_slave_with_master

  # Check property 1.2, 2.1, 3.1 and 3.2
  if ($i == 1)
  {
    --let $binlog= binlog
    --let $gtid_set_ini= 1
    --let $gtid_set_end= 4
    --let $gtid_ini=
    --let $gtid_end=
  }
  if ($i != 1)
  {
    --let $binlog= binlog
    --let $gtid_set_ini= 1
    --let $gtid_set_end= 4
    --let $gtid_ini=
    --let $gtid_end=
  }
  --source extra/rpl_tests/rpl_check_gtid.inc

  #  5.4 - Rotates both the binary logs on the slave and master.
  FLUSH LOGS;
  --connection master
  FLUSH LOGS;

  inc $i;
}

#
# 6. This part of the test case:
#
#  6.1 - Generates a set of transactions on the master.
#
#  6.2 - Makes the slave to retrieve and apply these transactions through
#        sync_slave_gtid_with_master
#
#  6.3 - Stop the slave, call CHANGE MASTER TO with MASTER_AUTO_POSITION and
#        start the slave to rotate the relay log.
#
#  6.4 - Rotates the binary log on master by calling FLUSH LOGS.
#

--connection slave
--source include/stop_slave.inc
RESET SLAVE;
RESET MASTER;
--connection master
RESET MASTER;
--connection slave
--let $slave_master_host= query_get_value(SHOW SLAVE STATUS, Master_Host, 1)
--error ER_BAD_SLAVE_AUTO_POSITION
CHANGE MASTER TO MASTER_AUTO_POSITION= 1, MASTER_LOG_FILE= 'master-bin.000001', MASTER_LOG_POS= 4;
--source include/start_slave.inc

--let $i=1
while ($i != 4)
{
  # 6.1 - Generates a set of transactions on the master.
  --connection master
  BEGIN;
  INSERT INTO t1 VALUES(1);
  INSERT INTO t1 VALUES(2);
  COMMIT;

  BEGIN;
  INSERT INTO t1 VALUES(1);
  INSERT INTO t1 VALUES(2);
  COMMIT;

  # 6.2 - Makes the slave to retrieve and apply these transactions.
  --sync_slave_gtid_with_master

  # Check property 4.1
  --let $binlog= relaylog
  --let $gtid_set_ini=
  --let $gtid_set_end=
  --let $gtid_ini= `SELECT ($i * 2) - 1`
  --let $gtid_end= `SELECT $i * 2`
  --source extra/rpl_tests/rpl_check_gtid.inc

  # 6.3 - Stop and start the slave, call CHANGE MASTER TO with MASTER_AUTO_POSITION.
  --source include/stop_slave.inc
  --replace_result $slave_master_host SLAVE_MASTER_HOST
  --eval CHANGE MASTER TO MASTER_HOST= '$slave_master_host', MASTER_AUTO_POSITION= 1
  --source include/start_slave.inc

  # 6.4 - Rotates the binary log on master by calling FLUSH LOGS.
  --connection master
  FLUSH LOGS;

  inc $i;
}


#
# 7. This part of the test case:
#
#  7.1 - Generates a set of transactions on the master.
#
#  7.2 - Makes the slave to retrieve and apply these transactions through
#        START SLAVE UNTIL GTID_SET.
#
#  7.3 - Rotates the binary log on master by calling FLUSH LOGS.
#

--connection slave
--source include/stop_slave.inc
RESET SLAVE;
RESET MASTER;
--connection master
RESET MASTER;
--connection slave
--let $slave_master_host= query_get_value(SHOW SLAVE STATUS, Master_Host, 1)
--replace_result $slave_master_host SLAVE_MASTER_HOST
--eval CHANGE MASTER TO MASTER_HOST= '$slave_master_host', MASTER_AUTO_POSITION= 1

--let $i=1
while ($i != 4)
{
  # 7.1 - Generates a set of transactions on the master.
  --connection master
  BEGIN;
  INSERT INTO t1 VALUES(1);
  INSERT INTO t1 VALUES(2);
  COMMIT;

  BEGIN;
  INSERT INTO t1 VALUES(1);
  INSERT INTO t1 VALUES(2);
  COMMIT;

  # 7.2 - Makes the slave to retrieve and apply these transactions.
  --let $executed_gtid= query_get_value(SHOW MASTER STATUS, Executed_Gtid_Set, 1)
  --connection slave
  --replace_result $executed_gtid GTID_SET
  --eval START SLAVE UNTIL GTID_SET= "$executed_gtid"

  # Check property 1.2 and 4.1.
  --let $binlog= relaylog
  --let $gtid_set_ini=
  --let $gtid_set_end=
  --let $gtid_ini= `SELECT ($i * 2) - 1`
  --let $gtid_end= `SELECT $i * 2`
  --source extra/rpl_tests/rpl_check_gtid.inc

  # 7.3 - Rotates the binary log on master by calling FLUSH LOGS.
  --connection master
  FLUSH LOGS;

  inc $i;
}
--connection slave
--source include/start_slave.inc

--connection master
DROP TABLE t1;
--source include/rpl_end.inc
