##### This test is intended to verify that the optimizer chooses one of the #####
##### semijoin strategies while executing a multi table UPDATE or DELETE    #####
##### statement. The test cases added below verifies that the optimizer uses#####
##### semi-join strategy for certain statements which have supported JOIN   #####
##### syntax.								    #####
##### Test case name : multi_table_upd_del_sj.test			    #####
CREATE TABLE class(class_num INT NOT NULL PRIMARY KEY, class_name VARCHAR(20)) ENGINE=INNODB;
CREATE TABLE student(stu_name VARCHAR(20) NOT NULL PRIMARY KEY, stu_city VARCHAR(20), stu_id INT) ENGINE=INNODB;
CREATE TABLE roster(ros_num INT NOT NULL PRIMARY KEY, class_num INT, stu_name VARCHAR(20), FOREIGN KEY fk1(class_num) REFERENCES class(class_num), FOREIGN KEY fk2(stu_name) REFERENCES student(stu_name)) ENGINE=INNODB;
INSERT INTO class VALUES(1,'math'),(2,'science'),(3,'history'),(4,'geog');
INSERT INTO student VALUES('amit','bangalore',1),('ashu','hyderabad',2),('sumit','kota',2),('rajdeep','bbsr',4);
INSERT INTO roster VALUES(1,3,'amit'),(2,4,'amit'),(3, 1, 'ashu'),(4,3,'ashu'),(5,1,'sumit'),(6,4,'sumit');

CREATE TABLE ot1(a INT) ENGINE=INNODB;
CREATE TABLE ot2(a INT) ENGINE=INNODB;
CREATE TABLE ot3(a INT) ENGINE=INNODB;
CREATE TABLE it1(a INT) ENGINE=INNODB;
CREATE TABLE it2(a INT) ENGINE=INNODB;
CREATE TABLE it3(a INT) ENGINE=INNODB;

INSERT INTO ot1 VALUES(0),(1),(2),(3),(4),(5),(6),(7);
INSERT INTO ot2 VALUES(0),(2),(4),(6);
INSERT INTO ot3 VALUES(0),(3),(6);
INSERT INTO it1 VALUES(0),(1),(2),(3),(4),(5),(6),(7);
INSERT INTO it2 VALUES(0),(2),(4),(6);
INSERT INTO it3 VALUES(0),(3),(6);
COMMIT;

# The following are multi-table UPDATE queries

let $query1 = UPDATE class JOIN roster ON class.class_num=roster.class_num
	      SET class.class_name='geography'
	      WHERE class.class_num IN (SELECT class_num FROM roster);

let $query2 = UPDATE class JOIN roster ON class.class_num=roster.class_num 
	      SET class.class_name='geography' 
              WHERE roster.class_num IN (SELECT class_num FROM roster);

let $query3 = UPDATE student JOIN roster ON student.stu_name=roster.stu_name 
	      SET student.stu_city='kolkata' 
	      WHERE student.stu_name IN (SELECT stu_name FROM roster);

let $query4 = UPDATE student JOIN roster ON student.stu_name=roster.stu_name 
	      SET student.stu_city='kolkata' 
	      WHERE roster.stu_name IN (SELECT stu_name FROM roster);

let $query5 = UPDATE LOW_PRIORITY class JOIN roster ON class.class_num=roster.class_num 
	      SET class.class_name='geography' 
	      WHERE class.class_num IN (SELECT class_num FROM roster);

let $query6 = UPDATE IGNORE class JOIN roster ON class.class_num=roster.class_num 
	      SET class.class_name='geography' 
	      WHERE roster.class_num IN (SELECT class_num FROM roster);

let $query7 = UPDATE class RIGHT JOIN roster ON class.class_num=roster.class_num 
	      SET class.class_name='geography' 
	      WHERE roster.class_num IN (SELECT class_num FROM roster);

let $query8 = UPDATE student LEFT JOIN roster ON student.stu_name=roster.stu_name 
	      SET student.stu_city='kolkata' 
	      WHERE student.stu_name IN (SELECT stu_name FROM roster);

let $query9 = UPDATE class INNER JOIN roster ON class.class_num=roster.class_num 
	      SET class.class_name='geography' 
	      WHERE class.class_num IN (SELECT class_num FROM roster);

let $query10 = UPDATE ot1 LEFT JOIN ot2 ON ot1.a=ot2.a 
	       SET ot1.a = 111, ot2.a = 222 
	       WHERE ot1.a IN (SELECT a FROM it3 ORDER BY a);

let $query11 = UPDATE ot1 LEFT JOIN ot2 ON ot1.a=ot2.a 
	       SET ot1.a = 111 
	       WHERE COALESCE(ot2.a,0) IN (SELECT a FROM it3);

let $query12 = UPDATE ot1 LEFT JOIN ot2 ON ot1.a=ot2.a 
	       SET ot1.a = 111, ot2.a = 222 
	       WHERE (ot1.a,ot2.a) IN (SELECT a,a FROM it3 ORDER BY 2);

let $query13 = UPDATE ot1 JOIN ot2 ON ot1.a=ot2.a AND ot1.a IN (SELECT a FROM it3) 
	       SET ot1.a = 111, ot2.a = 222 
	       WHERE ot1.a IN (SELECT a FROM it3);

let $query14 = UPDATE ot1 JOIN ot2 ON ot1.a IN (SELECT a FROM it3) 
	       SET ot1.a = 111, ot2.a = 222 
	       WHERE ot1.a IN (SELECT a FROM it3);

let $query15 = UPDATE ot1 LEFT JOIN (ot2 JOIN ot3 ON ot2.a=ot3.a) ON ot1.a=ot2.a AND ot1.a IN (SELECT a FROM it1 ORDER BY a) 
	       SET ot1.a = 111 
	       WHERE ot1.a IN (SELECT a FROM it3 ORDER BY a);

let $query1a = UPDATE class, roster
	       SET class.class_name='geography'
	       WHERE class.class_num IN (SELECT class_num FROM roster ORDER BY ros_num);

let $query1b = UPDATE class INNER JOIN roster ON class.class_num = roster.class_num 
	       AND class.class_name = 'history' OR class.class_name = 'math'
	       SET class.class_name='geography'
	       WHERE class.class_num IN (SELECT class_num FROM roster ORDER BY ros_num);

let $query1c = UPDATE class JOIN roster ON class.class_num IN (SELECT class_num from roster ORDER BY ros_num) 
	       SET class.class_name='geography';

# The following are multi-table DELETE queries

let $queryd_1 = DELETE class FROM class RIGHT JOIN roster 
	       ON class.class_num=roster.class_num 
	       WHERE roster.class_num IN (SELECT class_num FROM roster);

let $queryd_2 = DELETE LOW_PRIORITY FROM class USING class INNER JOIN roster 
       	       ON class.class_num=roster.class_num 
	       WHERE class.class_num IN (SELECT class_num FROM roster);

let $queryd_3 = DELETE QUICK FROM class USING class LEFT JOIN roster 
	       ON class.class_num=roster.class_num 
	       WHERE class.class_num IN (SELECT class_num FROM roster);

let $queryd_4 = DELETE IGNORE FROM class USING class RIGHT JOIN roster 
	       ON class.class_num=roster.class_num 
	       WHERE class.class_num IN (SELECT class_num FROM roster);

let $queryd_5 = DELETE class FROM class, roster 
	       WHERE class.class_num IN (SELECT class_num FROM roster);

let $queryd_6 = DELETE FROM class USING class, roster 
	       WHERE class.class_num IN (SELECT class_num FROM roster);

let $queryd_7 = DELETE student FROM student LEFT JOIN roster 
	       ON student.stu_name=roster.stu_name 
	       WHERE student.stu_name IN (SELECT stu_name FROM roster);

let $queryd_8 = DELETE student FROM student INNER JOIN roster INNER JOIN class 
	       ON student.stu_name=roster.stu_name AND roster.class_num = class.class_num AND stu_city = 'bbsr' 
	       WHERE student.stu_name IN (SELECT stu_name FROM roster);

let $queryd_9 = DELETE tz FROM tz JOIN ty 
		ON tz.c3=ty.c3 JOIN tx ON ty.c1=tx.c1 
		WHERE ty.c1 IN(SELECT c2 from ty WHERE ty.c1 IN(SELECT c1 from tx WHERE c2>2));

let $queryd_10 = DELETE FROM tz USING tz JOIN ty 
		 ON tz.c3=ty.c3 LEFT JOIN tx ON ty.c1=tx.c1 
		 WHERE ty.c1 IN(SELECT c2 from ty WHERE ty.c1 IN(SELECT c1 from tx WHERE c2>2));

let $queryd_11 = DELETE FROM tz USING tz JOIN ty 
		 ON tz.c3=ty.c3 LEFT JOIN tx ON ty.c1=tx.c1 
		 WHERE ty.c1 IN(SELECT c2 from ty WHERE ty.c1 IN(SELECT c1 from tx));

let $queryd_12 = DELETE FROM tz USING tz INNER JOIN ty 
		 ON tz.c3=ty.c3 LEFT JOIN tx ON ty.c1=tx.c1 
		 WHERE ty.c1 IN(SELECT c2 from ty WHERE ty.c1 IN(SELECT c1 from tx));

let $queryd_13 = DELETE tz FROM tx,ty,tz 
		 WHERE tx.c1 IN(SELECT c2 from ty WHERE ty.c3 IN(SELECT c3 from tx WHERE c2>2));

let $queryd_14 = DELETE tz FROM tx,ty,tz 
		 WHERE ty.c1 IN(SELECT c2 from tx WHERE ty.c1 IN(SELECT c1 from tx));

# The following are a few SELECT queries

let $query_s1 = SELECT * FROM class;

let $query_s2 = SELECT * FROM student;

let $query_s3 = SELECT * FROM ot1;

let $query_s4 = SELECT * FROM ot2;

let $query_s5 = SELECT * FROM tz;

--echo # The optimizer_switch is set to default. We are verifying the various supported JOIN types for SEMI-JOIN

SET optimizer_switch=default;
COMMIT;
SET autocommit=off;

eval EXPLAIN EXTENDED $query1;
eval EXPLAIN EXTENDED $query2;
eval EXPLAIN EXTENDED $query3;
eval EXPLAIN EXTENDED $query4;
eval EXPLAIN EXTENDED $query5;
eval EXPLAIN EXTENDED $query6;
eval EXPLAIN EXTENDED $query7;
eval EXPLAIN EXTENDED $query8;
eval EXPLAIN EXTENDED $query9;
eval EXPLAIN EXTENDED $query10;
eval EXPLAIN EXTENDED $query11;
eval EXPLAIN EXTENDED $query12;
eval EXPLAIN EXTENDED $query13;
eval EXPLAIN EXTENDED $query14;
eval EXPLAIN EXTENDED $query15;

eval $query1;
eval $query_s1;
ROLLBACK;
eval $query2;
eval $query_s1;
ROLLBACK;
eval $query3;
eval $query_s2;
ROLLBACK;
eval $query4;
eval $query_s2;
ROLLBACK;
eval $query5;
eval $query_s1;
ROLLBACK;
eval $query6;
eval $query_s1;
ROLLBACK;
eval $query7;
eval $query_s1;
ROLLBACK;
eval $query8;
eval $query_s2;
ROLLBACK;
eval $query9;
eval $query_s1;
ROLLBACK;
eval $query10;
eval $query_s3;
eval $query_s4;
ROLLBACK;
eval $query11;
eval $query_s3;
ROLLBACK;
eval $query12;
eval $query_s3;
eval $query_s4;
ROLLBACK;
eval $query13;
eval $query_s3;
eval $query_s4;
ROLLBACK;
eval $query14;
eval $query_s3;
eval $query_s4;
ROLLBACK;
eval $query15;
eval $query_s3;
ROLLBACK;

--echo # The following queries would select Firstmatch based on the optimizer switch settings
--echo # Please note that some of the queries would still show Duplicate Weedout

SET optimizer_switch='semijoin=on,firstmatch=on,materialization=off,loosescan=off,index_condition_pushdown=off,mrr=off';
COMMIT;

eval EXPLAIN EXTENDED $query1;
eval EXPLAIN EXTENDED $query7;
eval EXPLAIN EXTENDED $query8;
eval EXPLAIN EXTENDED $query9;
eval EXPLAIN EXTENDED $query10;
eval EXPLAIN EXTENDED $query11;
eval EXPLAIN EXTENDED $query12;
eval EXPLAIN EXTENDED $query13;
eval EXPLAIN EXTENDED $query14;
eval EXPLAIN EXTENDED $query15;

eval $query1;
eval $query_s1;
ROLLBACK;
eval $query7;
eval $query_s1;
ROLLBACK;
eval $query8;
eval $query_s2;
ROLLBACK;
eval $query9;
eval $query_s1;
ROLLBACK;
eval $query10;
eval $query_s3;
eval $query_s4;
ROLLBACK;
eval $query11;
eval $query_s3;
ROLLBACK;
eval $query12;
eval $query_s3;
eval $query_s4;
ROLLBACK;
eval $query13;
eval $query_s3;
eval $query_s4;
ROLLBACK;
eval $query14;
eval $query_s3;
eval $query_s4;
ROLLBACK;
eval $query15;
eval $query_s3;
ROLLBACK;

--echo # The following queries would select Materialize based on the optimizer switch settings
--echo # Please note that some of the queries would still show Duplicate Weedout

SET optimizer_switch='semijoin=on,loosescan=off,firstmatch=off,index_condition_pushdown=off,mrr=off,materialization=on';
COMMIT;

eval EXPLAIN EXTENDED $query1;
eval EXPLAIN EXTENDED $query7;
eval EXPLAIN EXTENDED $query8;
eval EXPLAIN EXTENDED $query9;
eval EXPLAIN EXTENDED $query10;
eval EXPLAIN EXTENDED $query11;
eval EXPLAIN EXTENDED $query12;
eval EXPLAIN EXTENDED $query13;
eval EXPLAIN EXTENDED $query14;
eval EXPLAIN EXTENDED $query15;

eval $query1;
eval $query_s1;
ROLLBACK;
eval $query7;
eval $query_s1;
ROLLBACK;
eval $query8;
eval $query_s2;
ROLLBACK;
eval $query9;
eval $query_s1;
ROLLBACK;
eval $query10;
eval $query_s3;
eval $query_s4;
ROLLBACK;
eval $query11;
eval $query_s3;
ROLLBACK;
eval $query12;
eval $query_s3;
eval $query_s4;
ROLLBACK;
eval $query13;
eval $query_s3;
eval $query_s4;
ROLLBACK;
eval $query14;
eval $query_s3;
eval $query_s4;
ROLLBACK;
eval $query15;
eval $query_s3;
ROLLBACK;

--echo # The following queries would select Duplicate Weedout strategy based on the optimizer switch settings

SET optimizer_switch='loosescan=off,firstmatch=off,index_condition_pushdown=off,mrr=off,semijoin=on,materialization=off';
COMMIT;

eval EXPLAIN EXTENDED $query1;
eval EXPLAIN EXTENDED $query7;
eval EXPLAIN EXTENDED $query8;
eval EXPLAIN EXTENDED $query9;
eval EXPLAIN EXTENDED $query10;
eval EXPLAIN EXTENDED $query11;
eval EXPLAIN EXTENDED $query12;
eval EXPLAIN EXTENDED $query13;
eval EXPLAIN EXTENDED $query14;
eval EXPLAIN EXTENDED $query15;

eval $query1;
eval $query_s1;
ROLLBACK;
eval $query7;
eval $query_s1;
ROLLBACK;
eval $query8;
eval $query_s2;
ROLLBACK;
eval $query9;
eval $query_s1;
ROLLBACK;
eval $query10;
eval $query_s3;
eval $query_s4;
ROLLBACK;
eval $query11;
eval $query_s3;
ROLLBACK;
eval $query12;
eval $query_s3;
eval $query_s4;
ROLLBACK;
eval $query13;
eval $query_s3;
eval $query_s4;
ROLLBACK;
eval $query14;
eval $query_s3;
eval $query_s4;
ROLLBACK;
eval $query15;
eval $query_s3;
ROLLBACK;

--echo # The following queries would select Loosescan strategy based on the optimizer switch settings
--echo # Please note that some of the queries would still show Duplicate Weedout

SET optimizer_switch='loosescan=on,firstmatch=off,index_condition_pushdown=off,mrr=off,semijoin=on,materialization=off';
COMMIT;

eval EXPLAIN EXTENDED $query1;
eval EXPLAIN EXTENDED $query7;
eval EXPLAIN EXTENDED $query8;
eval EXPLAIN EXTENDED $query9;
eval EXPLAIN EXTENDED $query10;
eval EXPLAIN EXTENDED $query11;
eval EXPLAIN EXTENDED $query12;
eval EXPLAIN EXTENDED $query13;
eval EXPLAIN EXTENDED $query14;
eval EXPLAIN EXTENDED $query15;

eval $query1;
eval $query_s1;
ROLLBACK;
eval $query7;
eval $query_s1;
ROLLBACK;
eval $query8;
eval $query_s2;
ROLLBACK;
eval $query9;
eval $query_s1;
ROLLBACK;
eval $query10;
eval $query_s3;
eval $query_s4;
ROLLBACK;
eval $query11;
eval $query_s3;
ROLLBACK;
eval $query12;
eval $query_s3;
eval $query_s4;
ROLLBACK;
eval $query13;
eval $query_s3;
eval $query_s4;
ROLLBACK;
eval $query14;
eval $query_s3;
eval $query_s4;
ROLLBACK;
eval $query15;
eval $query_s3;
ROLLBACK;

--echo # The following queries would give various strategies based on the default optimizer switch settings

SET optimizer_switch=default;
COMMIT;

eval EXPLAIN EXTENDED $query1a;
eval EXPLAIN EXTENDED $query1b;

eval $query1a;
eval $query_s1;
ROLLBACK;
eval $query1b;
eval $query_s1;
ROLLBACK;

--echo # Using IN subquery predicate in the ON clause of the JOIN

eval EXPLAIN EXTENDED $query1c;

eval $query1c;
eval $query_s1;
ROLLBACK;

--echo # The following set of tables are created to verify JOINS between 3 tables

CREATE TABLE tx(c1 INT NOT NULL PRIMARY KEY, c2 INT) ENGINE=INNODB;
CREATE TABLE ty(c1 INT, c2 INT, c3 VARCHAR(20) NOT NULL PRIMARY KEY, FOREIGN KEY fk1(c1) REFERENCES tx(c1)) ENGINE=INNODB;
CREATE TABLE tz(c1 INT, c2 INT, c3 VARCHAR(20), FOREIGN KEY fk2(c3) REFERENCES ty(c3)) ENGINE=INNODB;

INSERT INTO tx VALUES(1,1),(2,2),(3,3),(4,4),(5,5);
INSERT INTO ty VALUES(1,1,'1 match tx'),(2,2,'2 match tx'),(4,4,'4 match tx');
INSERT INTO tz VALUES(2,2,'2 match tx'),(4,4,'4 match tx'); 
INSERT INTO tz VALUES(20,20,'2 match tx'),(40,40,'4 match tx');
INSERT INTO tz VALUES(200,200,'2 match tx'),(400,400,'4 match tx');
COMMIT;

--echo # Verifying various variations of the JOIN syntax using 3 tables

let $query2a = UPDATE tx JOIN ty ON tx.c1=ty.c1 JOIN tz ON ty.c3=tz.c3 
	       SET tx.c2=100 
	       WHERE tx.c1 IN(SELECT c2 from ty WHERE ty.c3 IN(SELECT c3 from tz WHERE c2>2) ORDER BY c1);

let $query2b = UPDATE tx JOIN ty ON tx.c1=ty.c1 LEFT JOIN tz ON ty.c3=tz.c3 
	       SET tx.c2=100 
	       WHERE tx.c1 IN(SELECT c2 from ty WHERE ty.c3 IN(SELECT c3 from tz WHERE c2>2));

let $query2c = UPDATE tx JOIN ty ON tx.c1=ty.c1 LEFT JOIN tz ON ty.c3=tz.c3 
	       SET tx.c2=100 
	       WHERE tx.c1 IN(SELECT c1 from ty WHERE ty.c3 IN(SELECT c3 from tz WHERE c2>2) ORDER BY c2);

let $query2d = UPDATE tx JOIN ty ON tx.c1=ty.c1 LEFT JOIN tz ON ty.c3=tz.c3 
	       SET tx.c2=100 
	       WHERE tx.c1 IN(SELECT c2 from ty WHERE ty.c3 IN(SELECT c3 from tz));

let $query2e = UPDATE tx INNER JOIN ty ON tx.c1=ty.c1 LEFT JOIN tz ON ty.c3=tz.c3 
	       SET tx.c2=100 
	       WHERE tx.c1 IN(SELECT c2 from ty WHERE ty.c3 IN(SELECT c3 from tz ORDER BY c2));

let $query2f = UPDATE tx,ty,tz 
	       SET tx.c2=100 
	       WHERE tx.c1 IN(SELECT c2 from ty WHERE ty.c3 IN(SELECT c3 from tz WHERE c2>2 ORDER BY c2));

let $query2g = UPDATE tx,ty,tz 
	       SET tx.c2=100 
	       WHERE tx.c1 IN(SELECT c2 from ty WHERE ty.c3 IN(SELECT c3 from tz));

let $query2_s = SELECT * FROM tx;

eval EXPLAIN EXTENDED $query2a;
eval EXPLAIN EXTENDED $query2b;
eval EXPLAIN EXTENDED $query2c;
eval EXPLAIN EXTENDED $query2d;
eval EXPLAIN EXTENDED $query2e;
eval EXPLAIN EXTENDED $query2f;
eval EXPLAIN EXTENDED $query2g;

eval $query2a;
eval $query2_s;
ROLLBACK;
eval $query2b;
eval $query2_s;
ROLLBACK;
eval $query2c;
eval $query2_s;
ROLLBACK;
eval $query2d;
eval $query2_s;
ROLLBACK;
eval $query2e;
eval $query2_s;
ROLLBACK;
eval $query2f;
eval $query2_s;
ROLLBACK;
eval $query2g;
eval $query2_s;
ROLLBACK;

--echo # The following queries have JOIN syntax within the IN sub-query

let $query3a = UPDATE tx JOIN ty ON tx.c1=ty.c1 JOIN tz ON ty.c3=tz.c3 
	       SET tx.c2=100 
	       WHERE tx.c1 IN(SELECT ty.c2 from ty,tz WHERE ty.c3 = tz.c3 and tz.c2 > 2);

let $query3b = UPDATE tx JOIN ty ON tx.c1=ty.c1 JOIN tz ON ty.c3=tz.c3 
	       SET tx.c2=100 
	       WHERE tx.c1 IN(SELECT ty.c2 from ty JOIN tz ON ty.c3 = tz.c3 and tz.c2 > 2);

let $query3c = UPDATE tx JOIN ty ON tx.c1=ty.c1 JOIN tz ON ty.c3=tz.c3 
	       SET tx.c2=100 
	       WHERE tx.c1 IN(SELECT ty.c2 from ty INNER JOIN tz ON ty.c3 = tz.c3 and tz.c2 > 2);

let $query3d = UPDATE tx JOIN ty ON tx.c1=ty.c1 JOIN tz ON ty.c3=tz.c3 
	       SET tx.c2=100 
	       WHERE tx.c1 IN(SELECT ty.c2 from ty LEFT JOIN tz ON ty.c3 = tz.c3 and tz.c2 > 2);

let $query3e = UPDATE tx INNER JOIN ty ON tx.c1=ty.c1 LEFT JOIN tz ON ty.c3=tz.c3 
	       SET tx.c2=100 
	       WHERE tx.c1 IN(SELECT c2 from ty) AND tx.c1 IN(SELECT c2 from tz);

eval EXPLAIN EXTENDED $query3a;
eval EXPLAIN EXTENDED $query3b;
eval EXPLAIN EXTENDED $query3c;
eval EXPLAIN EXTENDED $query3d;
eval EXPLAIN EXTENDED $query3e;

eval $query3a;
eval $query2_s;
ROLLBACK;
eval $query3b;
eval $query2_s;
ROLLBACK;
eval $query3c;
eval $query2_s;
ROLLBACK;
eval $query3d;
eval $query2_s;
ROLLBACK;
eval $query3e;
eval $query2_s;
ROLLBACK;

--echo # Updating  columns from more than 1 table 

let $query4a = UPDATE tx,ty,tz 
	       SET tx.c2=100,tz.c2=101 
	       WHERE tx.c1 IN(SELECT c2 from ty);

let $query4b = UPDATE tx INNER JOIN ty ON tx.c1=ty.c1 LEFT JOIN tz ON ty.c3=tz.c3 
	       SET tx.c2=100,tz.c2=101 
	       WHERE tx.c1 IN(SELECT c2 from ty);

let $query4_s1 = SELECT * FROM tx;

let $query4_s2 = SELECT * FROM tz;

eval EXPLAIN EXTENDED $query4a;
eval EXPLAIN EXTENDED $query4b;

eval $query4a;
eval $query4_s1;
eval $query4_s2;
ROLLBACK;
eval $query4b;
eval $query4_s1;
eval $query4_s2;
ROLLBACK;

# Verifying the multi-table DELETE in the tests below
--echo # Testing multi-table DELETE

ALTER TABLE roster DROP FOREIGN KEY roster_ibfk_1; 
ALTER TABLE roster DROP FOREIGN KEY roster_ibfk_2;
ALTER TABLE roster DROP PRIMARY KEY;
ALTER TABLE class DROP PRIMARY KEY;
ALTER TABLE student DROP PRIMARY KEY;
ALTER TABLE roster ADD KEY(class_num);

--echo # The optimizer_switch is set to default. We are verifying the various supported JOIN types for SEMI-JOIN

SET optimizer_switch=default;
COMMIT;

eval EXPLAIN EXTENDED $queryd_1;
eval EXPLAIN EXTENDED $queryd_2;
eval EXPLAIN EXTENDED $queryd_3;
eval EXPLAIN EXTENDED $queryd_4;
eval EXPLAIN EXTENDED $queryd_5;
eval EXPLAIN EXTENDED $queryd_6;
eval EXPLAIN EXTENDED $queryd_7;
eval EXPLAIN EXTENDED $queryd_8;
eval EXPLAIN EXTENDED $queryd_9;
eval EXPLAIN EXTENDED $queryd_10;
eval EXPLAIN EXTENDED $queryd_11;
eval EXPLAIN EXTENDED $queryd_12;
eval EXPLAIN EXTENDED $queryd_13;
eval EXPLAIN EXTENDED $queryd_14;

eval $queryd_1;
eval $query_s1;
ROLLBACK;
eval $queryd_2;
eval $query_s1;
ROLLBACK;
eval $queryd_3;
eval $query_s1;
ROLLBACK;
eval $queryd_4;
eval $query_s1;
ROLLBACK;
eval $queryd_5;
eval $query_s1;
ROLLBACK;
eval $queryd_6;
eval $query_s1;
ROLLBACK;
eval $queryd_7;
eval $query_s2;
ROLLBACK;
eval $queryd_8;
eval $query_s2;
ROLLBACK;
eval $queryd_9;
eval $query_s5;
ROLLBACK;
eval $queryd_10;
eval $query_s5;
ROLLBACK;
eval $queryd_11;
eval $query_s5;
ROLLBACK;
eval $queryd_12;
eval $query_s5;
ROLLBACK;
eval $queryd_13;
eval $query_s5;
ROLLBACK;
eval $queryd_14;
eval $query_s5;
ROLLBACK;

--echo # The following queries would select Firstmatch based on the optimizer switch settings
--echo # Please note that some of the queries would still show Duplicate Weedout

SET optimizer_switch='semijoin=on,firstmatch=on,materialization=off,loosescan=off,index_condition_pushdown=off,mrr=off';
COMMIT;

eval EXPLAIN EXTENDED $queryd_1;
eval EXPLAIN EXTENDED $queryd_2;
eval EXPLAIN EXTENDED $queryd_3;
eval EXPLAIN EXTENDED $queryd_4;
eval EXPLAIN EXTENDED $queryd_5;
eval EXPLAIN EXTENDED $queryd_6;
eval EXPLAIN EXTENDED $queryd_7;
eval EXPLAIN EXTENDED $queryd_8;
eval EXPLAIN EXTENDED $queryd_9;
eval EXPLAIN EXTENDED $queryd_10;
eval EXPLAIN EXTENDED $queryd_11;
eval EXPLAIN EXTENDED $queryd_12;
eval EXPLAIN EXTENDED $queryd_13;
eval EXPLAIN EXTENDED $queryd_14;

eval $queryd_1;
eval $query_s1;
ROLLBACK;
eval $queryd_2;
eval $query_s1;
ROLLBACK;
eval $queryd_3;
eval $query_s1;
ROLLBACK;
eval $queryd_4;
eval $query_s1;
ROLLBACK;
eval $queryd_5;
eval $query_s1;
ROLLBACK;
eval $queryd_6;
eval $query_s1;
ROLLBACK;
eval $queryd_7;
eval $query_s2;
ROLLBACK;
eval $queryd_8;
eval $query_s2;
ROLLBACK;
eval $queryd_9;
eval $query_s5;
ROLLBACK;
eval $queryd_10;
eval $query_s5;
ROLLBACK;
eval $queryd_11;
eval $query_s5;
ROLLBACK;
eval $queryd_12;
eval $query_s5;
ROLLBACK;
eval $queryd_13;
eval $query_s5;
ROLLBACK;
eval $queryd_14;
eval $query_s5;
ROLLBACK;

--echo # The following queries would select Materialize based on the optimizer switch settings
--echo # Please note that some of the queries would still show Duplicate Weedout

SET optimizer_switch='semijoin=on,loosescan=off,firstmatch=off,index_condition_pushdown=off,mrr=off,materialization=on';
COMMIT;

eval EXPLAIN EXTENDED $queryd_1;
eval EXPLAIN EXTENDED $queryd_2;
eval EXPLAIN EXTENDED $queryd_3;
eval EXPLAIN EXTENDED $queryd_4;
eval EXPLAIN EXTENDED $queryd_5;
eval EXPLAIN EXTENDED $queryd_6;
eval EXPLAIN EXTENDED $queryd_7;
eval EXPLAIN EXTENDED $queryd_8;
eval EXPLAIN EXTENDED $queryd_9;
eval EXPLAIN EXTENDED $queryd_10;
eval EXPLAIN EXTENDED $queryd_11;
eval EXPLAIN EXTENDED $queryd_12;
eval EXPLAIN EXTENDED $queryd_13;
eval EXPLAIN EXTENDED $queryd_14;

eval $queryd_1;
eval $query_s1;
ROLLBACK;
eval $queryd_2;
eval $query_s1;
ROLLBACK;
eval $queryd_3;
eval $query_s1;
ROLLBACK;
eval $queryd_4;
eval $query_s1;
ROLLBACK;
eval $queryd_5;
eval $query_s1;
ROLLBACK;
eval $queryd_6;
eval $query_s1;
ROLLBACK;
eval $queryd_7;
eval $query_s2;
ROLLBACK;
eval $queryd_8;
eval $query_s2;
ROLLBACK;
eval $queryd_9;
eval $query_s5;
ROLLBACK;
eval $queryd_10;
eval $query_s5;
ROLLBACK;
eval $queryd_11;
eval $query_s5;
ROLLBACK;
eval $queryd_12;
eval $query_s5;
ROLLBACK;
eval $queryd_13;
eval $query_s5;
ROLLBACK;
eval $queryd_14;
eval $query_s5;
ROLLBACK;

--echo # The following queries would select Duplicate Weedout strategy based on the optimizer switch settings

SET optimizer_switch='loosescan=off,firstmatch=off,index_condition_pushdown=off,mrr=off,semijoin=on,materialization=off';
COMMIT;

eval EXPLAIN EXTENDED $queryd_1;
eval EXPLAIN EXTENDED $queryd_2;
eval EXPLAIN EXTENDED $queryd_3;
eval EXPLAIN EXTENDED $queryd_4;
eval EXPLAIN EXTENDED $queryd_5;
eval EXPLAIN EXTENDED $queryd_6;
eval EXPLAIN EXTENDED $queryd_7;
eval EXPLAIN EXTENDED $queryd_8;
eval EXPLAIN EXTENDED $queryd_9;
eval EXPLAIN EXTENDED $queryd_10;
eval EXPLAIN EXTENDED $queryd_11;
eval EXPLAIN EXTENDED $queryd_12;
eval EXPLAIN EXTENDED $queryd_13;
eval EXPLAIN EXTENDED $queryd_14;

eval $queryd_1;
eval $query_s1;
ROLLBACK;
eval $queryd_2;
eval $query_s1;
ROLLBACK;
eval $queryd_3;
eval $query_s1;
ROLLBACK;
eval $queryd_4;
eval $query_s1;
ROLLBACK;
eval $queryd_5;
eval $query_s1;
ROLLBACK;
eval $queryd_6;
eval $query_s1;
ROLLBACK;
eval $queryd_7;
eval $query_s2;
ROLLBACK;
eval $queryd_8;
eval $query_s2;
ROLLBACK;
eval $queryd_9;
eval $query_s5;
ROLLBACK;
eval $queryd_10;
eval $query_s5;
ROLLBACK;
eval $queryd_11;
eval $query_s5;
ROLLBACK;
eval $queryd_12;
eval $query_s5;
ROLLBACK;
eval $queryd_13;
eval $query_s5;
ROLLBACK;
eval $queryd_14;
eval $query_s5;
ROLLBACK;

--echo # The following queries would select Loosescan strategy based on the optimizer switch settings
--echo # Please note that some of the queries would still show Duplicate Weedout

SET optimizer_switch='loosescan=on,firstmatch=off,index_condition_pushdown=off,mrr=off,semijoin=on,materialization=off';
COMMIT;

eval EXPLAIN EXTENDED $queryd_1;
eval EXPLAIN EXTENDED $queryd_2;
eval EXPLAIN EXTENDED $queryd_3;
eval EXPLAIN EXTENDED $queryd_4;
eval EXPLAIN EXTENDED $queryd_5;
eval EXPLAIN EXTENDED $queryd_6;
eval EXPLAIN EXTENDED $queryd_7;
eval EXPLAIN EXTENDED $queryd_8;
eval EXPLAIN EXTENDED $queryd_9;
eval EXPLAIN EXTENDED $queryd_10;
eval EXPLAIN EXTENDED $queryd_11;
eval EXPLAIN EXTENDED $queryd_12;
eval EXPLAIN EXTENDED $queryd_13;
eval EXPLAIN EXTENDED $queryd_14;

eval $queryd_1;
eval $query_s1;
ROLLBACK;
eval $queryd_2;
eval $query_s1;
ROLLBACK;
eval $queryd_3;
eval $query_s1;
ROLLBACK;
eval $queryd_4;
eval $query_s1;
ROLLBACK;
eval $queryd_5;
eval $query_s1;
ROLLBACK;
eval $queryd_6;
eval $query_s1;
ROLLBACK;
eval $queryd_7;
eval $query_s2;
ROLLBACK;
eval $queryd_8;
eval $query_s2;
ROLLBACK;
eval $queryd_9;
eval $query_s5;
ROLLBACK;
eval $queryd_10;
eval $query_s5;
ROLLBACK;
eval $queryd_11;
eval $query_s5;
ROLLBACK;
eval $queryd_12;
eval $query_s5;
ROLLBACK;
eval $queryd_13;
eval $query_s5;
ROLLBACK;
eval $queryd_14;
eval $query_s5;
ROLLBACK;

-- echo # Drop the tables that were created

DROP TABLE tz;
DROP TABLE ty;
DROP TABLE tx;
DROP TABLE roster;
DROP TABLE student;
DROP TABLE class;
COMMIT;

###################################### The following set of queries are verified for UPDATE on partitioned tables ################################################

--echo # Verifying the feature with partitioned table

CREATE TABLE emp  (
    id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
    fname VARCHAR(25) NOT NULL,
    lname VARCHAR(25) NOT NULL,
    store_id INT NOT NULL,
    dept_id INT NOT NULL,
    KEY(dept_id)
) ENGINE=INNODB   
    PARTITION BY RANGE(id)  (
        PARTITION p0 VALUES LESS THAN (5),
        PARTITION p1 VALUES LESS THAN (10),
        PARTITION p2 VALUES LESS THAN (15),
        PARTITION p3 VALUES LESS THAN MAXVALUE
);

CREATE TABLE dept (
    dept_id INT NOT NULL,
    dept_name varchar(25) NOT NULL,
    KEY(dept_id)
) ENGINE=INNODB
    PARTITION BY RANGE(dept_id) (
        PARTITION p0 VALUES LESS THAN (3),
        PARTITION p1 VALUES LESS THAN (6),
        PARTITION p3 VALUES LESS THAN MAXVALUE
);

INSERT INTO emp(fname, lname, store_id, dept_id) VALUES
    ('Bob', 'Taylor', 3, 2), ('Frank', 'Williams', 1, 2), 
    ('Ellen', 'Johnson', 3, 4), ('Jim', 'Smith', 2, 4),  
    ('Mary', 'Jones', 1, 1), ('Linda', 'Black', 2, 3),
    ('Ed', 'Jones', 2, 1), ('June', 'Wilson', 3, 1), 
    ('Andy', 'Smith', 1, 3), ('Lou', 'Waters', 2, 4),  
    ('Jill', 'Stone', 1, 4), ('Roger', 'White', 3, 2),
    ('Howard', 'Andrews', 1, 2), ('Fred', 'Goldberg', 3, 3), 
    ('Barbara', 'Brown', 2, 3), ('Alice', 'Rogers', 2, 2),  
    ('Mark', 'Morgan', 3, 3), ('Karen', 'Cole', 3, 2);

INSERT INTO dept VALUES
    (1,'admin'),(2, 'finance'),
    (3,'IT'),(4, 'security'),
    (5,'ref'),(6,'services');
COMMIT;

--echo # Verfying with partitioned tables keeping the default optimizer_switch settings

let $query5a = UPDATE emp PARTITION(p1,p3) JOIN dept ON emp.dept_id = dept.dept_id 
	       SET emp.store_id = 500 
	       WHERE emp.dept_id IN (SELECT dept_id from dept);

let $query5b = UPDATE emp PARTITION(p1,p0) JOIN dept ON emp.dept_id = dept.dept_id 
	       SET emp.store_id = 500 
	       WHERE dept.dept_id IN (SELECT dept_id from dept);

let $query5c = UPDATE emp PARTITION(p0,p3) RIGHT JOIN dept ON emp.dept_id = dept.dept_id 
	       SET emp.store_id = 500 
	       WHERE emp.dept_id IN (SELECT dept_id from dept);

let $query5d = UPDATE LOW_PRIORITY emp PARTITION(p3,p2,p0) JOIN dept ON emp.dept_id = dept.dept_id 
	       SET emp.store_id = 500 
	       WHERE emp.dept_id IN (SELECT dept_id from dept);

let $query5e = UPDATE IGNORE emp PARTITION(p3,p1,p2,p0) JOIN dept ON emp.dept_id = dept.dept_id 
	       SET emp.store_id = 500 
	       WHERE emp.dept_id IN (SELECT dept_id from dept);

let $query5f = UPDATE emp LEFT JOIN dept PARTITION(p0) ON emp.dept_id = dept.dept_id 
	       SET dept.dept_name = 'Junk' 
	       WHERE dept.dept_id IN (SELECT dept_id from emp);

let $query5g = UPDATE emp INNER JOIN dept PARTITION(p1,p0) ON emp.dept_id = dept.dept_id 
	       SET dept.dept_name = 'Junk' 
	       WHERE dept.dept_id IN (SELECT DISTINCT dept_id from emp);

let $query5h = UPDATE emp PARTITION(p0,p2), dept 
	       SET emp.store_id = 500 
	       WHERE emp.dept_id IN (SELECT dept_id FROM dept);

let $query5i = UPDATE emp INNER JOIN dept ON emp.dept_id = dept.dept_id 
	       SET emp.store_id = 500, emp.lname = 'not SET', emp.fname = 'not SET' 
	       WHERE emp.dept_id IN (SELECT dept_id FROM dept);

let $query5j = UPDATE emp INNER JOIN dept ON emp.dept_id = dept.dept_id AND emp.fname = 'Bob' OR emp.lname = 'Cole' 
	       SET emp.store_id = 500, emp.lname = 'not SET', emp.fname = 'not SET' 
	       WHERE emp.dept_id IN (SELECT dept_id FROM dept);

let $query5k = UPDATE emp PARTITION(p0,p1,p2) INNER JOIN dept ON emp.dept_id = dept.dept_id 
	       SET emp.store_id = 500 
	       WHERE emp.dept_id IN (SELECT dept_id FROM dept);

let $query5l = UPDATE emp PARTITION(p1,p3) JOIN dept ON emp.dept_id IN (SELECT dept_id FROM dept) 
	       SET emp.store_id = 500;

let $queryd_5a = DELETE emp FROM emp PARTITION(p1,p3) JOIN dept 
		 ON emp.dept_id = dept.dept_id 
		 WHERE emp.dept_id IN (SELECT dept_id from dept);

let $queryd_5b = DELETE FROM emp USING emp PARTITION(p0) JOIN dept 
		 ON emp.dept_id = dept.dept_id 
		 WHERE dept.dept_id IN (SELECT dept_id from dept);

let $queryd_5c = DELETE QUICK emp FROM emp PARTITION(p1,p2,p3) RIGHT JOIN dept 
		 ON emp.dept_id = dept.dept_id 
		 WHERE emp.dept_id IN (SELECT dept_id from dept);

let $queryd_5d = DELETE LOW_PRIORITY emp FROM emp PARTITION(p3,p0) JOIN dept 
		 ON emp.dept_id = dept.dept_id 
		 WHERE emp.dept_id IN (SELECT dept_id from dept);

let $queryd_5e = DELETE IGNORE emp FROM emp JOIN dept 
		 ON emp.dept_id = dept.dept_id 
		 WHERE emp.dept_id IN (SELECT dept_id from dept);

let $queryd_5f = DELETE emp FROM emp PARTITION(p1,p3,p0) LEFT JOIN dept 
		 ON emp.dept_id = dept.dept_id 
		 WHERE emp.dept_id IN (SELECT dept_id from dept);

let $queryd_5g = DELETE emp FROM emp PARTITION(p1,p3,p0,p2) INNER JOIN dept 
		 ON emp.dept_id = dept.dept_id 
		 WHERE emp.dept_id IN (SELECT dept_id from dept);

let $query5_s1 = SELECT * FROM emp;

let $query5_s2 = SELECT * FROM dept;

eval EXPLAIN EXTENDED $query5a;
eval EXPLAIN EXTENDED $query5b;
eval EXPLAIN EXTENDED $query5c;
eval EXPLAIN EXTENDED $query5d;
eval EXPLAIN EXTENDED $query5e;
eval EXPLAIN EXTENDED $query5f;
eval EXPLAIN EXTENDED $query5g;
eval EXPLAIN EXTENDED $query5h;
eval EXPLAIN EXTENDED $query5i;
eval EXPLAIN EXTENDED $query5j;
eval EXPLAIN EXTENDED $query5k;
eval EXPLAIN EXTENDED $query5l;
eval EXPLAIN EXTENDED $queryd_5a;
eval EXPLAIN EXTENDED $queryd_5b;
eval EXPLAIN EXTENDED $queryd_5c;
eval EXPLAIN EXTENDED $queryd_5d;
eval EXPLAIN EXTENDED $queryd_5e;
eval EXPLAIN EXTENDED $queryd_5f;
eval EXPLAIN EXTENDED $queryd_5g;

eval $query5a;
eval $query5_s1;
ROLLBACK;
eval $query5b;
eval $query5_s1;
ROLLBACK;
eval $query5c;
eval $query5_s1;
ROLLBACK;
eval $query5d;
eval $query5_s1;
ROLLBACK;
eval $query5e;
eval $query5_s1;
ROLLBACK;
eval $query5f;
eval $query5_s2;
ROLLBACK;
eval $query5g;
eval $query5_s2;
ROLLBACK;
eval $query5h;
eval $query5_s1;
ROLLBACK;
eval $query5i;
eval $query5_s1;
ROLLBACK;
eval $query5j;
eval $query5_s1;
ROLLBACK;
eval $query5k;
eval $query5_s1;
ROLLBACK;
eval $query5l;
eval $query5_s1;
ROLLBACK;
eval $queryd_5a;
eval $query5_s1;
ROLLBACK;
eval $queryd_5b;
eval $query5_s1;
ROLLBACK;
eval $queryd_5c;
eval $query5_s1;
ROLLBACK;
eval $queryd_5d;
eval $query5_s1;
ROLLBACK;
eval $queryd_5e;
eval $query5_s1;
ROLLBACK;
eval $queryd_5f;
eval $query5_s2;
ROLLBACK;
eval $queryd_5g;
eval $query5_s2;
ROLLBACK;

--echo # Tables are partitioned, queries uses Firstmatch
--echo # Please note that some of the queries would still show Duplicate Weedout

SET optimizer_switch='semijoin=on,firstmatch=on,materialization=off,loosescan=off,index_condition_pushdown=off,mrr=off';
COMMIT;

eval EXPLAIN EXTENDED $query5a;
eval EXPLAIN EXTENDED $query5b;
eval EXPLAIN EXTENDED $query5c;
eval EXPLAIN EXTENDED $query5d;
eval EXPLAIN EXTENDED $query5e;
eval EXPLAIN EXTENDED $query5f;
eval EXPLAIN EXTENDED $query5g;
eval EXPLAIN EXTENDED $query5h;
eval EXPLAIN EXTENDED $query5i;
eval EXPLAIN EXTENDED $query5j;
eval EXPLAIN EXTENDED $query5k;
eval EXPLAIN EXTENDED $query5l;
eval EXPLAIN EXTENDED $queryd_5a;
eval EXPLAIN EXTENDED $queryd_5b;
eval EXPLAIN EXTENDED $queryd_5c;
eval EXPLAIN EXTENDED $queryd_5d;
eval EXPLAIN EXTENDED $queryd_5e;
eval EXPLAIN EXTENDED $queryd_5f;
eval EXPLAIN EXTENDED $queryd_5g;

eval $query5a;
eval $query5_s1;
ROLLBACK;
eval $query5b;
eval $query5_s1;
ROLLBACK;
eval $query5c;
eval $query5_s1;
ROLLBACK;
eval $query5d;
eval $query5_s1;
ROLLBACK;
eval $query5e;
eval $query5_s1;
ROLLBACK;
eval $query5f;
eval $query5_s2;
ROLLBACK;
eval $query5g;
eval $query5_s2;
ROLLBACK;
eval $query5h;
eval $query5_s1;
ROLLBACK;
eval $query5i;
eval $query5_s1;
ROLLBACK;
eval $query5j;
eval $query5_s1;
ROLLBACK;
eval $query5k;
eval $query5_s1;
ROLLBACK;
eval $query5l;
eval $query5_s1;
ROLLBACK;
eval $queryd_5a;
eval $query5_s1;
ROLLBACK;
eval $queryd_5b;
eval $query5_s1;
ROLLBACK;
eval $queryd_5c;
eval $query5_s1;
ROLLBACK;
eval $queryd_5d;
eval $query5_s1;
ROLLBACK;
eval $queryd_5e;
eval $query5_s1;
ROLLBACK;
eval $queryd_5f;
eval $query5_s2;
ROLLBACK;
eval $queryd_5g;
eval $query5_s2;
ROLLBACK;

--echo # Tables are partitioned, queries uses Materialization
--echo # Please note that some of the queries would still show Duplicate Weedout

SET optimizer_switch='loosescan=off,firstmatch=off,index_condition_pushdown=off,mrr=off,semijoin=on,materialization=on';
COMMIT;

eval EXPLAIN EXTENDED $query5a;
eval EXPLAIN EXTENDED $query5b;
eval EXPLAIN EXTENDED $query5c;
eval EXPLAIN EXTENDED $query5d;
eval EXPLAIN EXTENDED $query5e;
eval EXPLAIN EXTENDED $query5f;
eval EXPLAIN EXTENDED $query5g;
eval EXPLAIN EXTENDED $query5h;
eval EXPLAIN EXTENDED $query5i;
eval EXPLAIN EXTENDED $query5j;
eval EXPLAIN EXTENDED $query5k;
eval EXPLAIN EXTENDED $query5l;
eval EXPLAIN EXTENDED $queryd_5a;
eval EXPLAIN EXTENDED $queryd_5b;
eval EXPLAIN EXTENDED $queryd_5c;
eval EXPLAIN EXTENDED $queryd_5d;
eval EXPLAIN EXTENDED $queryd_5e;
eval EXPLAIN EXTENDED $queryd_5f;
eval EXPLAIN EXTENDED $queryd_5g;

eval $query5a;
eval $query5_s1;
ROLLBACK;
eval $query5b;
eval $query5_s1;
ROLLBACK;
eval $query5c;
eval $query5_s1;
ROLLBACK;
eval $query5d;
eval $query5_s1;
ROLLBACK;
eval $query5e;
eval $query5_s1;
ROLLBACK;
eval $query5f;
eval $query5_s2;
ROLLBACK;
eval $query5g;
eval $query5_s2;
ROLLBACK;
eval $query5h;
eval $query5_s1;
ROLLBACK;
eval $query5i;
eval $query5_s1;
ROLLBACK;
eval $query5j;
eval $query5_s1;
ROLLBACK;
eval $query5k;
eval $query5_s1;
ROLLBACK;
eval $query5l;
eval $query5_s1;
ROLLBACK;
eval $queryd_5a;
eval $query5_s1;
ROLLBACK;
eval $queryd_5b;
eval $query5_s1;
ROLLBACK;
eval $queryd_5c;
eval $query5_s1;
ROLLBACK;
eval $queryd_5d;
eval $query5_s1;
ROLLBACK;
eval $queryd_5e;
eval $query5_s1;
ROLLBACK;
eval $queryd_5f;
eval $query5_s2;
ROLLBACK;
eval $queryd_5g;
eval $query5_s2;
ROLLBACK;

--echo # Tables are partitioned, queries uses Duplicate Weedout strategy

SET optimizer_switch='loosescan=off,firstmatch=off,index_condition_pushdown=off,mrr=off,semijoin=on,materialization=off';
COMMIT;

eval EXPLAIN EXTENDED $query5a;
eval EXPLAIN EXTENDED $query5b;
eval EXPLAIN EXTENDED $query5c;
eval EXPLAIN EXTENDED $query5d;
eval EXPLAIN EXTENDED $query5e;
eval EXPLAIN EXTENDED $query5f;
eval EXPLAIN EXTENDED $query5g;
eval EXPLAIN EXTENDED $query5h;
eval EXPLAIN EXTENDED $query5i;
eval EXPLAIN EXTENDED $query5j;
eval EXPLAIN EXTENDED $query5k;
eval EXPLAIN EXTENDED $query5l;
eval EXPLAIN EXTENDED $queryd_5a;
eval EXPLAIN EXTENDED $queryd_5b;
eval EXPLAIN EXTENDED $queryd_5c;
eval EXPLAIN EXTENDED $queryd_5d;
eval EXPLAIN EXTENDED $queryd_5e;
eval EXPLAIN EXTENDED $queryd_5f;
eval EXPLAIN EXTENDED $queryd_5g;

eval $query5a;
eval $query5_s1;
ROLLBACK;
eval $query5b;
eval $query5_s1;
ROLLBACK;
eval $query5c;
eval $query5_s1;
ROLLBACK;
eval $query5d;
eval $query5_s1;
ROLLBACK;
eval $query5e;
eval $query5_s1;
ROLLBACK;
eval $query5f;
eval $query5_s2;
ROLLBACK;
eval $query5g;
eval $query5_s2;
ROLLBACK;
eval $query5h;
eval $query5_s1;
ROLLBACK;
eval $query5i;
eval $query5_s1;
ROLLBACK;
eval $query5j;
eval $query5_s1;
ROLLBACK;
eval $query5k;
eval $query5_s1;
ROLLBACK;
eval $query5l;
eval $query5_s1;
ROLLBACK;
eval $queryd_5a;
eval $query5_s1;
ROLLBACK;
eval $queryd_5b;
eval $query5_s1;
ROLLBACK;
eval $queryd_5c;
eval $query5_s1;
ROLLBACK;
eval $queryd_5d;
eval $query5_s1;
ROLLBACK;
eval $queryd_5e;
eval $query5_s1;
ROLLBACK;
eval $queryd_5f;
eval $query5_s2;
ROLLBACK;
eval $queryd_5g;
eval $query5_s2;
ROLLBACK;

--echo # Tables are partitioned, queries uses Loosescan strategy
--echo # Please note that some of the queries would still show Duplicate Weedout

SET optimizer_switch='loosescan=on,firstmatch=off,index_condition_pushdown=off,mrr=off,semijoin=on,materialization=off';
COMMIT;

eval EXPLAIN EXTENDED $query5a;
eval EXPLAIN EXTENDED $query5b;
eval EXPLAIN EXTENDED $query5c;
eval EXPLAIN EXTENDED $query5d;
eval EXPLAIN EXTENDED $query5e;
eval EXPLAIN EXTENDED $query5f;
eval EXPLAIN EXTENDED $query5g;
eval EXPLAIN EXTENDED $query5h;
eval EXPLAIN EXTENDED $query5i;
eval EXPLAIN EXTENDED $query5j;
eval EXPLAIN EXTENDED $query5k;
eval EXPLAIN EXTENDED $query5l;
eval EXPLAIN EXTENDED $queryd_5a;
eval EXPLAIN EXTENDED $queryd_5b;
eval EXPLAIN EXTENDED $queryd_5c;
eval EXPLAIN EXTENDED $queryd_5d;
eval EXPLAIN EXTENDED $queryd_5e;
eval EXPLAIN EXTENDED $queryd_5f;
eval EXPLAIN EXTENDED $queryd_5g;

eval $query5a;
eval $query5_s1;
ROLLBACK;
eval $query5b;
eval $query5_s1;
ROLLBACK;
eval $query5c;
eval $query5_s1;
ROLLBACK;
eval $query5d;
eval $query5_s1;
ROLLBACK;
eval $query5e;
eval $query5_s1;
ROLLBACK;
eval $query5f;
eval $query5_s2;
ROLLBACK;
eval $query5g;
eval $query5_s2;
ROLLBACK;
eval $query5h;
eval $query5_s1;
ROLLBACK;
eval $query5i;
eval $query5_s1;
ROLLBACK;
eval $query5j;
eval $query5_s1;
ROLLBACK;
eval $query5k;
eval $query5_s1;
ROLLBACK;
eval $query5l;
eval $query5_s1;
ROLLBACK;
eval $queryd_5a;
eval $query5_s1;
ROLLBACK;
eval $queryd_5b;
eval $query5_s1;
ROLLBACK;
eval $queryd_5c;
eval $query5_s1;
ROLLBACK;
eval $queryd_5d;
eval $query5_s1;
ROLLBACK;
eval $queryd_5e;
eval $query5_s1;
ROLLBACK;
eval $queryd_5f;
eval $query5_s2;
ROLLBACK;
eval $queryd_5g;
eval $query5_s2;
ROLLBACK;

--echo # Tables are partitioned, queries with default optimizer_switch settings

SET optimizer_switch=default;
COMMIT;

eval EXPLAIN EXTENDED $query5a;
eval EXPLAIN EXTENDED $query5b;
eval EXPLAIN EXTENDED $query5c;
eval EXPLAIN EXTENDED $query5d;
eval EXPLAIN EXTENDED $query5e;
eval EXPLAIN EXTENDED $query5f;
eval EXPLAIN EXTENDED $query5g;
eval EXPLAIN EXTENDED $query5h;
eval EXPLAIN EXTENDED $query5i;
eval EXPLAIN EXTENDED $query5j;
eval EXPLAIN EXTENDED $query5k;
eval EXPLAIN EXTENDED $query5l;
eval EXPLAIN EXTENDED $queryd_5a;
eval EXPLAIN EXTENDED $queryd_5b;
eval EXPLAIN EXTENDED $queryd_5c;
eval EXPLAIN EXTENDED $queryd_5d;
eval EXPLAIN EXTENDED $queryd_5e;
eval EXPLAIN EXTENDED $queryd_5f;
eval EXPLAIN EXTENDED $queryd_5g;

eval $query5a;
eval $query5_s1;
ROLLBACK;
eval $query5b;
eval $query5_s1;
ROLLBACK;
eval $query5c;
eval $query5_s1;
ROLLBACK;
eval $query5d;
eval $query5_s1;
ROLLBACK;
eval $query5e;
eval $query5_s1;
ROLLBACK;
eval $query5f;
eval $query5_s2;
ROLLBACK;
eval $query5g;
eval $query5_s2;
ROLLBACK;
eval $query5h;
eval $query5_s1;
ROLLBACK;
eval $query5i;
eval $query5_s1;
ROLLBACK;
eval $query5j;
eval $query5_s1;
ROLLBACK;
eval $query5k;
eval $query5_s1;
ROLLBACK;
eval $query5l;
eval $query5_s1;
ROLLBACK;
eval $queryd_5a;
eval $query5_s1;
ROLLBACK;
eval $queryd_5b;
eval $query5_s1;
ROLLBACK;
eval $queryd_5c;
eval $query5_s1;
ROLLBACK;
eval $queryd_5d;
eval $query5_s1;
ROLLBACK;
eval $queryd_5e;
eval $query5_s1;
ROLLBACK;
eval $queryd_5f;
eval $query5_s2;
ROLLBACK;
eval $queryd_5g;
eval $query5_s2;
ROLLBACK;

DROP TABLE emp;
DROP TABLE dept;
COMMIT;

################### Multi-table UPDATE on tables having BLOB data type ##################

-- echo # A test to verify multi-table UPDATE with BLOB data type

CREATE TABLE tb1(c1 TEXT(16), c2 TEXT(16)) ENGINE=INNODB;
CREATE TABLE tb2(c1 TEXT(16)) ENGINE=INNODB;

INSERT INTO tb1 VALUES(repeat('a',1000),repeat('b',1000));
INSERT INTO tb2 VALUES(repeat('a',1000));
COMMIT;

let $query6a = UPDATE tb1 JOIN tb2 ON tb1.c1=tb2.c1 
	       SET tb1.c2='geography' 
	       WHERE tb1.c1 IN (SELECT c1 FROM tb2);

let $query6b = DELETE FROM tb1 USING tb1 JOIN tb2 
	       ON tb1.c1=tb2.c1 
      	       WHERE tb1.c1 IN (SELECT c1 FROM tb2);

eval EXPLAIN EXTENDED $query6a;
eval EXPLAIN EXTENDED $query6b;

eval $query6a;
SELECT * FROM tb1;
ROLLBACK;
eval $query6b;
SELECT * FROM tb1;
ROLLBACK;

DROP TABLE tb1;
DROP TABLE tb2;
COMMIT;

################### Clean up the remaining objects ########################################
DROP TABLE ot1,ot2,ot3,it1,it2,it3;
SET optimizer_switch=default;
COMMIT;
