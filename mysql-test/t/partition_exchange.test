#--source include/master-slave.inc
--source include/have_innodb.inc
--source include/have_partition.inc
#--source include/have_binlog_format_statement.inc
# TODO: Verify replication/binlog
create table t (a int,
  b varchar(55),
  primary key (a))
engine =  myisam;
create table tp (a int,
  b varchar(55),
  primary key (a))
engine =  myisam
partition by range (a)
(partition p0 values less than (100),
 partition p1 values less than MAXVALUE);
create table tsp (a int,
  b varchar(55),
  primary key (a))
engine =  myisam
partition by range (a)
subpartition by hash(a)
(partition p0 values less than (100)
 (subpartition sp0,
  subpartition sp1),
 partition p1 values less than MAXVALUE
 (subpartition sp2,
  subpartition sp3));
insert into t values (1, "First value"), (3, "Three"), (5, "Five"), (99, "End of values");
insert into tp values (2, "First value"), (10, "Ten"), (50, "Fifty"), (200, "Two hundred, end of values"), (61, "Sixty one"), (62, "Sixty two"), (63, "Sixty three"), (64, "Sixty four"), (161, "161"), (162, "162"), (163, "163"), (164, "164");
insert into tsp values (2, "First value"), (10, "Ten"), (50, "Fifty"), (200, "Two hundred, end of values"), (61, "Sixty one"), (62, "Sixty two"), (63, "Sixty three"), (64, "Sixty four"), (161, "161"), (162, "162"), (163, "163"), (164, "164");
show create table t;
show create table tp;
--sorted_result
select * from t;
--sorted_result
select * from tp;
ALTER TABLE tp exchange partition p0 with table t;
show create table t;
show create table tp;
--sorted_result
select * from t;
--sorted_result
select * from tp;
ALTER TABLE tp exchange partition p0 with table t;
--sorted_result
select * from t;
--sorted_result
select * from tp;
--error ER_ROW_DOES_NOT_MATCH_PARTITION
ALTER TABLE tp exchange partition p1 with table t;
ALTER TABLE tp exchange partition p1 with table t IGNORE;
show create table t;
show create table tp;
--sorted_result
select * from t;
--sorted_result
select * from tp;
--echo # No need to use ignore on the original partition
ALTER TABLE tp exchange partition p1 with table t;
show create table t;
show create table tp;
--sorted_result
select * from t;
--sorted_result
select * from tp;
--echo # Test list of partitions
--error ER_PARSE_ERROR
ALTER TABLE tp exchange partition p0,p1 with table t ignore;
--error ER_PARSE_ERROR
ALTER TABLE tp exchange partition (p0,p1) with table t;
--error ER_PARSE_ERROR
ALTER TABLE tp exchange partition p0 with table (t,t2) ignore;
--error ER_PARSE_ERROR
ALTER TABLE tp exchange partition p0 with table t,t2;
--error ER_UNKNOWN_PARTITION
ALTER TABLE tp exchange partition non_existent with table t ignore;
--error ER_PARTITION_INSTEAD_OF_SUBPARTITION
ALTER TABLE tsp exchange partition p0 with table t;
show create table t;
show create table tp;
show create table tsp;
--sorted_result
select * from t;
--sorted_result
select * from tp;
--echo # Test exchange partition
ALTER TABLE tp exchange partition p0 with table t ignore;
show create table t;
show create table tp;
--sorted_result
select * from t;
--sorted_result
select * from tp;
ALTER TABLE tp exchange partition p0 with table t;
show create table t;
show create table tp;
--sorted_result
select * from t;
--sorted_result
select * from tp;
ALTER TABLE tp exchange partition p0 with table t;
show create table t;
show create table tp;
--sorted_result
select * from t;
--sorted_result
select * from tp;
--echo # Test exchange subpartition with IGNORE
ALTER TABLE tsp exchange partition sp3 with table t ignore;
show create table t;
show create table tsp;
--sorted_result
select * from t;
--sorted_result
select * from tsp;
ALTER TABLE tsp exchange partition sp3 with table t ignore;
alter table t engine = innodb;
alter table tp engine = innodb;
show create table t;
show create table tp;
--sorted_result
select * from t;
--sorted_result
select * from tp;
ALTER TABLE tp EXCHANGE PARTITION p0 WITH TABLE t IGNORE;
show create table t;
show create table tp;
--sorted_result
select * from t;
--sorted_result
select * from tp;
ALTER TABLE tp EXCHANGE PARTITION p0 WITH TABLE t IGNORE;
--echo # test different engines
alter table t engine = myisam;
alter table tp engine = innodb;
show create table t;
show create table tp;
--error ER_MIX_HANDLER_ERROR
ALTER TABLE tp EXCHANGE PARTITION p0 WITH TABLE t IGNORE;
show create table t;
show create table tp;
--echo # Test different charsets
alter table t engine = myisam;
create table tmp like t;
insert into tmp select * from t;
rename table t to tmp2, tmp to t;
alter table tp engine = myisam;
alter table t character set = koi8r collate koi8r_general_ci;
--error ER_PARTITION_EXCHANGE_DIFFERENT_OPTION
ALTER TABLE tp EXCHANGE PARTITION p0 WITH TABLE t IGNORE;
drop table t;
rename table tmp2 to t;
# test different keys
alter table t add key ba_key (b, a);
alter table tp add key ba_key (b, a);
alter table tsp add key ba_key (b, a);
alter table tp exchange partition p1 with table t IGNORE;
show create table t;
show create table tp;
--sorted_result
select * from t;
--sorted_result
select * from tp;
alter table tp exchange partition p1 with table t IGNORE;
alter table t drop key ba_key;
--error ER_TABLES_DIFFERENT_METADATA
alter table tp exchange partition p1 with table t IGNORE;
alter table t add key b_key (b);
--error ER_TABLES_DIFFERENT_METADATA
alter table tsp exchange partition sp1 with table t IGNORE;
alter table t add key ba_key (b, a);
alter table t drop key b_key;
# test different index types
# test different columns
alter table t change a c int;
--error ER_TABLES_DIFFERENT_METADATA
alter table tsp exchange partition sp1 with table t IGNORE;
alter table t change c a int;
# test different data/index dir
# test different options (row_format, max/min_rows, comments, tablespace,
#                         pack_keys, delay_key_write, checksum etc.
# test foreign keys
--echo # test temporary table
alter table t engine = myisam;
alter table tp engine = myisam;
create temporary table tmp like t;
insert into tmp select * from t;
alter table t rename to tmp2;
alter table tmp rename to t;
show create table t;
show create table tp;
--error ER_PARTITION_EXCHANGE_TEMP_TABLE
ALTER TABLE tp EXCHANGE PARTITION p0 WITH TABLE t IGNORE;
show create table t;
show create table tp;
drop temporary table t;
alter table tmp2 rename to t;
--echo # Test non partitioned table
alter table tp remove partitioning;
--error ER_PARTITION_MGMT_ON_NONPARTITIONED
ALTER TABLE tp EXCHANGE PARTITION p0 WITH TABLE t IGNORE;

# TODO:
# Verify that it is possible to read a table that is going to be exchanged
# (but not write)
# Verify that it is possible to both read and write to the partition that is
# going to be exchanged
# test mdl locking (i.e. together with transactions and other ddl)
# Add test in lc_0-2 to make sure renameing operators is ok with different lc
# Add test to exchange between databases, also check grants.
# Add test for privileges
# check if correct error whithout partitioning support
drop table t, tp, tsp;


--echo # Test with general_log
use mysql;
SET @old_general_log_state = @@global.general_log;
SET GLOBAL general_log = 0;
ALTER TABLE general_log ENGINE = MyISAM;
CREATE TABLE t LIKE general_log;
ALTER TABLE t PARTITION BY RANGE (UNIX_TIMESTAMP(event_time))
(PARTITION p0 VALUES LESS THAN (123456789),
 PARTITION pMAX VALUES LESS THAN MAXVALUE);
--error ER_WRONG_USAGE
ALTER TABLE t EXCHANGE PARTITION p0 WITH TABLE general_log;
ALTER TABLE general_log ENGINE = CSV;
SET @@global.general_log = @old_general_log_state;
DROP TABLE t;
use test;

--echo # Test with LOCK TABLE
# Test with only one table locked at a time, both table locked + read, write

CREATE TABLE tp
(a VARCHAR(24),
 b DATETIME,
 PRIMARY KEY (a,b))
PARTITION BY RANGE COLUMNS (a, b)
(PARTITION p0 VALUES LESS THAN ("Middle", '0000-00-00'),
 PARTITION p1 VALUES LESS THAN (MAXVALUE, '9999-12-31 23:59:59'));
CREATE TABLE t LIKE tp;
ALTER TABLE t REMOVE PARTITIONING;
CREATE TABLE t2 LIKE t;
INSERT INTO tp VALUES ("First in tp", '2000-01-02 03:04:25'), ("Zebra in tp", '0000-00-00 00:00:00'), ("Second in tp", '2010-01-01 05:12:24');
INSERT INTO t VALUES ("First in t", '2000-01-02 03:04:25'), ("a test in t", '0000-00-00 00:00:00'), ("Echo in t", '2010-01-01 05:12:24');
# 3 different kind of locks (none, READ, WRITE) for three different tables.
# 3^3 = 18. The variant with no locks does not need testing -> 17
let $count = 17;
while ($count)
{
let $t_lock = `SELECT (CASE ($count % 3) WHEN 0 THEN 1 WHEN 1 THEN 'WRITE' WHEN 2 THEN 'READ' END)`;
let $tp_lock = `SELECT (CASE ((($count + 2) DIV 3) % 3) WHEN 0 THEN 1 WHEN 1 THEN 'WRITE' WHEN 2 THEN 'READ' END)`;
let $t2_lock = `SELECT (CASE ((($count + 8) DIV 9) % 3) WHEN 0 THEN 1 WHEN 1 THEN 'WRITE' WHEN 2 THEN 'READ' END)`;
--echo # tp_lock '$tp_lock' t_lock '$t_lock' t2_lock '$t2_lock' count '$count'
let $lock_cmd = LOCK TABLE;
let $take_lock = 0;
if (!$t_lock)
{
  let $lock_cmd = $lock_cmd t $t_lock;
  let $take_lock = 1;
}
if (!$tp_lock)
{
  if ($take_lock)
  {
    let $lock_cmd = $lock_cmd, tp $tp_lock;
  }
  if (!$take_lock)
  {
    let $lock_cmd = $lock_cmd tp $tp_lock;
  }
  let $take_lock = 1;
}
if (!$t2_lock)
{
  if ($take_lock)
  {
    let $lock_cmd = $lock_cmd, t2 $t2_lock;
  }
  if (!$take_lock)
  {
    let $lock_cmd = $lock_cmd t2 $t2_lock;
  }
  let $take_lock = 1;
}
if ($take_lock)
{
  eval $lock_cmd;
}
--error 0, ER_TABLE_NOT_LOCKED, ER_TABLE_NOT_LOCKED_FOR_WRITE
ALTER TABLE tp EXCHANGE PARTITION p0 WITH TABLE t;
SHOW WARNINGS;
--error 0, ER_TABLE_NOT_LOCKED, ER_TABLE_NOT_LOCKED_FOR_WRITE
ALTER TABLE tp EXCHANGE PARTITION p0 WITH TABLE t2;
SHOW WARNINGS;
UNLOCK TABLES;
dec $count;
}
DROP TABLE t, t2, tp;
