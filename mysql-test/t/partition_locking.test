--source include/have_innodb.inc
--source include/have_partition.inc

--echo # Original tests for WL#4443

--echo # Must have InnoDB as engine to get the same statistics results.
--echo # embedded uses MyISAM as default. CREATE SELECT uses the default engine.
SET @old_default_storage_engine = @@default_storage_engine;
SET @@default_storage_engine = 'InnoDB';

let $get_handler_status_counts= SELECT * FROM INFORMATION_SCHEMA.SESSION_STATUS
WHERE VARIABLE_NAME LIKE 'HANDLER_%' AND VARIABLE_VALUE > 0;

--let $MYSQLD_DATADIR= `SELECT @@datadir`



CREATE TABLE t1 (a int PRIMARY KEY, b varchar(128), KEY (b))
ENGINE = InnoDB
PARTITION BY HASH (a) PARTITIONS 13;

CREATE TABLE t2 (a int PRIMARY KEY AUTO_INCREMENT, b varchar(128))
ENGINE = InnoDB
PARTITION BY HASH (a) PARTITIONS 13;


--echo #
--echo #
--echo # Test insert
--echo #
FLUSH STATUS;
INSERT INTO t1 VALUES (1, 'First row, p1');
eval $get_handler_status_counts;
--echo # 4 locks (table + partition lock/unlock)
--echo # 1 commit
FLUSH STATUS;
--error ER_DUP_ENTRY
INSERT INTO t1 VALUES (1, 'First row, duplicate');
eval $get_handler_status_counts;
--echo # 4 locks (table + partition lock/unlock)
--echo # 1 commit
FLUSH STATUS;
INSERT INTO t1 VALUES (0, 'First row, p0'), (2, 'First row, p2'),
                      (3, 'First row, p3'), (4, 'First row, p4');
eval $get_handler_status_counts;
--echo # 10 locks (table + 4 partition * lock/unlock)
--echo # 1 commit
FLUSH STATUS;
INSERT INTO t1 VALUES (1 * 13, 'Second row, p0'), (2 * 13, 'Third row, p0'),
                      (3 * 13, 'Fourth row, p0'), (4 * 13, 'Fifth row, p0');
eval $get_handler_status_counts;
--echo # 4 locks (table + 1 partition lock/unlock)
--echo # 1 commit
FLUSH STATUS;
INSERT INTO t2 VALUES (NULL, 'First auto-inc row');
eval $get_handler_status_counts;
--echo # Auto increment value not know until write.
--echo # 28 locks (table + 13 partition lock/unlock)
--echo # 1 commit

FLUSH STATUS;
INSERT INTO t2 (b) VALUES ('Second auto-inc row');
eval $get_handler_status_counts;
--echo # Auto increment value not know until write.
--echo # 28 locks (table + 13 partition lock/unlock)
--echo # 1 commit

--echo #
--echo # Test of pruning with secondary column auto_inc
--echo #
CREATE TABLE t3 (a INT, b INT AUTO_INCREMENT, PRIMARY KEY (a, b))
ENGINE = MyISAM
PARTITION BY HASH (a) PARTITIONS 5;
FLUSH STATUS;
INSERT INTO t3 VALUES (1, 1);
eval $get_handler_status_counts;
--echo # 4 locks (table + partition lock/unlock)
--echo # No commits, since MyISAM!
FLUSH STATUS;
INSERT INTO t3 VALUES (1, NULL);
eval $get_handler_status_counts;
--echo # 4 locks (table + partition lock/unlock)
SELECT @@sql_mode;
SET @old_sql_mode = @@sql_mode;
SET @@sql_mode = 'NO_AUTO_VALUE_ON_ZERO';
SELECT @@sql_mode;
FLUSH STATUS;
INSERT INTO t3 VALUES (1, 0);
eval $get_handler_status_counts;
--echo # 4 locks (table + partition lock/unlock)
SET @@sql_mode = @old_sql_mode;
SELECT @@sql_mode;
FLUSH STATUS;
INSERT INTO t3 VALUES (1, 0);
eval $get_handler_status_counts;
--echo # 4 locks (table + partition lock/unlock)
SELECT * FROM t3;
DROP TABLE t3;

--echo #
--echo # More INSERT pruning tests
--echo #
CREATE TABLE t3 (a INT, b CHAR(10)) PARTITION BY HASH (a) PARTITIONS 2;
FLUSH STATUS;
INSERT INTO t3 VALUES (1, "Test 1");
eval $get_handler_status_counts;
--echo # 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 VALUES (2, "Test 2"), (3, "Test 3"), (4, "Test 4");
eval $get_handler_status_counts;
--echo # 6 locks (1 table, 2 partition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 VALUES (6, "Test 6"), (8, "Test 8"), (10, "Test 10");
eval $get_handler_status_counts;
--echo # 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 VALUES (5, "Test 5"), (7, "Test 7"), (9, "Test 9");
eval $get_handler_status_counts;
--echo # 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 VALUES (0, "Test 0");
eval $get_handler_status_counts;
--echo # 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (a, b) VALUES (1, "Test 1");
eval $get_handler_status_counts;
--echo # 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (a, b) VALUES (2, "Test 2"), (3, "Test 3"), (4, "Test 4");
eval $get_handler_status_counts;
--echo # 6 locks (1 table, 2 partition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (a, b) VALUES (6, "Test 6"), (8, "Test 8"), (10, "Test 10");
eval $get_handler_status_counts;
--echo # 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (a, b) VALUES (5, "Test 5"), (7, "Test 7"), (9, "Test 9");
eval $get_handler_status_counts;
--echo # 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (a, b) VALUES (0, "Test 0");
eval $get_handler_status_counts;
--echo # 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (a) VALUES (1);
eval $get_handler_status_counts;
--echo # 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (a) VALUES (2), (3), (4);
eval $get_handler_status_counts;
--echo # 6 locks (1 table, 2 partition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (a) VALUES (6), (8), (10);
eval $get_handler_status_counts;
--echo # 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (a) VALUES (5), (7), (9);
eval $get_handler_status_counts;
--echo # 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (b) VALUES ("Only b 1");
eval $get_handler_status_counts;
--echo # 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (b) VALUES ("Only b 2"), ("Only b 3");
eval $get_handler_status_counts;
--echo # 4 locks (1 table, 1 partition lock/unlock)
SELECT * FROM t3 ORDER BY a, b;
DROP TABLE t3;

--echo #
--echo # Test of insert pruning with subpartitions
--echo #
--echo # I've place the varchar column before the int column for better
--echo # distribution by LINEAR KEY.
CREATE TABLE t3
(a int DEFAULT 10,
 b varchar(64) DEFAULT "Default",
 c varchar(64) DEFAULT "Default",
 d int unsigned DEFAULT 9,
 e varchar(255) DEFAULT "Default-filler.filler.filler.",
 PRIMARY KEY (a,b,c,d))
PARTITION BY RANGE COLUMNS (a, b)
SUBPARTITION BY LINEAR KEY (d, c)
SUBPARTITIONS 4
(PARTITION pNeg VALUES LESS THAN (-1, MAXVALUE),
 PARTITION `p0-9` VALUES LESS THAN (9, MAXVALUE),
 PARTITION p10 VALUES LESS THAN (10, MAXVALUE),
 PARTITION `p11-100` VALUES LESS THAN (99, MAXVALUE));
FLUSH STATUS;
INSERT INTO t3 () VALUES ();
eval $get_handler_status_counts;
--echo # 4 locks (1 table, 1 subpartition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 VALUES (-1, "ZZZzzzz", "yyyYYY", -1, DEFAULT);
eval $get_handler_status_counts;
--echo # 4 locks (1 table, 1 subpartition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 () VALUES (0, "", "", 0, NULL);
eval $get_handler_status_counts;
--echo # 4 locks (1 table, 1 subpartition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (a) VALUES (1);
eval $get_handler_status_counts;
--echo # 4 locks (1 table, 1 subpartition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (a, b) VALUES (1, "Part expr fulfilled"),
                             (10, "Part expr fulfilled");
eval $get_handler_status_counts;
--echo # 6 locks (1 table, 2 subpartition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (d) VALUES (1), (2);
eval $get_handler_status_counts;
--echo # 6 locks (1 table, 2 subpartition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (c, d) VALUES ("Subpart expr fulfilled", 1);
eval $get_handler_status_counts;
--echo # 4 locks (1 table, 1 subpartition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (a, b, d) VALUES (10, "Full part, half subpart", 1),
                                (12, "Full part, half subpart", 1),
                                (12, "Full part, half subpart", 2),
                                (12, "Full part, half subpart", 3),
                                (12, "Full part, half subpart", 4),
                                (12, "Full part, half subpart", 0);
eval $get_handler_status_counts;
--echo # d = 0 and d = 4 goes to the same subpart!
--echo # 12 locks (1 table, 5 subpartition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (a, b, c) VALUES (1, "Full part", "Half subpart");
eval $get_handler_status_counts;
--echo # 4 locks (1 table, 1 subpartition lock/unlock)
--echo # Adding 'Default' as padding to see if LINEAR KEY uses different parts.
FLUSH STATUS;
INSERT INTO t3 (a, c, d) VALUES (12, "Half part, full subpart", 1),
                                (12, "Half part, full subpartDefault", 1),
                                (12, "Half part, full subpart Default", 1);
eval $get_handler_status_counts;
--echo # First and last row goes to the same subpartition.
--echo # 6 locks (1 table, 2 subpartition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (b, c, d) VALUES ("Half part", "Full subpart", 1);
eval $get_handler_status_counts;
--echo # 4 locks (1 table, 1 subpartition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (a, b, c, d) VALUES (1, "Full part", "Full subpart", 1);
eval $get_handler_status_counts;
--echo # 4 locks (1 table, 1 subpartition lock/unlock)

--sorted_result
SELECT * FROM t3;
--sorted_result
SELECT d, c FROM t3 PARTITION(`p11-100sp0`);
--sorted_result
SELECT d, c FROM t3 PARTITION(`p11-100sp1`);
--sorted_result
SELECT d, c FROM t3 PARTITION(`p11-100sp2`);
--sorted_result
SELECT d, c FROM t3 PARTITION(`p11-100sp3`);

DROP TABLE t3;

--echo #
--echo # Test insert with timestamp column
--echo #
CREATE TABLE t3
(a timestamp DEFAULT 0,
 b char(10),
 PRIMARY KEY (a, b))
PARTITION BY HASH (UNIX_TIMESTAMP(a)) PARTITIONS 3;
FLUSH STATUS;
INSERT INTO t3 (a) VALUES (NULL);
SHOW CREATE TABLE t3;
eval $get_handler_status_counts;
--echo # 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (a) VALUES ('2011-01-01 00:00:00');
eval $get_handler_status_counts;
--echo # 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (a) VALUES ('2011-01-01 00:00:01');
eval $get_handler_status_counts;
--echo # 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (a) VALUES ('2011-01-01 00:00:02'), ('2011-01-01 00:00:03');
eval $get_handler_status_counts;
--echo # 6 locks (1 table, 2 partition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (a) VALUES ('2011-01-01 00:00:00')
ON DUPLICATE KEY UPDATE b = CONCAT(b, ", DUP_KEY");
eval $get_handler_status_counts;
--echo # 4 locks (1 table, 1 partition lock/unlock)
SELECT COUNT(*) FROM t3;
DROP TABLE t3;
CREATE TABLE t3
(a timestamp DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
 b char(10),
 PRIMARY KEY (a, b))
PARTITION BY HASH (UNIX_TIMESTAMP(a)) PARTITIONS 3;
SHOW CREATE TABLE t3;
FLUSH STATUS;
INSERT INTO t3 (a) VALUES (NULL);
eval $get_handler_status_counts;
--echo # 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (a) VALUES ('2011-01-01 00:00:00');
eval $get_handler_status_counts;
--echo # 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (a) VALUES ('2011-01-01 00:00:01');
eval $get_handler_status_counts;
--echo # 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (a) VALUES ('2011-01-01 00:00:02'), ('2011-01-01 00:00:03');
eval $get_handler_status_counts;
--echo # 6 locks (1 table, 2 partition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (a) VALUES ('2011-01-01 00:00:00')
ON DUPLICATE KEY UPDATE b = CONCAT(b, ", DUP_KEY");
#eval $get_handler_status_counts;
--echo # May change partition, so gives different UPDATE/DELETE/WRITE count
SHOW STATUS LIKE 'Handler_external_lock';
--echo # 8 locks (1 table, 3 partition lock/unlock)
SELECT COUNT(*) FROM t3;
DROP TABLE t3;
CREATE TABLE t3
(a timestamp DEFAULT 0 ON UPDATE CURRENT_TIMESTAMP,
 b char(10),
 PRIMARY KEY (a, b))
PARTITION BY HASH (UNIX_TIMESTAMP(a)) PARTITIONS 3;
SHOW CREATE TABLE t3;
FLUSH STATUS;
INSERT INTO t3 (a) VALUES (NULL);
eval $get_handler_status_counts;
--echo # 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (a) VALUES ('2011-01-01 00:00:00');
eval $get_handler_status_counts;
--echo # 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (a) VALUES ('2011-01-01 00:00:01');
eval $get_handler_status_counts;
--echo # 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (a) VALUES ('2011-01-01 00:00:02'), ('2011-01-01 00:00:03');
eval $get_handler_status_counts;
--echo # 6 locks (1 table, 2 partition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (a) VALUES ('2011-01-01 00:00:00')
ON DUPLICATE KEY UPDATE b = CONCAT(b, ", DUP_KEY");
#eval $get_handler_status_counts;
--echo # May change partition, so gives different UPDATE/DELETE/WRITE count
SHOW STATUS LIKE 'Handler_external_lock';
--echo # 8 locks (1 table, 3 partition lock/unlock)
SELECT COUNT(*) FROM t3;
DROP TABLE t3;
CREATE TABLE t3
(a timestamp DEFAULT CURRENT_TIMESTAMP,
 b char(10),
 PRIMARY KEY (a, b))
PARTITION BY HASH (UNIX_TIMESTAMP(a)) PARTITIONS 3;
SHOW CREATE TABLE t3;
FLUSH STATUS;
INSERT INTO t3 (a) VALUES (NULL);
eval $get_handler_status_counts;
--echo # 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (a) VALUES ('2011-01-01 00:00:00');
eval $get_handler_status_counts;
--echo # 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (a) VALUES ('2011-01-01 00:00:01');
eval $get_handler_status_counts;
--echo # 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (a) VALUES ('2011-01-01 00:00:02'), ('2011-01-01 00:00:03');
eval $get_handler_status_counts;
--echo # 6 locks (1 table, 2 partition lock/unlock)
FLUSH STATUS;
INSERT INTO t3 (a) VALUES ('2011-01-01 00:00:00')
ON DUPLICATE KEY UPDATE b = CONCAT(b, ", DUP_KEY");
eval $get_handler_status_counts;
--echo # 4 locks (1 table, 1 partition lock/unlock)
SELECT COUNT(*) FROM t3;
DROP TABLE t3;

--echo #
--echo # Test insert select
--echo #
FLUSH STATUS;
TRUNCATE TABLE t2;
eval $get_handler_status_counts;
--echo # All partitions needs to be locked
--echo # 28 locks (table + 13 partition lock/unlock)
--echo # 1 commit
FLUSH STATUS;
INSERT INTO t2 SELECT a, b FROM t1 WHERE a IN (1,4);
eval $get_handler_status_counts;
--echo # All partitions in t2 needs to be locked (no propagation from t1 yet).
--echo # 2 partitions in t1 needs to be locked (for 1 and 4)
--echo # 34 locks (2 table + 15 partition lock/unlock)
--echo # 2 read_first, read_key and read_next.
--echo # 1 commit

--echo #
--echo # Test TRUNCATE PARTITION
--echo #
FLUSH STATUS;
ALTER TABLE t2 TRUNCATE PARTITION p1;
eval $get_handler_status_counts;
--echo # 4 locks (1 table, 1 partition lock/unlock)
INSERT INTO t2 SELECT a, b FROM t1 WHERE a = 1;

--echo #
--echo # Test insert on duplicated key update
--echo #
FLUSH STATUS;
INSERT INTO t1 VALUES (65, "No duplicate")
ON DUPLICATE KEY UPDATE b = CONCAT(b, ", INSERT_DUP_KEY_UPDATE");
eval $get_handler_status_counts;
--echo # 4 lock (1 table + 1 partition lock/unlock)
--echo # 1 write (insert)
--echo # 1 commit
FLUSH STATUS;
INSERT INTO t1 VALUES (65, "No duplicate")
ON DUPLICATE KEY UPDATE b = CONCAT(b, ", INSERT_DUP_KEY_UPDATE");
eval $get_handler_status_counts;
--echo # 4 lock (1 table + 1 partition lock/unlock)
--echo # 1 read_key
--echo # 1 update
--echo # 1 commit
FLUSH STATUS;
INSERT INTO t1 VALUES (78, "No duplicate")
ON DUPLICATE KEY UPDATE a = a + 13, b = CONCAT(b, ", INSERT_DUP_KEY_UPDATE");
eval $get_handler_status_counts;
--echo # If a partitioning column is updated, no pruning
--echo # 28 lock (1 table + 13 partition lock/unlock)
--echo # 1 write (insert)
--echo # 1 commit
FLUSH STATUS;
INSERT INTO t1 VALUES (78, "No duplicate")
ON DUPLICATE KEY UPDATE a = a + 13, b = CONCAT(b, ", INSERT_DUP_KEY_UPDATE");
eval $get_handler_status_counts;
--echo # If partitioning column is updated, no pruning
--echo # 28 lock (1 table + 13 partition lock/unlock)
--echo # 1 read_key
--echo # 1 update
--echo # 1 commit

--echo #
--echo # Test of failed update
--echo #
FLUSH STATUS;
INSERT INTO t1 VALUES (78, "No duplicate")
ON DUPLICATE KEY UPDATE a = a + 13,
                        b = CONCAT(b, ", INSERT_DUP_KEY_UPDATE third");
eval $get_handler_status_counts;
--echo # If partitioning column is updated, no pruning
--echo # 28 lock (1 table + 13 partition lock/unlock)
--echo # 1 commit
FLUSH STATUS;
--error ER_DUP_ENTRY
INSERT INTO t1 VALUES (78, "No duplicate")
ON DUPLICATE KEY UPDATE a = a + 13,
                        b = CONCAT(b, ", INSERT_DUP_KEY_UPDATE fail?");
eval $get_handler_status_counts;
--echo # If partitioning column is updated, no pruning
--echo # 28 lock (1 table + 13 partition lock/unlock)
--echo # 1 read_key
--echo # 1 update
--echo # 1 rollback

--echo #
--echo # Test of update to different partition
--echo #
FLUSH STATUS;
INSERT INTO t1 VALUES (104, "No duplicate")
ON DUPLICATE KEY UPDATE a = a + 1;
eval $get_handler_status_counts;
--echo # If partitioning column is updated, no pruning
--echo # 28 lock (1 table + 13 partition lock/unlock)
--echo # 1 write
--echo # 1 commit
FLUSH STATUS;
INSERT INTO t1 VALUES (104, "No duplicate")
ON DUPLICATE KEY UPDATE a = a + 1;
eval $get_handler_status_counts;
--echo # If partitioning column is updated, no pruning
--echo # 28 lock (1 table + 13 partition lock/unlock)
--echo # 1 delete
--echo # 1 write
--echo # 1 read_key
--echo # 1 commit
FLUSH STATUS;
INSERT INTO t1 VALUES (104, "No duplicate 104")
ON DUPLICATE KEY UPDATE a = a + 1;
eval $get_handler_status_counts;
--echo # If partitioning column is updated, no pruning
--echo # 28 lock (1 table + 13 partition lock/unlock)
--echo # 1 write
--echo # 1 commit
FLUSH STATUS;
--error ER_DUP_ENTRY
INSERT INTO t1 VALUES (104, "No duplicate 104 + 1")
ON DUPLICATE KEY UPDATE a = a + 1;
eval $get_handler_status_counts;
--echo # If partitioning column is updated, no pruning
--echo # 28 lock (1 table + 13 partition lock/unlock)
--echo # 1 write
--echo # 1 read_key
--echo # 1 rollback

--echo #
--echo # Test replace
--echo #
FLUSH STATUS;
REPLACE INTO t1 VALUES (5, "REPLACE first");
eval $get_handler_status_counts;
--echo # 4 lock (1 table + 1 partition lock/unlock)
--echo # 1 write
--echo # 1 commit
FLUSH STATUS;
REPLACE INTO t1 VALUES (5, "REPLACE second");
eval $get_handler_status_counts;
--echo # 4 lock (1 table + 1 partition lock/unlock)
--echo # 1 write
--echo # 1 read_key
--echo # 1 update (NOTE: write_record() may cheat instead of delete/insert!)
--echo # 1 rollback

--echo #
--echo # Test select
--echo #
FLUSH STATUS;
SELECT * FROM t1 ORDER BY a;
eval $get_handler_status_counts;
--echo # 28 locks
--echo # 13 read_first
--echo # 13 read_key
--echo # 15 read_next
FLUSH STATUS;
SELECT * FROM t1 WHERE a IN (0, 1, 4) ORDER BY a;
eval $get_handler_status_counts;
--echo # 8 locks (1 table + 3 partitions lock/unlock)
--echo # 3 read_first, read_key
--echo # 12 read_next
FLUSH STATUS;
--sorted_result
SELECT * FROM t1 WHERE a IN (13, 26, 39, 52);
eval $get_handler_status_counts;
--echo # 4 locks (1 table + 1 partitions lock/unlock)
--echo # 1 read_first, read_key
--echo # 9 read_next
FLUSH STATUS;
--sorted_result
SELECT * FROM t1 WHERE a = 3;
eval $get_handler_status_counts;
--echo # 4 locks
--echo # 1 read_key
FLUSH STATUS;
SELECT * FROM t1 WHERE b LIKE 'First%' ORDER BY a;
eval $get_handler_status_counts;
--echo # 28 locks
--echo # 13 read_key
--echo # 5 read_next

--echo #
--echo # Test EXPLAIN select
--echo #
FLUSH STATUS;
--sorted_result
EXPLAIN SELECT * FROM t1;
eval $get_handler_status_counts;
--echo # 28 locks (1 table + 13 partition lock/unlock)
FLUSH STATUS;
EXPLAIN SELECT * FROM t1 WHERE a IN (0, 1, 4) ORDER BY a;
eval $get_handler_status_counts;
--echo # 8 locks (1 table + 3 partition lock/unlock)
FLUSH STATUS;
--sorted_result
EXPLAIN SELECT * FROM t1 WHERE a IN (13, 26, 39, 52);
eval $get_handler_status_counts;
--echo # 4 locks (1 table + 1 partition lock/unlock)
FLUSH STATUS;
--sorted_result
EXPLAIN SELECT * FROM t1 WHERE a = 3;
eval $get_handler_status_counts;
--echo # 4 locks (1 table + 1 partition lock/unlock)
FLUSH STATUS;
EXPLAIN SELECT * FROM t1 WHERE b LIKE 'First%' ORDER BY a;
eval $get_handler_status_counts;
--echo # 28 locks (1 table + 13 partition lock/unlock)
FLUSH STATUS;
--sorted_result
EXPLAIN PARTITIONS SELECT * FROM t1;
eval $get_handler_status_counts;
--echo # 28 locks (1 table + 13 partition lock/unlock)
FLUSH STATUS;
EXPLAIN PARTITIONS SELECT * FROM t1 WHERE a IN (0, 1, 4) ORDER BY a;
eval $get_handler_status_counts;
--echo # 8 locks (1 table + 3 partition lock/unlock)
FLUSH STATUS;
--sorted_result
EXPLAIN PARTITIONS SELECT * FROM t1 WHERE a IN (13, 26, 39, 52);
eval $get_handler_status_counts;
--echo # 4 locks (1 table + 1 partition lock/unlock)
FLUSH STATUS;
--sorted_result
EXPLAIN PARTITIONS SELECT * FROM t1 WHERE a = 3;
eval $get_handler_status_counts;
--echo # 4 locks (1 table + 1 partition lock/unlock)
FLUSH STATUS;
EXPLAIN PARTITIONS SELECT * FROM t1 WHERE b LIKE 'First%' ORDER BY a;
eval $get_handler_status_counts;
--echo # 28 locks (1 table + 13 partition lock/unlock)

--echo #
--echo # Test pruning of non static values
--echo # They will need to lock all partitions, but will allow pruning
--echo # due to a second pruning call in optimize.
--echo # TODO: Partition wise joins ?
--echo #
CREATE TABLE t3 (a INT);
INSERT INTO t3 VALUES (1);
FLUSH STATUS;
SELECT * FROM t1 WHERE a = (SELECT a FROM t3);
eval $get_handler_status_counts;
--echo # 30 locks (2 table + 13 partitions lock/unlock)
--echo # 1 read_first (NOTE only reads from one partition!)
--echo # 2 read_key
--echo # 2 read_rnd_next
FLUSH STATUS;
SELECT t1.a FROM t1 INNER JOIN t3 ON t1.a = t3.a;
eval $get_handler_status_counts;
--echo # 30 locks (2 table + 13 partitions lock/unlock)
--echo # 1 read_first (NOTE only reads from one partition!)
--echo # 2 read_key
FLUSH STATUS;
EXPLAIN PARTITIONS SELECT t1.a, t1.b FROM t1 INNER JOIN t3 ON t1.a = t3.a;
eval $get_handler_status_counts;
--echo # 30 locks (2 table + 13 partitions lock/unlock)
FLUSH STATUS;
--echo # EXPLAIN does not evaluate SUBQUERIES, so pruning will not show!
EXPLAIN PARTITIONS SELECT * FROM t1 WHERE a = (SELECT a FROM t3);
eval $get_handler_status_counts;
--echo # 30 locks (2 table + 13 partitions lock/unlock)
FLUSH STATUS;
SELECT * FROM t1 WHERE a = 1;
eval $get_handler_status_counts;
--echo # 4 locks
--echo # 1 read_key
FLUSH STATUS;
SELECT * FROM t1 WHERE a = (SELECT COUNT(*) FROM t3);
eval $get_handler_status_counts;
--echo # 30 locks (2 table + 13 partitions lock/unlock)
--echo # 1 read_first
--echo # 2 read_key, read_rnd_next
--echo #
--echo # Test of non indexed partition column
--echo #
CREATE TABLE t4 SELECT a, b FROM t1;
ALTER TABLE t4 PARTITION BY HASH (a) PARTITIONS 5;
FLUSH STATUS;
SELECT * FROM t4 WHERE a = (SELECT a FROM t3);
eval $get_handler_status_counts;
--echo # 14 locks (2 tables + 5 partitions lock/unlock)
--echo # 2 read_first, read_key
--echo # 6 read_rnd_next
FLUSH STATUS;
EXPLAIN PARTITIONS SELECT * FROM t4 WHERE a = (SELECT a FROM t3);
eval $get_handler_status_counts;
--echo # 14 locks (2 tables + 5 partitions lock/unlock)
INSERT INTO t3 VALUES (3);
--error ER_SUBQUERY_NO_1_ROW
SELECT * FROM t4 WHERE a = (SELECT a FROM t3);
--error ER_SUBQUERY_NO_1_ROW
EXPLAIN PARTITIONS SELECT * FROM t4 WHERE a = (SELECT a FROM t3);
EXPLAIN PARTITIONS SELECT * FROM t4 WHERE a = (SELECT a FROM t3 LIMIT 1);
EXPLAIN PARTITIONS SELECT * FROM t4 WHERE a = (SELECT MAX(a) FROM t3);
DROP TABLE t3;
DROP TABLE t4;


--echo #
--echo # Test select * from (select * from ...)
--echo #
FLUSH STATUS;
SELECT * FROM (SELECT * FROM t1 WHERE a IN (0,2,3,13,26)) t3;
eval $get_handler_status_counts;
--echo # 8 locks (1 table + 3 partitions lock/unlock)
--echo # 3 read_first, read_key
--echo # 11 read_next
--echo # 6 read_rnd_next (tmp table)
FLUSH STATUS;
SELECT * FROM (SELECT * FROM (SELECT * FROM t1 WHERE a IN (0,2,3,13,26)) t3) t4;
eval $get_handler_status_counts;
--echo # 8 locks (1 table + 3 partitions lock/unlock)
--echo # 3 read_first, read_key
--echo # 11 read_next
--echo # 12 read_rnd_next (tmp table)


--echo #
--echo # Test EXPLAIN select * from (select * from ...)
--echo #
FLUSH STATUS;
EXPLAIN SELECT * FROM (SELECT * FROM t1 WHERE a IN (0,2,3,13,26)) t3;
eval $get_handler_status_counts;
--echo # 8 locks (1 table + 3 partitions lock/unlock)
FLUSH STATUS;
EXPLAIN SELECT * FROM (SELECT * FROM (SELECT * FROM t1 WHERE a IN (0,2,3,13,26)) t3) t4;
eval $get_handler_status_counts;
--echo # 8 locks (1 table + 3 partitions lock/unlock)

FLUSH STATUS;
EXPLAIN PARTITIONS SELECT * FROM (SELECT * FROM t1 WHERE a IN (0,2,3,13,26)) t3;
eval $get_handler_status_counts;
--echo # 8 locks (1 table + 3 partitions lock/unlock)
FLUSH STATUS;
EXPLAIN PARTITIONS SELECT * FROM (SELECT * FROM (SELECT * FROM t1 WHERE a IN (0,2,3,13,26)) t3) t4;
eval $get_handler_status_counts;
--echo # 8 locks (1 table + 3 partitions lock/unlock)


--echo #
--echo # Test select ... UNION select ...
--echo #
FLUSH STATUS;
--sorted_result
SELECT * FROM t1 UNION SELECT * FROM t2;
eval $get_handler_status_counts;
--echo # 56 locks (2 tables + 26 partitions lock/unlock)
FLUSH STATUS;
SELECT * FROM t1 WHERE a IN (0, 1, 13, 4) UNION SELECT * FROM t2;
eval $get_handler_status_counts;
--echo # 36 locks (2 tables, 13 + 3 partitions lock/unlock)
FLUSH STATUS;
SELECT * FROM (SELECT * FROM t1 WHERE a IN (0, 1, 13, 4)) t3 UNION SELECT * FROM t2;
eval $get_handler_status_counts;
--echo # 36 locks (2 tables, 13 + 3 partitions lock/unlock)
FLUSH STATUS;
SELECT * FROM (SELECT * FROM (SELECT * FROM t1 WHERE a IN (0, 1, 13, 4) UNION SELECT * FROM t2) t3) t4;
eval $get_handler_status_counts;
--echo # 36 locks (2 tables, 13 + 3 partitions lock/unlock)
FLUSH STATUS;
SELECT * FROM (SELECT * FROM (SELECT * FROM t1 WHERE a IN (0, 1, 13, 4)) t3 UNION SELECT * FROM t2) t4;
eval $get_handler_status_counts;
--echo # 36 locks (2 tables, 13 + 3 partitions lock/unlock)
FLUSH STATUS;
SELECT * FROM (SELECT * FROM (SELECT * FROM t1 WHERE a IN (0, 1, 13, 4)) t3) t4 UNION SELECT * FROM t2;
eval $get_handler_status_counts;
--echo # 36 locks (2 tables, 13 + 3 partitions lock/unlock)
FLUSH STATUS;
SELECT * FROM (SELECT * FROM (SELECT * FROM t1 WHERE a IN (0, 1, 13, 4)) t3 UNION SELECT * FROM t2 WHERE a = 1) t4;
eval $get_handler_status_counts;
--echo # 12 locks (2 tables, 3 + 1 partitions lock/unlock)


--echo #
--echo # Test EXPLAIN select ... UNION select ...
--echo #
FLUSH STATUS;
EXPLAIN SELECT * FROM t1 UNION SELECT * FROM t2;
eval $get_handler_status_counts;
--echo # 56 locks
FLUSH STATUS;
EXPLAIN SELECT * FROM t1 WHERE a IN (0, 1, 13, 4) UNION SELECT * FROM t2;
eval $get_handler_status_counts;
--echo # 36 locks (2 tables, 13 + 3 partitions lock/unlock)
FLUSH STATUS;
EXPLAIN SELECT * FROM (SELECT * FROM t1 WHERE a IN (0, 1, 13, 4)) t3 UNION SELECT * FROM t2;
eval $get_handler_status_counts;
--echo # 36 locks (2 tables, 13 + 3 partitions lock/unlock)
FLUSH STATUS;
EXPLAIN SELECT * FROM (SELECT * FROM (SELECT * FROM t1 WHERE a IN (0, 1, 13, 4) UNION SELECT * FROM t2) t3) t4;
eval $get_handler_status_counts;
--echo # 36 locks (2 tables, 13 + 3 partitions lock/unlock)
FLUSH STATUS;
EXPLAIN SELECT * FROM (SELECT * FROM (SELECT * FROM t1 WHERE a IN (0, 1, 13, 4)) t3 UNION SELECT * FROM t2) t4;
eval $get_handler_status_counts;
--echo # 36 locks (2 tables, 13 + 3 partitions lock/unlock)
FLUSH STATUS;
EXPLAIN SELECT * FROM (SELECT * FROM (SELECT * FROM t1 WHERE a IN (0, 1, 13, 4)) t3) t4 UNION SELECT * FROM t2;
eval $get_handler_status_counts;
--echo # 36 locks (2 tables, 13 + 3 partitions lock/unlock)
FLUSH STATUS;
EXPLAIN SELECT * FROM (SELECT * FROM (SELECT * FROM t1 WHERE a IN (0, 1, 13, 4)) t3 UNION SELECT * FROM t2 WHERE a = 1) t4;
eval $get_handler_status_counts;
--echo # 12 locks (2 tables, 3 + 1 partitions lock/unlock)

FLUSH STATUS;
EXPLAIN PARTITIONS SELECT * FROM t1 UNION SELECT * FROM t2;
eval $get_handler_status_counts;
--echo # 56 locks
FLUSH STATUS;
EXPLAIN PARTITIONS SELECT * FROM t1 WHERE a IN (0, 1, 13, 4) UNION SELECT * FROM t2;
eval $get_handler_status_counts;
--echo # 36 locks (2 tables, 13 + 3 partitions lock/unlock)
FLUSH STATUS;
EXPLAIN PARTITIONS SELECT * FROM (SELECT * FROM t1 WHERE a IN (0, 1, 13, 4)) t3 UNION SELECT * FROM t2;
eval $get_handler_status_counts;
--echo # 36 locks (2 tables, 13 + 3 partitions lock/unlock)
FLUSH STATUS;
EXPLAIN PARTITIONS SELECT * FROM (SELECT * FROM (SELECT * FROM t1 WHERE a IN (0, 1, 13, 4) UNION SELECT * FROM t2) t3) t4;
eval $get_handler_status_counts;
--echo # 36 locks (2 tables, 13 + 3 partitions lock/unlock)
FLUSH STATUS;
EXPLAIN PARTITIONS SELECT * FROM (SELECT * FROM (SELECT * FROM t1 WHERE a IN (0, 1, 13, 4)) t3 UNION SELECT * FROM t2) t4;
eval $get_handler_status_counts;
FLUSH STATUS;
EXPLAIN PARTITIONS SELECT * FROM (SELECT * FROM (SELECT * FROM t1 WHERE a IN (0, 1, 13, 4)) t3) t4 UNION SELECT * FROM t2;
eval $get_handler_status_counts;
--echo # 36 locks (2 tables, 13 + 3 partitions lock/unlock)
FLUSH STATUS;
EXPLAIN PARTITIONS SELECT * FROM (SELECT * FROM (SELECT * FROM t1 WHERE a IN (0, 1, 13, 4)) t3 UNION SELECT * FROM t2 WHERE a = 1) t4;
eval $get_handler_status_counts;
--echo # 12 locks (2 tables, 3 + 1 partitions lock/unlock)


--echo #
--echo # Test update
--echo #
SELECT * FROM t1 ORDER BY a;
--echo # This should be prunable (does not change the partitioning key)
FLUSH STATUS;
UPDATE t1 SET b = CONCAT(b, ", updated 1") WHERE a IN (13, 26, 39, 52);
eval $get_handler_status_counts;
--echo # 4 locks (1 table + 1 partition lock/unlock)
--echo # 4 read_key
--echo # 4 update
--echo #
--echo # This should not be prunable (only after implementing 'update pruning')
--echo # i.e if all changed partitioning field is set to constant values,
--echo # set lock_partitions to be a union of read_partition and the matching
--echo # partition for the constants. Easy if all partitioning fields are set,
--echo # probably needs a second round of prune_partitions() with these fields
--echo # set to see if possible to prune locks.
FLUSH STATUS;
UPDATE t1 SET a = 99, b = CONCAT(b, ", updated 2 -> p8") WHERE a = 13;
eval $get_handler_status_counts;
--echo # 28 locks (1 table + 13 partition lock/unlock)
--echo # 2 read_key
--echo # 1 read_rnd
--echo # 1 delete (due to moved to another partition)
--echo # 1 write
--echo #
--echo # This should use ha_update_row instead of ha_write_row + ha_delete_row
FLUSH STATUS;
UPDATE t1 SET a = 13 + 99, b = CONCAT(b, ", updated 3") WHERE a = 99;
eval $get_handler_status_counts;
--echo # 28 locks (1 table + 13 partition lock/unlock)
--echo # 2 read_key
--echo # 1 read_rnd
--echo # 1 update
--echo #
--echo # This should not be prunable (only after implementing
--echo # 'optimized update pruning', which will probably never happen, since
--echo # it depends on which partitioning type is used (for this only hash is
--echo # simple, but range and list is possible, key is very hard)
FLUSH STATUS;
UPDATE t1 SET a = a + 1, b = CONCAT(b, ", updated 4 -> p9") WHERE a = 112;
eval $get_handler_status_counts;
--echo # 28 locks (1 table + 13 partition lock/unlock)
--echo # 2 read_key
--echo # 1 read_rnd
--echo # 1 delete (due to moved to another partition)
--echo # 1 write
FLUSH STATUS;
UPDATE t1 SET b = CONCAT(b, ", same as min(a) + 2 in t2") WHERE a = (SELECT MIN(a) + 2 FROM t2);
eval $get_handler_status_counts;
--echo # 56 locks (2 tables, 13 + 13 partitions lock/unlock)
FLUSH STATUS;
UPDATE t1 SET b = CONCAT(b, ", max(a) in t2: ", (SELECT MAX(a) FROM t2)) WHERE a = 5;
eval $get_handler_status_counts;
--echo # 32 locks (2 tables, 1 + 13 partitions lock/unlock)

--echo #
--echo # Test multi table update
--echo #
SELECT * FROM t1 ORDER BY a;
SELECT * FROM t2 ORDER BY a;
FLUSH STATUS;
EXPLAIN UPDATE t1, t2
SET t1.b = CONCAT(t1.b, ", t2.b:", t2.b),
    t2.b = CONCAT(t2.b, ", t1.b:", t1.b)
WHERE t2.b = t1.b and t2.a = 4;
eval $get_handler_status_counts;
--echo # 32 locks (2 table, 13 + 1 partitions lock/unlock)
FLUSH STATUS;
EXPLAIN PARTITIONS UPDATE t1, t2
SET t1.b = CONCAT(t1.b, ", t2.b:", t2.b),
    t2.b = CONCAT(t2.b, ", t1.b:", t1.b)
WHERE t2.b = t1.b and t2.a = 4;
eval $get_handler_status_counts;
--echo # 32 locks (2 table, 13 + 1 partitions lock/unlock)
FLUSH STATUS;
UPDATE t1, t2
SET t1.b = CONCAT(t1.b, ", t2.b:", t2.b),
    t2.b = CONCAT(t2.b, ", t1.b:", t1.b)
WHERE t2.b = t1.b and t2.a = 4;
eval $get_handler_status_counts;
--echo # 32 locks (2 table, 13 + 1 partitions lock/unlock)
--echo # 15 read_key
--echo # 1 read_next, read_rnd
--echo # 2 rean_rnd_next
--echo # 2 update

--echo #
--echo # Test of views
--echo #
--echo # Found bug#13559657 (partition selection does not work with views)
FLUSH STATUS;
CREATE VIEW v1_25 AS SELECT a, b FROM t1 PARTITION (p2, p5);
eval $get_handler_status_counts;
--echo # No locks!
FLUSH STATUS;
CREATE VIEW v1_25_check AS SELECT a, b FROM t1 PARTITION (p2, p5) t1_alias WITH CHECK OPTION;
eval $get_handler_status_counts;
--echo # No locks!
FLUSH STATUS;
CREATE VIEW v1_9 AS SELECT a, b FROM t1 WHERE a = 9;
eval $get_handler_status_counts;
--echo # No locks!
FLUSH STATUS;
CREATE VIEW v1_9_check AS SELECT a, b FROM t1 WHERE a = 9 WITH CHECK OPTION;
eval $get_handler_status_counts;
--echo # No locks!
FLUSH STATUS;
CREATE VIEW v1_all AS SELECT a, b FROM t1;
eval $get_handler_status_counts;
--echo # No locks!
SELECT TABLE_NAME, CHECK_OPTION, IS_UPDATABLE, VIEW_DEFINITION
FROM INFORMATION_SCHEMA.VIEWS
WHERE TABLE_SCHEMA = 'test' AND TABLE_NAME LIKE 'v1_%';

FLUSH STATUS;
INSERT INTO v1_all VALUES (23, "Insert in v1_all");
eval $get_handler_status_counts;
--echo # 4 locks (1 table, 1 partition lock/unlock)

FLUSH STATUS;
INSERT INTO v1_25 VALUES (18, "Insert in v1_25");
eval $get_handler_status_counts;
--echo # 4 locks (1 table, 1 partition lock/unlock)

FLUSH STATUS;
--error ER_ROW_DOES_NOT_MATCH_GIVEN_PARTITION_SET
INSERT INTO v1_25 VALUES (17, "Insert in v1_25 fail");
eval $get_handler_status_counts;
--echo # 2 locks (1 table, 0 partition lock/unlock)

FLUSH STATUS;
INSERT IGNORE INTO v1_25 VALUES (17, "Insert ignore in v1_25");
eval $get_handler_status_counts;
--echo # 2 locks (1 table, 0 partition lock/unlock)

FLUSH STATUS;
INSERT INTO v1_25_check VALUES (31, "Insert in v1_25_check");
eval $get_handler_status_counts;
--echo # 4 locks (1 table, 1 partition lock/unlock)

--echo # Bug#13559657, this should fail!
FLUSH STATUS;
--error ER_ROW_DOES_NOT_MATCH_GIVEN_PARTITION_SET
INSERT INTO v1_25_check VALUES (30, "Insert in v1_25_check fail");
eval $get_handler_status_counts;
--echo # 2 locks (1 table, 0 partition lock/unlock)

FLUSH STATUS;
INSERT IGNORE INTO v1_25_check VALUES (30, "Insert ignore in v1_25_check");
eval $get_handler_status_counts;
--echo # 2 locks (1 table, 0 partition lock/unlock)

FLUSH STATUS;
INSERT INTO v1_9 VALUES (9, "Insert in v1_9");
eval $get_handler_status_counts;
--echo # 4 locks (1 table, 1 partition lock/unlock)

FLUSH STATUS;
INSERT INTO v1_9 VALUES (8, "Insert in v1_9 NO CHECK!");
eval $get_handler_status_counts;
--echo # 4 locks (1 table, 1 partition lock/unlock)

SELECT * FROM t1 WHERE a = 8;
--echo # DELETE will not find row not in view
FLUSH STATUS;
DELETE FROM v1_9_check WHERE a = 8;
eval $get_handler_status_counts;
--echo # 0 locks, impossible where!
--echo # TODO: See if the reviewer in optimizer notices the difference :)
--echo # I.e. EXPLAIN DELETE for non partitioned tables does not optimize this
--echo # as SELECT would!
EXPLAIN EXTENDED DELETE FROM v1_9_check WHERE a = 8;
EXPLAIN EXTENDED SELECT * FROM v1_9_check WHERE a = 8;
SELECT * FROM t1 WHERE a = 8;

FLUSH STATUS;
--error ER_VIEW_CHECK_FAILED
INSERT INTO v1_9_check VALUES (10, "Insert in v1_9_check fail");
eval $get_handler_status_counts;
--echo # 4 locks (1 table, 1 partition lock/unlock)

SELECT * FROM t1 WHERE a = 9;
FLUSH STATUS;
DELETE FROM v1_9_check WHERE a = 9;
eval $get_handler_status_counts;
--echo # 4 locks (1 table, 1 partition lock/unlock)

FLUSH STATUS;
INSERT INTO v1_9_check VALUES (9, "Insert in v1_9_check");
eval $get_handler_status_counts;

FLUSH STATUS;
--sorted_result
SELECT * FROM v1_9;
eval $get_handler_status_counts;
--echo # 4 locks (1 table, 1 partition lock/unlock)

FLUSH STATUS;
--sorted_result
SELECT * FROM v1_25;
eval $get_handler_status_counts;
--echo # 6 locks (1 table, 2 partition lock/unlock)

FLUSH STATUS;
--sorted_result
SELECT * FROM v1_all;
eval $get_handler_status_counts;
--echo # 28 locks (1 table, 13 partition lock/unlock)
DROP VIEW v1_all;
DROP VIEW v1_9, v1_9_check;
DROP VIEW v1_25, v1_25_check;

--echo #
--echo # Test CREATE SELECT
--echo #
FLUSH STATUS;
CREATE TABLE t3 SELECT a, b FROM t1 WHERE a IN (0, 1, 13, 113);
eval $get_handler_status_counts;
--echo # 10 locks (2 tables, 3 partitions lock/unlock)
SELECT * FROM t3 ORDER BY a;
DROP TABLE t3;
FLUSH STATUS;
CREATE TABLE t3 SELECT a, b FROM t1 WHERE b LIKE 'First%';
eval $get_handler_status_counts;
--echo # 30 locks (2 tables, 13 partitions lock/unlock)
SELECT * FROM t3 ORDER BY a;
DROP TABLE t3;

--echo #
--echo # Test Stored procedures
--echo #
--disable_warnings
DROP PROCEDURE IF EXISTS sp_insert;
DROP PROCEDURE IF EXISTS sp_insert_partition;
DROP PROCEDURE IF EXISTS sp_select_all;
DROP PROCEDURE IF EXISTS sp_select_exact;
DROP PROCEDURE IF EXISTS sp_select_partition;
DROP PROCEDURE IF EXISTS sp_select_range;
--enable_warnings
CREATE PROCEDURE sp_insert(a INT, b CHAR(16))
  INSERT INTO test.t1 VALUES (a, b);

delimiter |;
CREATE PROCEDURE sp_insert_partition(p CHAR(16), a INT, b CHAR(16))
BEGIN
  SET @str = CONCAT("INSERT INTO test.t1 PARTITION(", p, ") VALUES (?, ?)");
  SET @x = a, @y = b;
  PREPARE stmt FROM @str;
  EXECUTE stmt USING @x, @y;
END|
delimiter ;|

CREATE PROCEDURE sp_select_all()
  SELECT * FROM test.t1;

CREATE PROCEDURE sp_select_exact(x INT)
  SELECT * FROM test.t1 WHERE a = x;

delimiter |;
CREATE PROCEDURE sp_select_partition(p CHAR(16))
BEGIN
  SET @str = CONCAT("SELECT * FROM test.t1 PARTITION(", p, ")");
  PREPARE stmt FROM @str;
  EXECUTE stmt;
END|
delimiter ;|


CREATE PROCEDURE sp_select_range(x INT, y INT)
  SELECT * FROM test.t1 WHERE a between x and y;

FLUSH STATUS;
CALL sp_insert(313,"Test313");
eval $get_handler_status_counts;
--echo # 6 locks (proc table, t1 + 1 partition lock/unlock)
FLUSH STATUS;
CALL sp_insert_partition("p7", 98, "Test98");
eval $get_handler_status_counts;
--echo # 6 locks (proc table, t1 + 1 partition lock/unlock)
FLUSH STATUS;
--error ER_ROW_DOES_NOT_MATCH_GIVEN_PARTITION_SET
CALL sp_insert_partition("p8", 111, "Test111");
eval $get_handler_status_counts;
--echo # no proc locking since already in proc cache.
--echo # 2 locks (1 table, no partitions lock/unlock)
FLUSH STATUS;
CALL sp_insert_partition("p7,p8", 111, "Test111");
eval $get_handler_status_counts;
--echo # 4 locks (1 table, 1 partition lock/unlock)
FLUSH STATUS;
--sorted_result
CALL sp_select_all();
eval $get_handler_status_counts;
--echo # 30 locks (procs table, t1 + 13 partitions lock/unlock)
FLUSH STATUS;
--sorted_result
CALL sp_select_exact(98);
eval $get_handler_status_counts;
--echo # 6 locks (proc table, t1 + 1 partition lock/unlock)
FLUSH STATUS;
--sorted_result
CALL sp_select_partition("p7");
eval $get_handler_status_counts;
--echo # 6 locks (proc table, t1 + 1 partition lock/unlock)
FLUSH STATUS;
--sorted_result
CALL sp_select_partition("p8");
eval $get_handler_status_counts;
--echo # no proc locking since already in proc cache.
--echo # 4 locks (t1 + 1 partition lock/unlock)
FLUSH STATUS;
--sorted_result
CALL sp_select_partition("p7,p8");
eval $get_handler_status_counts;
--echo # 6 locks (t1 + 2 partitions lock/unlock)
FLUSH STATUS;
--sorted_result
CALL sp_select_range(1,5);
eval $get_handler_status_counts;
--echo # 14 locks (proc table, t1 + 5 partitions lock/unlock)
DROP PROCEDURE sp_insert;
DROP PROCEDURE sp_insert_partition;
DROP PROCEDURE sp_select_all;
DROP PROCEDURE sp_select_partition;
DROP PROCEDURE sp_select_range;
DROP PROCEDURE sp_select_exact;

--echo #
--echo # Test EXPLAIN delete
--echo #
SELECT * FROM t1 ORDER BY a;
FLUSH STATUS;
EXPLAIN DELETE FROM t1 WHERE a = 105;
eval $get_handler_status_counts;
--echo # 4 locks (1 table + 1 partition lock/unlock)
--echo # This EXPLAIN DELETE have an unstable row estimation.
FLUSH STATUS;
--replace_column 9 #
EXPLAIN DELETE FROM t1 WHERE b = "No duplicate";
eval $get_handler_status_counts;
--echo # 28 locks (1 table + 13 partition lock/unlock)
FLUSH STATUS;
EXPLAIN PARTITIONS DELETE FROM t1 WHERE a = 105;
eval $get_handler_status_counts;
--echo # 4 locks (1 table + 1 partition lock/unlock)
--echo # This EXPLAIN DELETE have an unstable row estimation.
FLUSH STATUS;
--replace_column 10 #
EXPLAIN PARTITIONS DELETE FROM t1 WHERE b = "No duplicate";
eval $get_handler_status_counts;
--echo # 28 locks (1 table + 13 partition lock/unlock)
--echo #
--echo # Test DELETE
--echo #
FLUSH STATUS;
DELETE FROM t1 WHERE a = 105;
eval $get_handler_status_counts;
--echo # 4 locks (1 table + 1 partition lock/unlock)
--echo # 1 read_key
--echo # 1 delete
FLUSH STATUS;
DELETE FROM t1 WHERE b = "No duplicate";
eval $get_handler_status_counts;
--echo # 28 locks (1 table + 13 partition lock/unlock)
--echo # 13 read_key
--echo # 1 read_next (if more matches after the first match)
--echo # 1 delete

--echo #
--echo # Test multi table delete
--echo #
SELECT * FROM t1 ORDER BY a;
SELECT * FROM t2 ORDER BY a;
FLUSH STATUS;
EXPLAIN DELETE t1, t2 FROM t1, t2
WHERE t1.a = t2.a AND t1.b = 'First row, p1';
eval $get_handler_status_counts;
--echo # 56 locks (2 tables + 26 partitions lock/unlock)
FLUSH STATUS;
EXPLAIN DELETE FROM t2, t1 USING t2, t1
WHERE t1.b = t2.b AND t2.a = 4;
eval $get_handler_status_counts;
--echo # 32 locks (2 tables , 13 + 1 partition lock/unlock)

FLUSH STATUS;
EXPLAIN PARTITIONS DELETE t1, t2 FROM t1, t2
WHERE t1.a = t2.a AND t1.b = 'First row, p1';
eval $get_handler_status_counts;
--echo # 56 locks (2 tables + 26 partitions lock/unlock)
FLUSH STATUS;
EXPLAIN PARTITIONS DELETE FROM t2, t1 USING t2, t1
WHERE t1.b = t2.b AND t2.a = 4;
eval $get_handler_status_counts;
--echo # 32 locks (2 tables , 13 + 1 partition lock/unlock)

FLUSH STATUS;
DELETE t1, t2 FROM t1, t2
WHERE t1.a = t2.a AND t1.b = 'First row, p1';
eval $get_handler_status_counts;
--echo # 56 locks (2 tables + 26 partitions lock/unlock)
--echo # 15 read_key
--echo # 1 read_next, read_rnd
--echo # 2 delete
FLUSH STATUS;
DELETE FROM t2, t1 USING t2, t1
WHERE t1.b = t2.b AND t2.a = 4;
eval $get_handler_status_counts;
--echo # 32 locks (2 tables , 13 + 1 partition lock/unlock)
--echo # 15 read_key
--echo # 1 read_next, read_rnd
--echo # 2 delete

SELECT * FROM t1 ORDER BY a;
SELECT * FROM t2 ORDER BY a;

--echo #
--echo # Test triggers
--echo #
CREATE TABLE t3
(old_a int,
 new_a int,
 old_b varchar(255),
 new_b varchar(255),
 key (new_a, new_b),
 key(new_b))
PARTITION BY HASH (new_a) PARTITIONS 5;

CREATE TRIGGER t1_after_insert AFTER INSERT
ON t1 FOR EACH ROW
INSERT INTO t3 VALUES (2, NEW.a, NULL, CONCAT("AI: ", NEW.b));

CREATE TRIGGER t1_after_update AFTER UPDATE
ON t1 FOR EACH ROW
INSERT INTO t3 VALUES (OLD.a, NEW.a, CONCAT("AU: ", OLD.b), CONCAT("AU: ", NEW.b));

FLUSH STATUS;
INSERT INTO t1 VALUES (2, "First row, p2")
ON DUPLICATE KEY UPDATE b = CONCAT(b, ", duplicate key 2");
eval $get_handler_status_counts;
--echo # 28 locks (3 tables, 1 + 5 + 5 partition lock/unlock)
--echo # (t1 to insert, t3 after insert trigger, t3 after update trigger)
SELECT * FROM t1 WHERE a = 2;

FLUSH STATUS;
REPLACE INTO t1 VALUES (0, "First row, p0 REPLACED");
eval $get_handler_status_counts;
--echo # 16 locks (2 tables, 1 + 5 partition lock/unlock)
--echo # (t1 to replace, t3 after insert trigger)
--echo # Note that since there is no delete trigger, REPLACE cheats by
--echo # doing update instead of delete+insert!
SELECT * FROM t1 WHERE a = 0;

FLUSH STATUS;
EXPLAIN PARTITIONS UPDATE t1 SET b = CONCAT(b, ", UPDATED2") WHERE a = 3;
eval $get_handler_status_counts;
--echo # 16 locks (2 tables, 1 + 5 partition lock/unlock)
--echo # (t1 to insert, t3 after update trigger)

CREATE TRIGGER t1_after_delete AFTER DELETE
ON t1 FOR EACH ROW
INSERT INTO t3 VALUES (OLD.a, NULL, CONCAT("AD: ", OLD.b), NULL);

FLUSH STATUS;
REPLACE INTO t1 VALUES (0, "First row, p0 REPLACED2");
eval $get_handler_status_counts;
--echo # 28 locks (3 tables, 1 + 5 + 5 partition lock/unlock)
--echo # (t1 to replace, t3 after insert trigger, t3 after delete trigger)
--echo # Note that now it does delete+insert instead, due to delete trigger!
SELECT * FROM t1 WHERE a = 0;

CREATE TRIGGER t1_before_delete BEFORE DELETE
ON t1 FOR EACH ROW
INSERT INTO t3 VALUES (OLD.a, NULL, CONCAT("BD: ", OLD.b), NULL);

FLUSH STATUS;
REPLACE INTO t1 VALUES (0, "First row, p0 REPLACED3");
eval $get_handler_status_counts;
--echo # 40 locks (4 tables, 1 + 5 + 5 + 5 partition lock/unlock)
--echo # (t1 to replace, t3 after insert trigger, t3 before delete trigger,
--echo #  t3 after delete trigger)
SELECT * FROM t1 WHERE a = 0;

CREATE TRIGGER t1_before_update BEFORE UPDATE
ON t1 FOR EACH ROW
INSERT INTO t3 VALUES (OLD.a, NEW.a, CONCAT("BU: ", OLD.b), CONCAT("BU: ", NEW.b));

FLUSH STATUS;
INSERT INTO t1 VALUES (2, "First row, p2")
ON DUPLICATE KEY UPDATE b = CONCAT(b, ", duplicate key 2");
eval $get_handler_status_counts;
--echo # No pruning possible, due to BEFORE UPDATE trigger
--echo # 64 locks (4 tables, 13 + 5 + 5 + 5 partitions lock/unlock)
--echo # t1, t3 after insert, t3 before update, t3 after update
SELECT * FROM t1 WHERE a = 2;

FLUSH STATUS;
REPLACE INTO t1 VALUES (0, "First row, p0 REPLACED4");
eval $get_handler_status_counts;
--echo # 40 locks (4 tables, 1 + 5 + 5 + 5 partition lock/unlock)
--echo # t1, t3 after insert, t3 before delete, t3 after delete
SELECT * FROM t1 WHERE a = 0;

FLUSH STATUS;
EXPLAIN PARTITIONS UPDATE t1 SET b = CONCAT(b, ", UPDATED2") WHERE a = 3;
eval $get_handler_status_counts;
--echo # 52 locks (3 tables, 13 + 5 + 5 partition lock/unlock)
--echo # t1, before update, after update
SELECT * FROM t1 WHERE a = 3;

FLUSH STATUS;
UPDATE t1 SET b = CONCAT(b, ", UPDATED2") WHERE a = 3;
eval $get_handler_status_counts;
--echo # 52 locks (3 tables, 13 + 5 + 5 partition lock/unlock)
--echo # t1, before update, after update
SELECT * FROM t1 WHERE a = 3;

# No EXPLAIN for INSERT's.
FLUSH STATUS;
INSERT INTO t1 VALUES (12, "First row, p12");
eval $get_handler_status_counts;
--echo # 16 locks (2 table, 1 + 5 partition lock/unlock)
--echo # t1, t3 after insert trigger

CREATE TRIGGER t1_before_insert BEFORE INSERT
ON t1 FOR EACH ROW
INSERT INTO t3 VALUES (1, NEW.a, NULL, CONCAT("BI: ", NEW.b));

FLUSH STATUS;
INSERT INTO t1 VALUES (11, "First row, p11");
eval $get_handler_status_counts;
--echo # Nothing can be pruned, due to triggers.
--echo # 52 locks (3 tables, 13 + 5 + 5 partition lock/unlock)
--echo # t1, t3 before insert, t3 after insert.

FLUSH STATUS;
EXPLAIN PARTITIONS DELETE FROM t1 WHERE a = 98;
eval $get_handler_status_counts;
--echo # 28 locks (3 tables, 1 + 5 + 5 partitions)
--echo # t1, t3 before delete trigger, t3 after delete trigger
--echo # part 7, part 0-4, part 0-4.
SELECT * FROM t1 ORDER BY a;
FLUSH STATUS;
DELETE FROM t1 WHERE a = 98;
eval $get_handler_status_counts;
--echo # 28 locks (3 tables, 1 + 5 + 5 partitions)
--echo # t1, t3 before delete trigger, t3 after delete trigger

INSERT INTO t2 VALUES (1, "First row, p1");
INSERT INTO t2 VALUES (3, "First row, p3");
CREATE TRIGGER t2_before_insert BEFORE INSERT
ON t2 FOR EACH ROW
SET NEW.a = NEW.a + 1;

--echo # Test that one cannot update a row in BEFORE UPDATE
--error ER_TRG_CANT_CHANGE_ROW
CREATE TRIGGER t2_before_update BEFORE UPDATE
ON t2 FOR EACH ROW
SET OLD.a = OLD.a - 1;

CREATE TRIGGER t2_before_update BEFORE UPDATE
ON t2 FOR EACH ROW
SET NEW.a = NEW.a - 1;

--echo # Test that one cannot update a row in BEFORE DELETE
--error ER_TRG_CANT_CHANGE_ROW
CREATE TRIGGER t2_before_delete BEFORE DELETE
ON t2 FOR EACH ROW
SET OLD.a = OLD.a - 1;

FLUSH STATUS;
INSERT INTO t2 VALUES (1, "Second row, p1");
eval $get_handler_status_counts;
--echo # 28 locks (1 tables, 13 partitions lock/unlock)
SELECT * FROM t2 ORDER BY a;

FLUSH STATUS;
--error ER_DUP_ENTRY
UPDATE t2 SET b = CONCAT(b, ", UPDATED3") WHERE a = 4;
eval $get_handler_status_counts;
--echo # 28 locks (1 tables, 13 partitions lock/unlock)

FLUSH STATUS;
UPDATE t2 SET b = CONCAT(b, ", UPDATED3") WHERE a = 1;
eval $get_handler_status_counts;
--echo # 28 locks (1 tables, 13 partitions lock/unlock)


SELECT * FROM t1 ORDER BY a;
SELECT * FROM t2 ORDER BY a;
--sorted_result
SELECT * FROM t3 ORDER BY new_a;
DROP TABLE t1, t2, t3;

--echo #
--echo # DO is not supported by WL#4443 !!!
--echo # Test of DO (eg. SELECT without returning values)
--echo #
CREATE TABLE t1 (a INT, b VARCHAR(66))
PARTITION BY HASH (a) PARTITIONS 3;
INSERT INTO t1 VALUES (1, "One"), (2, "Two"), (3, "Three"), (4, "Four"), (5, "Five"), (6, "Six"), (0, "Zero");
DO (SELECT a FROM t1);
FLUSH STATUS;
DO (SELECT @x:= b FROM t1 WHERE a = 5);
eval $get_handler_status_counts;
--echo # 8 locks (1 table + 3 partitions lock/unlock)
SELECT @x;
FLUSH STATUS;
DO (SELECT @x:= b FROM t1 WHERE a = 5 or a = 1 ORDER BY b LIMIT 1);
eval $get_handler_status_counts;
SELECT @x;

DROP TABLE t1;

--echo #
--echo # Test EXCHANGE PARTITION to only lock exchanged partition
--echo #
CREATE TABLE t1 (a INT, b VARCHAR(44));
CREATE TABLE t2 (a INT, b VARCHAR(44))
PARTITION BY HASH (a) PARTITIONS 3;
INSERT INTO t1 VALUES (10, "Ten"), (13, "Thirteen"), (16, "Sixteen");
INSERT INTO t2 VALUES (0, "Zero"), (1, "One"), (2, "Two"),
                      (3, "Three"), (4, "Four"), (5, "Five"),
                      (6, "Six"), (7, "Seven"), (8, "Eight");
FLUSH STATUS;
ALTER TABLE t2 EXCHANGE PARTITION p1 WITH TABLE t1;
eval $get_handler_status_counts;
--echo # 6 locks (2 table + 1 partition lock/unlock)
SELECT * FROM t1 ORDER BY a;
SELECT * FROM t2 ORDER BY a;
DROP TABLE t1, t2;

--echo #
--echo # Prepared statement
--echo #
CREATE TABLE t1 (N int, M tinyint)
PARTITION BY HASH (N) PARTITIONS 3; 
INSERT INTO t1 VALUES (1,0),(1,0),(2,0),(2,0),(3,0);
PREPARE stmt FROM 'UPDATE t1 AS P1 INNER JOIN (SELECT N FROM t1 GROUP BY N HAVING COUNT(M) > 1) AS P2 ON P1.N = P2.N SET P1.M = 2';
FLUSH STATUS;
EXECUTE stmt;
eval $get_handler_status_counts;
--echo # 16 locks (2 table + 6 partition lock/unlock)
SELECT * FROM t1 ORDER BY N, M;
DEALLOCATE PREPARE stmt;
PREPARE stmt FROM 'SELECT * FROM t1 WHERE N = 2';
FLUSH STATUS;
EXECUTE stmt;
eval $get_handler_status_counts;
--echo # 4 locks (1 table + 1 partition lock/unlock)
DROP TABLE t1;

--echo # Check if we can infer from condition on partition fields that 
--echo # no records will match.
CREATE TABLE t1 ( a int NOT NULL) PARTITION BY HASH(a) PARTITIONS 2;
INSERT INTO t1 VALUES (1),(2),(3);
FLUSH STATUS;
EXPLAIN SELECT * FROM t1 WHERE a=5 AND a=6;
eval $get_handler_status_counts;
--echo # 2 locks (1 table + 0 partition lock/unlock)
FLUSH STATUS;
SELECT * FROM t1 WHERE a=5 AND a=6;
eval $get_handler_status_counts;
--echo # 2 locks (1 table + 0 partition lock/unlock)
DROP TABLE t1;

--echo #
--echo # Test of subqueries in INSERT
--echo #
CREATE TABLE t1 (a INT, b VARCHAR(64));
INSERT INTO t1 VALUES (1, "test 1");
--error ER_PARSE_ERROR
INSERT INTO t1 VALUES (SELECT * FROM t1);
DROP TABLE t1;

--echo # TODO: Add variants for LOCK TABLES
--echo # TODO: Document that functions in WHERE clause can now be evaluated
--echo #       before any locks are taken (i.e. if optimization is possible
--echo #       before locking). Like GET_LOCK/RELEASE_LOCK ?

--echo # TODO: How to make a stored function or trigger prune?
--echo # Stored procedures does not prelock, so it will prune locks.
--echo # Stored functions, triggers and events prelocks all used tables
--echo # which makes prune locks impossible.


# NOTEs:
# 
# To investigate:
# * effects on replication (statement and row)
