/*
 * jtie_gcalls.hpp
 */

#ifndef jtie_gcalls_hpp
#define jtie_gcalls_hpp

//#include <cstring>
#include "helpers.hpp"


// ---------------------------------------------------------------------------
// infrastructure code (for generic wrapper function definitions)
// ---------------------------------------------------------------------------

template< void F() >
void
gcall(JNIEnv * env)
{
    TRACE("void gcall(JNIEnv *)");
    F();
}

template< typename JR, typename CR,
          CR F() >
JR
gcall(JNIEnv * env)
{
    TRACE("JR gcall(JNIEnv *)");
    CR cr = F();
    JR jr;
    // no need to check conv status
    convert< JR, CR >(env, jr, cr); // type conv
    return jr;
}

template< typename JP0, typename CP0,
          void F(CP0) >
void
gcall(JNIEnv * env, JP0 jp0)
{
    TRACE("void gcall(JNIEnv *, JP0)");
    CP0 cp0;
    if (convert< CP0, JP0 >(env, cp0, jp0) == 0) { // type conv
        F(cp0);
        release< CP0, JP0 >(env, cp0, jp0);
    }
/*
    CP0 cp0;
    if (convert< CP0, JP0 >(env, cp0, jp0)) // type conv
        goto free0;
    F(cp0);
    release< CP0, JP0 >(env, cp0, jp0);
free0:
    ;
*/
}

template< typename JP0, typename CP0,
          typename JP1, typename CP1,
          void F(CP0, CP1) >
void
gcall(JNIEnv * env, JP0 jp0, JP1 jp1)
{
    TRACE("void gcall(JNIEnv *, JP0, JP1)");
    CP0 cp0;
    if (convert< CP0, JP0 >(env, cp0, jp0) == 0) { // type conv
        CP1 cp1;
        if (convert< CP1, JP1 >(env, cp1, jp1) == 0) { // type conv
            F(cp0, cp1);
            release< CP1, JP1 >(env, cp1, jp1);
        }
        release< CP0, JP0 >(env, cp0, jp0);
    }
/*
    CP0 cp0;
    CP1 cp1;
    if (convert< CP0, JP0 >(env, cp0, jp0)) // type conv
        goto free0;
    if (convert< CP1, JP1 >(env, cp1, jp1)) // type conv
        goto free1;
    F(cp0, cp1);
    release< CP1, JP1 >(env, cp1, jp1);
free1:
    release< CP0, JP0 >(env, cp0, jp0);
free0:
    ;
*/
}

#endif // jtie_gcalls_hpp
