/*
 * jtie_tconv.cpp
 */

#ifndef jtie_tconv_hpp
#define jtie_tconv_hpp

#include <jni.h>
//#include <cstring>

#include "helpers.hpp"


// ---------------------------------------------------------------------------
// infrastructure code (for parameter/result type conversions...)
// ---------------------------------------------------------------------------

// returns
//   0:    function and release() will be called
//   otherwise: assert(env->ExceptionCheck()); release() will not be called
template< typename T, typename S >
int
convert(JNIEnv * env, T & t, S const & s)
{
    TRACE("int convert(JNIEnv *, T &, S const &)");
    t = s;
    return 0;
}

// may only call JNI functions that are safe for pending exception
template< typename T, typename S >
void
release(JNIEnv * env, T & t, S const & s)
{
    TRACE("void release(JNIEnv *, T &, S const &)");
}

// ---------------------------------------------------------------------------
/*
template<>
int
convert< jint, signed int >(JNIEnv * env, jint & j, signed int const & c)
{
    TRACE("int convert(JNIEnv *, jint &, const signed int &)");
    j = c;
    return 0;
}

template<>
int
convert< signed int, jint >(JNIEnv * env, signed int & c, jint const & j)
{
    TRACE("int convert(JNIEnv *, signed int & c, const jint & j)");
    c = j;
    return 0;
}

template<>
int
convert< jint, unsigned int >(JNIEnv * env, jint & j, unsigned int const & c)
{
    TRACE("int convert(JNIEnv *, jint &, const unsigned int &)");
    j = c;
    return 0;
}

template<>
int
convert< unsigned int, jint >(JNIEnv * env, unsigned int & c, jint const & j)
{
    TRACE("int convert(JNIEnv *, unsigned int & c, const jint & j)");
    c = j;
    return 0;
}
*/
// ---------------------------------------------------------------------------

// returns a value in big endian format
template<typename C>
C
big_endian(C c) 
{
    // test if big or little endian
    C r = 1;
    if(*(char *)&r == 0) {
        // big endian, ok
        return c;
    }
    
    // little-endian, reverse byte order (better: use optimized swap macros)
    const size_t n = sizeof(C);
    char *s = (char *)&c;
    char *t = (char *)&r;
    for (int i = n-1, j = 0; i >= 0; i--, j++)
        t[j] = s[i];
    return r;
}

class _j_m_BigInteger {};
typedef _j_m_BigInteger * j_m_BigInteger;

template< typename I >
int
convert(JNIEnv * env, j_m_BigInteger & j, I const & c)
{
    TRACE("int convert(JNIEnv *, j_m_BigInteger &, I const &)");

    // init target, even in case of errors (better: use exceptions)
    j = NULL;

    // construct a BigInteger object from a two-complements byte array
    const jsize n = sizeof(I);
    jbyteArray ja = env->NewByteArray(n);
    if (ja != NULL) {

        // ensure the byte array is in the expected big-endian format
        I cbe = big_endian(c);

        // copy the two's-compliment into the byte array
        const jbyte * b = reinterpret_cast<const jbyte *>(&cbe);
        env->SetByteArrayRegion(ja, 0, n, b);
        if (env->ExceptionCheck() == JNI_OK) {

            // get the BigInteger class object
            jclass sbClass = env->FindClass("java/math/BigInteger");
            if (sbClass != NULL) {

                // get the method ID for the BigInteger(byte[]) constructor
                jmethodID cid = env->GetMethodID(sbClass, "<init>", "([B)V");
                if (cid != NULL) {

                    // construct a BigInteger object from a byte array
                    jobject jo = env->NewObject(sbClass, cid, ja);
                    j = reinterpret_cast< j_m_BigInteger >(jo);
                }
            }
            env->DeleteLocalRef(sbClass);
        }
    }
    env->DeleteLocalRef(ja);

    return (j == NULL);
}

template<>
int
convert< j_m_BigInteger, const unsigned long long >(JNIEnv * env, j_m_BigInteger & j, const unsigned long long & c)
{
    TRACE("int convert(JNIEnv *, j_m_BigInteger &, const unsigned long long &)");
    return convert< unsigned long long >(env, j, c);
}

template<>
int
convert< j_m_BigInteger, const signed long long >(JNIEnv * env, j_m_BigInteger & j, const signed long long & c)
{
    TRACE("int convert(JNIEnv *, j_m_BigInteger &, const unsigned long long &)");
    return convert< signed long long >(env, j, c);
}

/*
// XXX provide a default jobject mapping for integral types?

template<>
int
convert< jobject, const unsigned long long >(JNIEnv * env, jobject & j, const unsigned long long & c)
{
    TRACE("int convert(JNIEnv *, jobject &, const unsigned long long &)");
    j_m_BigInteger & jj = reinterpret_cast< j_m_BigInteger & >(j);
    return convert< unsigned long long >(env, jj, c);
}

template<>
int
convert< jobject, const signed long long >(JNIEnv * env, jobject & j, const signed long long & c)
{
    TRACE("int convert(JNIEnv *, jobject &, const unsigned long long &)");
    j_m_BigInteger & jj = reinterpret_cast< j_m_BigInteger & >(j);
    return convert< signed long long >(env, jj, c);
}
*/

template<>
int
convert< unsigned long long, jobject >(JNIEnv * env, unsigned long long & c, jobject const & j)
{
    TRACE("int convert(JNIEnv *, unsigned long long & c, const jobject & j)");
    //c = j; // XXX
    return 0;
}

// ---------------------------------------------------------------------------

template<>
int
convert< jstring, const char * >(JNIEnv * env, jstring & j, const char * const & c)
{
    TRACE("int convert(JNIEnv *, jstring &, const char * const &)");

    // init target, even in case of errors (better: use exceptions)
    j = NULL;
    if (c == NULL)
        return 0;

    // construct a String object from a UTF-8 C string
    j = env->NewStringUTF(c);
    return (j == NULL);
}

template<>
int
convert< const char *, jstring >(JNIEnv * env, const char * & c, jstring const & j)
{
    TRACE("int convert(JNIEnv *, const char * &, jstring const &)");

    // init target, even in case of errors (better: use exceptions)
    c = NULL;
    if (j == NULL)
        return 0;

    // get a const UTF-8 string, to be released by ReleaseStringUTFChars()
    c = env->GetStringUTFChars(j, NULL);
    return (c == NULL);
}

template<>
void
release< const char *, jstring >(JNIEnv * env, const char * & c, jstring const & j)
{
    TRACE("void release(JNIEnv *, const char * &, jstring const &)");
    if (c == NULL) {
        assert(j == NULL);
        return;
    }
    assert(j);

    // release the UTF-8 string allocated by GetStringUTFChars()
    env->ReleaseStringUTFChars(j, c);
}

// ---------------------------------------------------------------------------

// define char* conversions to/from StringBuilder
// this type mapping is inefficient due to multiple copying operations
// but should serve as a more complex example

// defining a new type j_l_StringBuilder as an alias and leads to conflicting
// declaration errors when instantiating the function templates
//typedef jobject j_l_StringBuilder;

// defining *j_l_StringBuilder as a subclass of *jobject would rely on
// type name conventions in the JNI header jni.h
//class _j_l_StringBuilder : public _jobject {};
//typedef _j_l_StringBuilder *j_l_StringBuilder;

// so, we define j_l_StringBuilder as unrelated type and apply approriate
// reinterpret_casts where dealing with jobject
class _j_l_StringBuilder {};
typedef _j_l_StringBuilder *j_l_StringBuilder;

template<>
int
convert< j_l_StringBuilder, char * >(JNIEnv * env, j_l_StringBuilder & j, char * const & c)
{
    TRACE("int convert(JNIEnv *, j_l_StringBuilder &, char * const &)");

    // init target, even in case of errors (better: use exceptions)
    j = NULL;
    if (c == NULL)
        return 0;

    // init local resources (better: use RAII, try-finally)
    jstring js = NULL;
    jclass sbClass = NULL;
    jmethodID cid = NULL;
    
    // construct a String object from a UTF-8 C string
    js = env->NewStringUTF(c);
    if (js == NULL)
        goto free0;

    // get the StringBuilder class object
    sbClass = env->FindClass("java/lang/StringBuilder");
    if (sbClass == NULL)
        goto free1;
    
    // get the method ID for the StringBuilder(String) constructor
    cid = env->GetMethodID(sbClass, "<init>", "(Ljava/lang/String;)V");
    if (cid == NULL)
        goto free2;

    // construct a StringBuilder object from a String
    j = reinterpret_cast<j_l_StringBuilder>(env->NewObject(sbClass, cid, js));
 
    // free local resources
    ;
free2:
    env->DeleteLocalRef(sbClass);
free1:
    env->DeleteLocalRef(js);
free0:

    return (j == NULL);
}

template<>
int
convert< char *, j_l_StringBuilder >(JNIEnv * env, char * & c, j_l_StringBuilder const & j)
{
    TRACE("int convert(JNIEnv *, char * &, j_l_StringBuilder const &)");

    // init target, even in case of errors (better: use exceptions)
    c = NULL;
    if (j == NULL)
        return 0;

    // init local resources (better: use RAII, try-finally)
    jclass sbClass = NULL;
    jmethodID mid = NULL;
    jstring js = NULL;
    
    // get the StringBuilder class object
    sbClass = env->FindClass("java/lang/StringBuilder");
    if (sbClass == NULL)
        goto free0;
    
    // get the method ID for the StringBuilder.toString() method
    mid = env->GetMethodID(sbClass, "toString", "()Ljava/lang/String;");
    if (mid == NULL)
        goto free1;

    // static cast won't do for pointer types
    jobject jo = reinterpret_cast<jobject>(j);

    // get a String from the StringBuilder object
    js = static_cast<jstring>(env->CallObjectMethod(jo, mid));
    if (env->ExceptionCheck())
        goto free2;
 
    // get length in bytes of String, does not throw exceptions
    const jsize n = env->GetStringUTFLength(js);
    
    // allocate the C target string to hold UTF-8 copy of String
    c = new char[n];
    if (c == NULL) { // old C++ compilers may not raise an exception
        jclass oomec = env->FindClass("java'lang/OutOfMemoryError");
        if (oomec != NULL)
            env->ThrowNew(oomec, "JNI wrapper failed to allocate memory, "
                          " file: " __FILE__);
        env->DeleteLocalRef(oomec);
        goto free3;
    }
    
    // copy String as UTF-8 into the C target string
    env->GetStringUTFRegion(js, 0, n, c);
    if (env->ExceptionCheck()) {
        // release the C string
        delete[] c;
        c = NULL;
        goto free4;
    }
    assert(c[n - 1] == '\0');

    // free local resources
    ;
free4:
    ;
free3:
    env->DeleteLocalRef(js);
free2:
    ;
free1:
    env->DeleteLocalRef(sbClass);
free0:

    return (c == NULL);
}

template<>
void
release< char *, j_l_StringBuilder >(JNIEnv * env, char * & c, j_l_StringBuilder const & j)
{
    TRACE("void release(JNIEnv *, char * &, j_l_StringBuilder const &)");
    if (c == NULL) {
        assert(j == NULL);
        return;
    }
    assert(j);

    // release the C string
    delete[] c;
}

// ---------------------------------------------------------------------------

template<>
int
convert< jobject, char * >(JNIEnv * env, jobject & j, char * const & c)
{
    TRACE("int convert(JNIEnv *, jobject &, char * const &)");

    // init target, even in case of errors (better: use exceptions)
    j = NULL;
    if (c == NULL)
        return 0;

    // construct a direct java.nio.ByteBuffer wrapping the source
    // XXX how large to choose capacity?
    //jlong cap = (1<<31) - 1;
    // XXX SECURITY HOLE!!!
    jlong cap = 0;
    j = env->NewDirectByteBuffer(c, cap);

    return (j == NULL);
}

template<>
int
convert< char *, jobject >(JNIEnv * env, char * & c, jobject const & j)
{
    TRACE("int convert(JNIEnv *, char * &, jobject const &)");

    // init target, even in case of errors (better: use exceptions)
    c = NULL;
    if (j == NULL)
        return 0;

    // get the ByteBuffer class object
    jclass sbClass = env->FindClass("java/nio/ByteBuffer");
    if (sbClass != NULL) {
        // get the method ID for the ByteBuffer.asReadOnlyBuffer() method
        jmethodID mid = env->GetMethodID(sbClass, "isReadOnly", "()Z");
        if (mid != NULL) {
            // get a read-only copy from the ByteBuffer object
            jboolean ro = env->CallBooleanMethod(j, mid);
            if (!ro) {
                // get the direct java.nio.ByteBuffer's internal buffer address
                c = static_cast<char *>(env->GetDirectBufferAddress(j));
            }
        }
        env->DeleteLocalRef(sbClass);
    }

    return (c == NULL);
}

template<>
void
release< char *, jobject >(JNIEnv * env, char * & c, jobject const & j)
{
    TRACE("void release(JNIEnv *, char * &, jobject const &)");
}

// ---------------------------------------------------------------------------

template<>
int
convert< jobject, const void * >(JNIEnv * env, jobject & j, const void * const & c)
{
    TRACE("int convert(JNIEnv *, jobject &, const void * const &)");

    // init target, even in case of errors (better: use exceptions)
    j = NULL;
    if (c == NULL)
        return 0;

    // ok to remove constness here since wrapping with a read-only buffer
    void * mc = const_cast<void *>(c);

    // construct a direct java.nio.ByteBuffer wrapping the source
    // XXX how large to choose capacity?
    //jlong cap = (1<<31) - 1;
    // XXX SECURITY HOLE!!!
    jlong cap = 0;
    jobject jo = env->NewDirectByteBuffer(mc, cap);
    if (jo != NULL) {
        // get the ByteBuffer class object
        jclass sbClass = env->FindClass("java/nio/ByteBuffer");
        if (sbClass != NULL) {
            // get the method ID for the ByteBuffer.asReadOnlyBuffer() method
            jmethodID mid = env->GetMethodID(sbClass, "asReadOnlyBuffer",
                                             "()Ljava/nio/ByteBuffer;");
            if (mid != NULL) {
                // get a read-only copy from the ByteBuffer object
                j = static_cast<jobject>(env->CallObjectMethod(jo, mid));
            }
            env->DeleteLocalRef(sbClass);
        }
        env->DeleteLocalRef(jo);
    }
    
    return (j == NULL);
}

template<>
int
convert< const void *, jobject >(JNIEnv * env, const void * & c, jobject const & j)
{
    TRACE("int convert(JNIEnv *, const void * &, jobject const &)");

    // init target, even in case of errors (better: use exceptions)
    c = NULL;
    if (j == NULL)
        return 0;

    // get the direct java.nio.ByteBuffer's internal buffer address
    c = static_cast<const void *>(env->GetDirectBufferAddress(j));

    return (c == NULL);
}

template<>
void
release< const void *, jobject >(JNIEnv * env, const void * & c, jobject const & j)
{
    TRACE("void release(JNIEnv *, const void * &, jobject const &)");
}

// ---------------------------------------------------------------------------

template<>
int
convert< jobject, void * >(JNIEnv * env, jobject & j, void * const & c)
{
    TRACE("int convert(JNIEnv *, jobject &, void * const &)");

    // init target, even in case of errors (better: use exceptions)
    j = NULL;
    if (c == NULL)
        return 0;

    // construct a direct java.nio.ByteBuffer wrapping the source
    // XXX how large to choose capacity?
    //jlong cap = (1<<31) - 1;
    // XXX SECURITY HOLE!!!
    jlong cap = 0;
    j = env->NewDirectByteBuffer(c, cap);

    return (j == NULL);
}

template<>
int
convert< void *, jobject >(JNIEnv * env, void * & c, jobject const & j)
{
    TRACE("int convert(JNIEnv *, void * &, jobject const &)");

    // init target, even in case of errors (better: use exceptions)
    c = NULL;
    if (j == NULL)
        return 0;

    // get the ByteBuffer class object
    jclass sbClass = env->FindClass("java/nio/ByteBuffer");
    if (sbClass != NULL) {
        // get the method ID for the ByteBuffer.asReadOnlyBuffer() method
        jmethodID mid = env->GetMethodID(sbClass, "isReadOnly", "()Z");
        if (mid != NULL) {
            // get a read-only copy from the ByteBuffer object
            jboolean ro = env->CallBooleanMethod(j, mid);
            if (!ro) {
                // get the direct java.nio.ByteBuffer's internal buffer address
                c = static_cast<void *>(env->GetDirectBufferAddress(j));
            }
        }
        env->DeleteLocalRef(sbClass);
    }

    return (c == NULL);
}

template<>
void
release< void *, jobject >(JNIEnv * env, void * & c, jobject const & j)
{
    TRACE("void release(JNIEnv *, void * &, jobject const &)");
}

// ---------------------------------------------------------------------------

template<>
int
convert< jintArray, const signed int * >(JNIEnv * env, jintArray & j, const signed int * const & c)
{
    TRACE("int convert(JNIEnv *, jintArray &, const signed int * const &)");

    // init target, even in case of errors (better: use exceptions)
    j = NULL;
    if (c == NULL)
        return 0;

    // construct a Java array object from a C array
    // XXX how large to choose size?
    const jsize n = 0;
    j = env->NewIntArray(n);
    if (j != NULL) {
        // static cast won't do for pointer types
        const jint * cj = reinterpret_cast<const jint *>(c);
        env->SetIntArrayRegion(j, 0, n, cj);
        if (env->ExceptionCheck()) {
            env->DeleteLocalRef(j);
            j = 0;
        }
    }

    return (j == NULL);
}

template<>
int
convert< const signed int *, jintArray >(JNIEnv * env, const signed int * & c, jintArray const & j)
{
    TRACE("int convert(JNIEnv *, const signed int * &, jintArray const &)");

    // init target, even in case of errors (better: use exceptions)
    c = NULL;
    if (j == NULL)
        return 0;

    // get a C array, to be released by ReleaseIntArrayElements()
    // ignore whether C array is pinned or a copy of Java array
    jint * cj = env->GetIntArrayElements(j, NULL);

    // static cast won't do for pointer types
    c = reinterpret_cast<const signed int *>(cj);

    return (c == NULL);
}

template<>
void
release< const signed int *, jintArray >(JNIEnv * env, const signed int * & c, jintArray const & j)
{
    TRACE("void release(JNIEnv *, const signed int * &, jintArray const &)");
    if (c == NULL) {
        assert(j == NULL);
        return;
    }
    assert(j);

    // reinterpret cast won't do for removing constness
    signed int * mc = const_cast<signed int *>(c);

    // static cast won't do for pointer types
    jint * cj = reinterpret_cast<jint *>(mc);

    // release the C array allocated by GetIntArrayElements()
    // if C array was a copy, discard any changes since contracted as const
    env->ReleaseIntArrayElements(j, cj, JNI_ABORT);
}

// ---------------------------------------------------------------------------

template<>
int
convert< jintArray, signed int * >(JNIEnv * env, jintArray & j, signed int * const & c)
{
    TRACE("int convert(JNIEnv *, jintArray &, signed int * const &)");

    // init target, even in case of errors (better: use exceptions)
    j = NULL;
    if (c == NULL)
        return 0;

    // construct a Java array object from a C array
    // XXX how large to choose size?
    const jsize n = 0;
    j = env->NewIntArray(n);
    if (j != NULL) {
        // static cast won't do for pointer types
        jint * cj = reinterpret_cast<jint *>(c);
        env->SetIntArrayRegion(j, 0, n, cj);
        if (env->ExceptionCheck()) {
            env->DeleteLocalRef(j);
            j = 0;
        }
    }

    return (j == NULL);
}

template<>
int
convert< signed int *, jintArray >(JNIEnv * env, signed int * & c, jintArray const & j)
{
    TRACE("int convert(JNIEnv *, signed int * &, jintArray const &)");

    // init target, even in case of errors (better: use exceptions)
    c = NULL;
    if (j == NULL)
        return 0;

    // get a C array, to be released by ReleaseIntArrayElements()
    // ignore whether C array is pinned or a copy of Java array
    jint * cj = env->GetIntArrayElements(j, NULL);

    // static cast won't do for pointer types
    c = reinterpret_cast<signed int *>(cj);

    return (c == NULL);
}

template<>
void
release< signed int *, jintArray >(JNIEnv * env, signed int * & c, jintArray const & j)
{
    TRACE("void release(JNIEnv *, signed int * &, jintArray const &)");
    if (c == NULL) {
        assert(j == NULL);
        return;
    }
    assert(j);

    // static cast won't do for pointer types
    jint * cj = reinterpret_cast<jint *>(c);

    // release the C array allocated by GetIntArrayElements()
    // if C array was a copy, copy back any changes to Java array
    env->ReleaseIntArrayElements(j, cj, 0);
}

#endif // jtie_tconv_hpp
